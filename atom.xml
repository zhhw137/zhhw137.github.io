<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhhw的Blog</title>
  
  <subtitle>记录java学习成长</subtitle>
  <link href="https://zhhw137.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhhw137.github.io/"/>
  <updated>2020-11-02T01:17:52.170Z</updated>
  <id>https://zhhw137.github.io/</id>
  
  <author>
    <name>zhhw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis</title>
    <link href="https://zhhw137.github.io/2020/10/15/redis%E7%AF%87/"/>
    <id>https://zhhw137.github.io/2020/10/15/redis%E7%AF%87/</id>
    <published>2020-10-15T13:30:00.000Z</published>
    <updated>2020-11-02T01:17:52.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本章节根据《Redis设计与实现》和笔者自身理解所写</p><a id="more"></a><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>定义：SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;<span class="comment">//记录buf数组中已使用的字节的数量，也就是sds所保存的字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;<span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">char</span> buf[];<span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>redis的字符串也就是sds的特殊<ul><li>O(1)复杂度获得长度</li><li>杜绝缓冲区溢出（因为知道长度，可以先检测下，不够扩容）</li><li>空间预分配：扩展SDS空间前，判断free空间是否足够，足够会直接使用而无须执行内存重分配<ul><li>处理后SDS大小大于1MB，则预分配1MB到free（未使用空间）</li><li>处理后SDS大小不大于1MB，则预分配同样大小到free空间。</li></ul></li><li>惰性空间释放<ul><li>执行SDS缩短操作时不会释放空间，而是转到free空间记录。等待下次使用。避免了缩短字符串的所需的内存重分配</li><li>提供API释放SDS的未使用空间，避免内存浪费</li></ul></li><li>二进制安全：使用len来判断字符串是否结束，避免了像C语言那样，因为空字符而提前结束。所以redis可以保存任意格式的二进制数据</li><li>兼容部分C语言函数：因为SDS也以空字符作为结尾，所以可以兼容</li></ul></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p>定义</p><ul><li><p>链表节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span><span class="comment">//前置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span><span class="comment">//后置节点</span></span><br><span class="line"><span class="keyword">void</span> *value;<span class="comment">//节点的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    listNode *head;<span class="comment">//表头节点</span></span><br><span class="line">    listNode *tail;<span class="comment">//表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;<span class="comment">//链表包含的节点数量</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);<span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);<span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);<span class="comment">//节点值对比函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特性</p><ul><li>双端：链表节点有next和pre指针，获取某个节点的前置节点和后置节点时间复杂度O(1)</li><li>无环：表头节点的pre指针和表尾节点的next指针都指向null，对链表的访问以null为终点</li><li>带表头指针和表尾指针：通过list结构的head和tail指针，获取表头节点和表尾节点的时间复杂度O(1)</li><li>带链表长度计数器：程序使用len属性，对list结构持有的链表节点数进行计数</li><li>多态：链表节点使用void*指针保存节点值，并且可以通过list结构的dup，free，match三个属性为节点值设置类型特定函数（根据不同类型都有一套方法实现），所以链表可以用于保存各种不同类型的值。</li></ul></li></ul><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ul><li><p>定义：字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。</p><ul><li><p>哈希表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    dictEntry **table;<span class="comment">//哈希表数组</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;<span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">//哈希表大小掩码，用于计算索引值 总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哈希表节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;   <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v; <span class="comment">//值，3选一，可以是对象，或者uint64_t整数，或者int64_t整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//指向下个哈希表节点，形成链表。类似于map，用以解决键冲突问题。</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></li><li><p>字典</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type; <span class="comment">//类型特定函数：保存一簇用于操作特定类型键值对的函数，针对不同类型的键值对，为创建多态字典而设置。为不同的字典设置不同的类型特定函数。</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">//私有数据：保存需要传给那些类型特定函数的可选参数</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">//哈希表：一般使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">//rehash索引，当rehash不在进行时，值为-1；记录rehash目前的进度.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型特定函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictype</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2) <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDestructor)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDestructor)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);<span class="comment">//销毁值的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>哈希算法：先计算哈希值，再计算索引值，再放在指定索引上面</p></li><li><p>键冲突：头插法的链地址法解决冲突</p></li><li><p>rehash（重新散列）（理论）</p><ul><li>ht[1]哈希表分配空间：<ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n（2的n次方幂）</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n（2的n次方幂</li></ul></li><li>将ht[0]中的所有键值对rehash到ht[1]上面（即重新计算键的哈希值和索引值，然后放到ht[1]的指定位置上）</li><li>释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]上新创建一个空白哈希表（没有分配空间），为下一次rehash做准备。</li><li>负载因子计算公式：load_factor=ht[0].used/ht[0].size    负载因子=哈希表已保存节点数/哈希表大小</li><li>哈希表自动扩展触发条件：<ul><li>服务器没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1.</li><li>服务器正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5.</li></ul></li><li>哈希表自动收缩触发条件：负载因子小于0.1</li></ul></li><li><p>渐进式rehash（实际）（避免了集中rehash带来的庞大计算量）（这一时期的删查改在俩个哈希表中进行，但是增加只在ht[1]中）</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]俩个哈希表。</li><li>在字典中维持一个索引计数器变量，rehashidx,并设置为0，标识rehash工作正式开始</li><li>在rehash进行期间，每次对字典执行增删改查时，程序除了执行指定操作以外，还会顺带将rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作不断执行，最终某个节点，ht[0]所有键值对都rehash到ht[1]上了，这时将rehashidx设置为-1。标识rehash完成。</li></ol></li></ul><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><ul><li><p>定义：是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的，时间复杂度O（logN）。只在redis里俩个地方运用:一个是实现有序集合键(如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现)，另一个是在集群节点中用作内部数据结构</p><ul><li>跳跃表节点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">//前进指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;<span class="comment">//跨度：用于记录俩个节点之间的距离，跨度越大相距越远，指向null的前进指针跨度为0.</span></span><br><span class="line">    &#125;<span class="comment">//层（类似于抽取关键词，方便快速查找）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> *<span class="title">backward</span>;</span><span class="comment">//后退指针</span></span><br><span class="line">    <span class="keyword">double</span> score;<span class="comment">//分值是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序（分值相同时，按照对象排序，小的在前）</span></span><br><span class="line">    robj *obj;<span class="comment">//成员对象是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值（唯一）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>跳跃表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    structz skiplistNode *header,*tail;<span class="comment">//表头和表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;<span class="comment">//表中节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> level;<span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><ul><li><p>定义：是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;<span class="comment">//编码方式：INTSET_ENC_INT16，INTSET_ENC_INT32，INTSET_ENC_INT64</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;<span class="comment">//元素数量</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];<span class="comment">//不重复的整数集合，数值按从小到大有序排列，实际值类型，按照encoding设定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>升级（每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade）就是进行编码方式的升级，从而导致整个整数集合升级）</p><ul><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ul></li><li><p>升级的好处</p><ul><li>提升灵活性：不用担心存放数据的类型</li><li>节约内存:只有必要的时候才进行升级，使用打的编码表示小的数。（在保持灵活性的情况下，不然的话数据结构会比较复杂）</li></ul></li></ul><h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><ul><li><p>定义：<strong>列表键和哈希键的底层实现之一</strong>，压缩列表是Redis<strong>为了节约内存而开发的</strong>，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><ul><li>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</li><li>当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</li></ul></li><li><p>构成</p><ul><li><p>压缩列表</p><table><thead><tr><th>属性</th><th>类型</th><th>长度</th><th>用途</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4字节</td><td>记录整个压缩列表占用的内存字节数</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址字节数，这个偏移量，定位表尾节点地址</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2字节</td><td>记录压缩列表包含的节点数量，这个值小于UINT6_MAX(65535)时其值即为节点数量，等于时，需要遍历整个压缩列表计算</td></tr><tr><td>entryX</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1字节</td><td>特殊值0xFF(255),用于标记压缩列表的末端</td></tr></tbody></table></li><li><p>压缩列表节点</p><ul><li>previous_entry_length（因为存的是前一个字节的长度，如果我们有一个指向当前节点起始地址的指针c，那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针p，从表尾向表头遍历操作使用这一原理实现的）<ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面</li><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面</li></ul></li><li>encoding：记录了节点的content属性所保存数据的类型以及长度<ul><li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录</li><li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录</li></ul></li><li>content：负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定</li></ul></li><li><p>连锁更新</p><ul><li>表头添加个长度大于等于254字节的节点，导致后面本来previous_entry_length为1字节的节点，变为4字节，需要对压缩列表执行空间重分配操作，以此类推，程序不断地执行空间重分配操作。此为连锁更新（删除节点同理也可以导致连锁更新）</li><li>尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：<ul><li>❑首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li><li>❑其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul></li></ul></li></ul></li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul><li><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;<span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;<span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">int</span> refcount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;<span class="comment">//对象最后一次被命令程序访问的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>type类型(键总是一个字符串对象，值才是type的各种对象)</p><table><thead><tr><th>类型常量</th><th>对象的名称</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>字符串对象</td></tr><tr><td>REDIS_LIST</td><td>列表对象</td></tr><tr><td>REDIS_HASH</td><td>哈希对象</td></tr><tr><td>REDIS_SET</td><td>集合对象</td></tr><tr><td>REDIS_ZSET</td><td>有序集合对象</td></tr></tbody></table></li><li><p>encoding记录对象所使用的编码，也就是决定数据结构的底层实现</p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th><th>类型</th></tr></thead><tbody><tr><td>REDIS_ENCODING_INT</td><td>long类型的整数</td><td>字符串可用</td></tr><tr><td>REDIS_ENCODING_EMBSTR</td><td>embstr编码的简单动态字符串</td><td>字符串</td></tr><tr><td>REDIS_ENCODING_RAW</td><td>简单动态字符串</td><td>字符串</td></tr><tr><td>REDIS_ENCODING_HT</td><td>字典</td><td>哈希、集合</td></tr><tr><td>REDIS_ENCODING_LINKEDLIST</td><td>双端链表</td><td>列表</td></tr><tr><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表</td><td>列表、哈希、有序集合</td></tr><tr><td>REDIS_ENCODING_INTSET</td><td>整数集合</td><td>集合</td></tr><tr><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表和字典</td><td>有序集合</td></tr></tbody></table></li><li><p>ptr内容，用具体的数据结构实现</p></li><li><p>字符串对象是唯一一种会被其他四种类型对象嵌套的对象</p></li></ul></li><li><p>字符串对象 （编码：int，embstr，raw）</p><ul><li>3种结构的区别<ul><li>如果一个字符串对象保存的是<strong>整数值</strong>，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int</li><li>可以用long double类型表示的<strong>浮点数</strong>在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li><li>embstr编码是专门用于保存短字符串的一种优化编码方式，相较于raw，内存分配、释放从俩次降低为一次，embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以更好地利用缓存带来的优势。</li></ul></li><li>编码的转换<ul><li>对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw（不论是编程字符串还是浮点数）</li><li>embstr编码的字符串对象实际上是只读的：redis没有为这个编码的字符串对象编写修改程序；所以一旦embstr编码的字符串对象执行了修改命令，就会变为一个raw编码的字符串对象</li></ul></li></ul></li><li><p>列表对象（编码：ziplist，linkedlist）</p><ul><li>编码转换：满足以下俩个条件时，才可以使用（这两个条件的上限值是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明）<ul><li>列表对象保存的所有字符串元素的长度都64字节</li><li>列表对象保存的元素数量小于512个</li></ul></li></ul></li><li><p>哈希对象（编码ziplist或者hashtable）</p><ul><li>俩种结构区别：<ul><li>ziplist会按照加入列表顺序，同时键值对紧挨着类似：name,tom,age,23这样</li><li>使用hashtable则会将内容变成字典键值，类似于age：25；name：tom这样</li></ul></li><li>编码转换：当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码（这两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明）<ul><li>哈希对象保存的所有键值对的<strong>键和值</strong>的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；</li></ul></li></ul></li><li><p>集合对象（编码intset和hashtable）</p><ul><li>俩种结构的区别<ul><li>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</li><li>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</li></ul></li><li>编码的转换：当集合对象可以同时满足以下两个条件时，对象使用intset编码；第二个条件的上限值是可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明<ul><li>集合对象保存的所有元素都是整数值</li><li>集合对象保存的元素数量不超过512个</li></ul></li></ul></li><li><p>有序集合对象（编码ziplist和skiplist）</p><ul><li><p>每个元素的成员是一个字符串对象，分值是一个double类型的浮点数</p></li><li><p>俩种结构的区别</p><ul><li><p>压缩列表：每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）；集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向</p></li><li><p>zset结构作为底层实现（字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何内存）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist *zsl;<span class="comment">//跳跃表</span></span><br><span class="line">    dict *dict;<span class="comment">//字典</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的</li><li>zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O（1）复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性</li></ul></li></ul></li><li><p>编码的转换：当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码；两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明</p><ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素成员的长度都小于64字节</li></ul></li></ul></li><li><p>命令</p><ul><li>可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等（基于类型的多态）</li><li>另一种命令只能对特定类型的键执行（也即为根据redisObject的type属性决定）<ul><li>SET、GET、APPEND、STRLEN等命令只能对字符串键执行</li><li>HDEL、HSET、HGET、HLEN等命令只能对哈希键执行</li><li>RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行</li><li>SADD、SPOP、SINTER、SCARD等命令只能对集合键执行</li><li>ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行</li></ul></li><li>多态命令：Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令（如列表对象，ziplist和linkedlist俩种编码，则分别用压缩列表API和双端链表API来实现）（基于编码的多态）</li></ul></li><li><p>内存回收</p><ul><li>引用计数技术实现内存回收机制。</li><li>使用redisObject的refcount属性记录<ul><li>创建新对象，引用计数的值初始化为1</li><li>对象被新程序使用时，引用计数值加1</li><li>对象不再被一个程序使用时，引用计数值减1</li><li>对象的引用计数值变为0时，对象所占用内存会被释放</li></ul></li></ul></li><li><p>对象共享</p><ul><li>redis初始化服务器时，创建一万个字符串对象，这些对象包含0到9999的所有整数值。这些对象的使用可以进行对象共享而不是重新创建</li><li>创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改。</li><li>Redis只共享整数值的字符串对象，其他对象越复杂时间复杂度会越高，消耗CPU时间会越高（如字符串值的字符串对象O(N),而整数只有O(1)）</li></ul></li><li><p>对象的空转时长</p><ul><li>OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的</li><li>OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性</li><li>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</li></ul></li></ul><h2 id="单机数据库的实现"><a href="#单机数据库的实现" class="headerlink" title="单机数据库的实现"></a>单机数据库的实现</h2><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li><p>结构（服务器结构）</p><ul><li>所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中</li><li>db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库</li><li>int dbnum（redisServer中的结构）属性决定创建多少数据库，服务器配置的database选项决定，默认16</li></ul></li><li><p>切换</p><ul><li>客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针</li><li>默认0号数据库；命令select 2切换为2号数据库</li></ul></li><li><p>数据库结构</p><ul><li>服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）</li><li>键空间的键也就是数据库的键一定是字符串对象；键空间的值也就是数据库的值，是5种对象中任意一种redis对象</li><li>键空间操作：添加、删除、更新、取值等操作</li><li>其他键空间操作：用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的；另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的</li><li>读写键空间的额外操作<ul><li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作</li><li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知</li></ul></li></ul></li></ul><h4 id="过期键"><a href="#过期键" class="headerlink" title="过期键"></a>过期键</h4><ul><li><p>过期时间</p><ul><li>设置过期时间(4种命令的底层都是PEXPIREAT命令)<ul><li>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒</li><li>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒</li><li>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳</li><li>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳</li></ul></li><li>保存过期时间（expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典）<ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳</li></ul></li><li>移除过期时间<ul><li>PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。（示例PERSIST book）</li></ul></li><li>计算并返回剩余生存时间<ul><li>TTL命令以秒为单位返回键的剩余生存时间</li><li>而PTTL命令则以毫秒为单位返回键的剩余生存时间</li></ul></li><li>过期键判断<ul><li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</li><li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期</li><li>实现过期键判定的另一种方法是使用TTL命令或者PTTL命令，比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。在实际中，Redis检查键是否过期的方法和is_expired函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些</li></ul></li></ul></li><li><p>过期键删除策略</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作<ul><li>优点：及时释放内存</li><li>缺点：占用CPU时间，同时，redis定时器是用时间事件实现，底层为无序链表，查找一个事件时间复杂度为O(N)，所以不能高效的处理。因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实</li></ul></li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键<ul><li>优点：CPU时间占用上友好，删除过期键只会在非做不可时进行。</li><li>缺点，对内存释放不利，甚至极端情况下可以理解为内存泄漏</li></ul></li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定<ul><li>前俩者的折中处理：每隔一段时间执行一次删除过期键的操作。并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。（这里没有保存惰性删除策略）</li><li>所以CPU时间和频率决定了定期删除策略会不会退化成惰性或者定时</li></ul></li></ul></li><li><p>Redis的过期键删除策略</p><ul><li>惰性删除策略的实现：db.c/expireIfNeeded函数（所有Redis命令执行前都会调用）<ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作</li></ul></li><li>定期删除策略的实现: redis.c/activeExpireCycle函数实现,该函数周期性执行，同时周期性调用activeExpireCycle函数<ul><li>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键</li><li>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键</li><li>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作</li></ul></li></ul></li><li><p>AOF、RDB和复制功能对过期键的处理</p><ul><li>生成RDB文件：在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中</li><li>载入RDB文件<ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响</li></ul></li><li>AOF文件写入：如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响；当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除</li><li>AOF文件重写：在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中</li><li>复制：从服务器的过期键删除动作由主服务器控制；只有主服务器向从服务器发送了DEL命令，从服务器才会删除过期键，其他时候从服务器当这个过期键没有过期继续使用（数据一致性）</li></ul></li><li><p>数据库通知</p><ul><li><p>键空间通知（key-space notification）：以键为主体的，关注某个键执行了什么命令的通知</p></li><li><p>键事件通知（key-event notification）：以事件为主体的，关注某个命令被什么键执行了</p></li><li><p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型</p><ul><li>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE</li><li>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK</li><li>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE</li><li>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$</li><li>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El</li></ul></li><li><p>发送通知</p><ul><li>由notify.c/notifyKeyspaceEvent函数实现的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeySpaceEvent</span><span class="params">(<span class="keyword">int</span> type,<span class="comment">//当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">char</span> *event,<span class="comment">//事件的名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        robj *key,<span class="comment">//产生事件的键</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> dbid<span class="comment">//产生事件的数据库号码)</span></span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><ul><li><p>数据库状态：将服务器中的非空数据库以及它们的键值对统称数据库状态</p></li><li><p>RDB文件的创建（rdbSave）</p><ul><li>SAVE命令：阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，所有客户端发送的命令请求都会被拒绝</li><li>BGSAVE：派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求（父进程继续处理命令请求，并通过轮询等待子进程信号）；但是其中：SAVE命令和BGSAVE命令都会被拒绝，防止产生竞争条件。BGREWRITEAOF命令会被延迟到BGSAVE命令执行完。（反过来，如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝）（这里是性能方面考虑）</li></ul></li><li><p>RDB文件的载入（服务器处于阻塞状态，直到载入工作完成）</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态</li></ul></li><li><p>自动间隔性保存</p><ul><li><p>定义：根据用户通过设置服务器配置的save选项，让服务器 每隔一段时间自动执行一次BGSAVE命令</p></li><li><p>自动更新条件类似（下面为默认情况）</p><ul><li>服务器在900秒之内，对数据库进行了至少1次修改</li><li>服务器在300秒之内，对数据库进行了至少10次修改</li><li>服务器在60秒之内，对数据库进行了至少10000次修改</li></ul></li><li><p>实现原理</p><ul><li><p>用户可以通过制定配置文件或者传入启动参数的方式设置save选项（不设置默认上面的条件）</p></li><li><p>服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性（是一个元素为saveparam的数组）</p></li><li><p>每个saveparam结构都保存了一个save选项设置的保存条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;<span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">int</span> changes;<span class="comment">//修改数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务器状态维持俩个参数，（执行完BGSAVE之后，会重置dirty计数器为0，lastsave属性更新为当前时间戳）</p><ol><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）（当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少（例如：给集合键加三个新元素，计3次））</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间（1378270800（2013年9月4日零时））</li></ol></li><li><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p></li></ul></li></ul></li><li><p>RDB结构</p><ul><li>开头长度5字节，保存“REDIS“5个字符，方便快速检查载入的文件是不是RDB文件</li><li>db_version，长度为4字节，表示一个字符串表示的整数，这个整数记录RDB文件版本号。比如”0006”就代表RDB文件的版本为第六版</li><li>databases部分，包含着零个或任意多个数据库，以及各个数据库中的键值对数据：<ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同（每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分）。<ol><li>SELECTDB常量的长度为1字节（<strong>固定值376</strong>），当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码</li><li>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中</li><li>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同<ul><li>不带过期时间的key_value_pairs分为：type常量，1字节，代表了一种对象类型或者底层编码；key键对象；value值对象</li><li>带过期时间的key_value_pairs分为：type，key，value，EXpiretime_MS：告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间和ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间</li></ul></li></ol></li></ul></li><li>EOF常量，长度1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了</li><li>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现</li><li>我们使用od命令来分析Redis服务器产生的RDB文件，该命令可以用给定的格式转存（dump）并打印输入文件。比如说，给定-c参数可以以ASCII编码的方式打印输入文件，给定-x参数可以以十六进制的方式打印输入文件，使用-cx参数调用od命令，同时以ASCII编码和十六进制格式打印RDB文件，诸如此类，具体的信息可以参考od命令的文档。</li></ul></li></ul><h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><ul><li><p>定义：AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态；被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式，所以我们可以直接打开一个AOF文件，观察里面的内容</p></li><li><p>AOF持久化实现（先缓冲，再文件持久化）</p><ul><li>命令追加（append）：当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</li><li>文件写入和文件同步（sync）<ul><li>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数</li><li>服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</li><li>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定(默认everysec)<ol><li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li><li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li><li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li></ol></li></ul></li></ul></li><li><p>AOF文件的载入与数据还原</p><ul><li>AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态</li></ul><ol><li>创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</li><li>从AOF文件中分析并读取出一条写命令。</li><li>使用伪客户端执行被读出的写命令。</li><li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li></ol></li><li><p>AOF重写</p><ul><li>AOF重写功能的实现原理：通过读取服务器当前的数据库状态，生成一条命令，代替之前执行的多条命令，减少AOF文件中命令数量，生成新的AOF文件，替换旧的AOF文件。</li><li>AOF重写实际实现时，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值（这个常量当前版本为64），那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令；但是每条命令设置的项数量也为64个</li><li>AOF后台重写（BGREWRITEAOF命令实现原理）（只有信号处理函数执行时会对服务器进程（父进程）造成阻塞）<ul><li>为了避免AOF重写时，服务器无法处理客户端发来的命令请求。使用子进程执行，同时子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性</li><li>为了解决子线程执行期间，父进程接受到客户端命令造成数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给<strong>AOF缓冲区</strong>和<strong>AOF重写缓冲区</strong><ol><li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行</li><li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面</li></ol></li><li>子进程完成AOF重写后，向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：<ol><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol></li></ul></li></ul></li></ul><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul><li><p>文本事件</p><ul><li>定义：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作</li><li>文件事件处理器：基于Reactor模式开发<ul><li>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul></li><li>构成组件部分<ul><li>套接字：文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现</li><li>I/O多路复用程序：负责监听多个套接字，尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个套接字</li><li>文件事件分派器：接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器</li><li>事件处理器：一个个函数，它们定义了某个事件发生时，服务器应该执行的动作；执行不同任务的套接字关联不同的事件处理器</li></ul></li><li>事件类型 （细节略）<ul><li>AE_READABLE事件（读事件）</li><li>AE_WRITABLE事件（写事件）两类</li></ul></li><li>API 略</li></ul></li><li><p>时间事件</p><ul><li>定义：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象</li><li>分类（取决于时间事件处理器的返回值）(目前只使用周期性事件，而没有使用定时事件)：<ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次；事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次；事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去</li></ul></li><li>构成<ul><li>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间</li><li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件</li></ul></li><li>实现：服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。（正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。）</li><li>API<ul><li>ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc</li><li>ae.c/aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。</li><li>ae.c/aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。</li><li>ae.c/processTimeEvents函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。</li></ul></li><li>时间事件应用实例：serverCron函数、<ul><li>定期操作由redis.c/serverCron函数执行(Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次;从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明)<ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul></li></ul></li></ul></li><li><p>事件的调度与执行</p><ul><li>由ae.c/aeProcessEvents函数负责；将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数</li><li>事件的调度和执行规则<ol><li>aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了</li><li>对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些</li></ol></li></ul></li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li><p>客户端属性</p><ul><li><p>通用属性</p><ol><li><p>套接字描述符：客户端状态的fd属性记录了客户端正在使用的套接字描述符；</p><ul><li><p>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令</p></li><li><p>普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1，所以普通客户端的套接字描述符的值必然是大于-1的整数</p></li></ul></li><li><p>名字：默认情况下是没有名字的，使用CLIENT setname命令可以为客户端设置一个名字，让客户端的身份变得更清晰</p></li><li><p>标志：客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态。flags属性的值可以是单个标志 flags=<value>或者多个标志的二进制或flags=<flag1>|<flag2>|…<strong>每个标志使用一个常量表示，一部分标志记录了客户端的角色，而另外一部分标志则记录了客户端目前所处的状态</strong>     所有标志都定义在redis.h文件里面。</p><ul><li>通常Redis只会将那些对数据库进行了修改的命令写入到AOF文件，但PUBSUB命令和SCRIPT LOAD命令是其中的例外，通过REDIS_FORCE_AOF标志，强制将这个俩个命令写入AOF文件。因为PUBSUB命令会让接受到消息的所有客户端的状态改变，SCRIPT LOAD命令会修改服务器状态，另外，为了让主服务器和从服务器都可以正确地载入SCRIPTLOAD命令指定的脚本。</li></ul></li><li><p>输入缓冲区：用于保存客户端发送的命令请求，<strong>输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端</strong>。</p></li><li><p>命令与命令参数：在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性</p><ul><li><p>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数</p></li><li><p>argc属性则负责记录argv数组的长度。</p></li></ul></li><li><p>命令的实现：当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表（字典）中查找命令所对应的命令实现函数，之后，服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令</p></li><li><p>输出缓冲区：执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的</p><ul><li><p>固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。   由buf和bufpos两个属性组成，buf是一个大小为REDIS_REPLY_CHUNK_BYTES字节的字节数组，*<em>而bufpos属性则记录了buf数组目前已使用的字节数量。REDIS_REPLY_CHUNK_BYTES常量目前的默认值为16</em>1024，也即是说，buf数组的默认大小为16KB**</p></li><li><p>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等       <strong>可变大小缓冲区由reply链表和一个或多个字符串对象组成，当buf数组的空间已经用完，或者回复因为太大而没办法放进buf数组里面时，服务器就会开始使用可变大小缓冲区。通过使用链表来连接多个字符串对象，服务器可以为客户端保存一个非常长的命令回复，而不必受到固定大小缓冲区16KB大小的限制</strong></p></li></ul></li><li><p>身份:客户端状态的authenticated属性用于记录客户端是否通过了身份验证;<strong>在服务器启用了身份验证功能时使用</strong></p><ul><li>如果authenticated的值为0，那么表示客户端未通过身份验证；如果authenticated的值为1，那么表示客户端已经通过了身份验证,未通过身份验证时，除了AUTH命令之外，客户端发送的所有其他命令都会被服务器拒绝执行</li></ul></li><li><p>时间属性</p><ul><li>ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒，CLIENT list命令的age域记录了这个秒数</li><li>lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间，这里的互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复，CLIENT list命令的idle域记录了这个秒数（可以用来计算客户端的空转时间）</li><li>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间</li></ul></li></ol></li></ul></li><li><p>特定功能相关属性</p><ul><li>创建：<ul><li>通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器（在第12章有介绍），为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾</li><li>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中，lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</li><li>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端</li></ul></li><li>关闭：主要包括reids针对，命令，输入缓冲区，输出缓冲区等等的限制</li></ul></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul><li><p>客户端服务器命令沟通流程</p><ol><li>当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器</li><li>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。3）调用命令执行器，执行客户端指定的命令<ul><li>服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了</li><li>进行预备操作（校验）：如是否已经通过了身份验证，参数个数对不对，cmd为空则拒绝等</li><li>调用命令实现函数</li><li>后续工作：如AOF缓冲区写入，慢查询日志，主服务器给从服务器传播刚刚执行的命令，根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</li></ul></li><li>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端</li><li>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看</li></ol></li><li><p>serverCron函数</p><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转</p><ol><li>更新服务器时间缓存：因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性（服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存）（<strong>对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间</strong>）</li><li>更新LRU时钟（<strong>服务器状态中的lruclock属性保存了服务器的LRU时钟</strong>）：类似于上面，也是服务器缓存时间的一种，每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间,当服务器要计算一个数据库键的空转时间（也即是数据库键对应的值对象的空转时间），程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间</li><li>更新服务器每秒执行命令次数:serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量</li><li>更新服务器内存峰值记录:服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小,每次会查看当前内存数量，于该值对比，留下较大的数</li><li>处理SIGTERM信号：每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器（值为1关闭服务器，为0不做动作），<strong>服务器在关闭自身之前会进行RDB持久化操作，这也是服务器拦截SIGTERM信号的原因，如果服务器一接到SIGTERM信号就立即关闭，那么它就没办法执行持久化操作了</strong></li><li>管理客户端资源：<ul><li>如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端</li><li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存</li></ul></li><li>管理数据库资源：serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作</li><li>执行被延迟的BGREWRITEAOF:每次serverCron函数执行时，函数都会检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行，如果这两个命令都没在执行，并且<strong>aof_rewrite_scheduled属性</strong>的值为1，那么服务器就会执行之前被推延的BGREWRITEAOF命令。</li><li>检查持久化操作的运行状态:rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID<ul><li>其中一个属性的值不为-1：如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件；；如果没有信号到达，那么表示持久化操作未完成，程序不做动作</li><li>都为-1表示没有进行持久化操作：（按照下面顺序判断进行，都会判断一遍，所以每次要判断是否有其他持久化操作）<ul><li>查看是否有BGREWRITEAOF被延迟了；</li><li>检查服务器的自动保存条件是否已经被满足，如果条件满足，<strong>并且服务器没有在执行其他持久化操作</strong>，那么服务器开始一次新的BGSAVE操作；</li><li>检查服务器设置的AOF重写条件是否满足，如果条件满足，<strong>并且服务器没有在执行其他持久化操作</strong>，那么服务器将开始一次新的BGREWRITEAOF操作</li></ul></li></ul></li><li>将AOF缓冲区中的内容写入AOF文件</li><li>关闭异步客户端：服务器会关闭那些输出缓冲区大小超出限制的客户端</li><li>增加cronloops计数器的值：服务器状态的cronloops属性记录了serverCron函数执行的次数，每次调用serverCron函数，本值加1；cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能，（例如执行10000次，重启）</li></ol></li><li><p>初始化服务器</p><ul><li>创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值，由<strong>initServerConfig函数</strong>完成<ul><li>设置服务器的运行ID。</li><li>设置服务器的默认运行频率。</li><li>设置服务器的默认配置文件路径。</li><li>设置服务器的运行架构。</li><li>设置服务器的默认端口号。</li><li>设置服务器的默认RDB持久化条件和AOF持久化条件。</li><li>初始化服务器的LRU时钟。</li><li>创建命令表。</li></ul></li><li>载入配置选项：用户可以通过给定配置参数或者指定配置文件（redis.conf文件）来修改服务器的默认配置</li><li>初始化服务器数据结构 <strong>initServer函数完成</strong><ul><li>server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</li><li>server.db数组，数组中包含了服务器的所有数据库。</li><li>用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</li><li>用于执行Lua脚本的Lua环境server.lua。</li><li>用于保存慢查询日志的server.slowlog属性</li><li>为服务器设置进程信号处理器</li><li>创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象</li><li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接</li><li>为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数</li><li>如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备</li><li>初始化服务器的后台I/O模块（bio），为将来的I/O操作做好准备</li></ul></li><li>还原数据库状态<ul><li>如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态</li><li>相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态</li></ul></li><li>执行事件循环：开始执行服务器的事件循环（loop）</li></ul></li></ul><h2 id="多机数据库"><a href="#多机数据库" class="headerlink" title="多机数据库"></a>多机数据库</h2><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul><li>用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）（示例slaveof  ip port）</li><li>旧版复制功能（俩个阶段）<ul><li>同步（sync）:只有同步可以显示的用slaveof开启，用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态(整体同步)<ul><li>从服务器向主服务器发送SYNC命令</li><li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</li><li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态</li><li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li></ul></li><li>命令传播（command propagate）:用于在主服务器的数据库状态被修改（例如写命令，删除一个键），导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态（个别命令同步）</li><li>缺陷：<ul><li>场景：断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li><li>原因：可能只有断开很短的时间，只需要复制小部分键的数据，而旧版功能需要同步，让主服务器生成一个RDB文件包含所有键，进行同步。<ol><li>主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源</li><li>主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响</li><li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求</li></ol></li></ul></li></ul></li><li>新版复制功能<ul><li>PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式<ul><li>完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li><li>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li></ul></li><li>部分重同步的实现<ul><li>主服务器的复制偏移量和从服务器的复制偏移量：主从服务器都维护一个复制偏移量，保持相等，主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N；从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。<strong>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的，不相等则不是</strong></li><li>主服务器的复制积压缓冲区：数据结构：<strong>固定长度先进先出队列</strong>，默认大小1MB。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，所以复制积压缓冲区保留最近传播的写命令。断线后，<strong>通过偏移量计算差的数据</strong>在不在里面，在则启动部分重同步模式，否则启动完整重同步。<ul><li>复制积压缓冲区的最小大小可以根据公式second（从服务器断线后重新连接上主服务器所需的平均时间（以秒计算））* write_size_per_second（服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和））  <strong>为了安全起见，可以将复制积压缓冲区的大小设为2 * second * write_size_per_second</strong>   repl-backlog-size选项修改复制积压缓冲区大小</li></ul></li><li>服务器的运行ID：每个redis服务器无论主从，都会在启动时生成运行id，由40个随机的十六进制字符组成 例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。 <strong>初次复制时，主服务器将自己的运行id传送给从服务器，从服务器保存运行id</strong>，断线重连后，从服务器发送这个运行id与当前服务器比对，相同则启动部分重同步操作，不同则完整重同步操作</li></ul></li><li>PSYNC命令的实现<ul><li>从服务器<ol><li>如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）</li><li>相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ＜runid＞ ＜offset＞命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。</li></ol></li><li>主服务器<ol><li>如果主服务器返回+FULLRESYNC ＜runid＞ ＜offset＞回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量</li><li>如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了</li><li>如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。</li></ol></li></ul></li></ul></li><li>复制的实现<ol><li>设置主服务器的地址端口，通过slaveof 127.0.0.1  6739 这样的命令，将ip和端口保存到服务器状态的masterhost属性和masterport属性里面。SLAVEOF命令是一个异步命令，在完成masterhost属性和masterport属性的设置工作之后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而实际的复制工作将在OK返回之后才真正开始执行。</li><li>建立套接字连接：从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接；连接成功，<ul><li>从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令</li><li>主服务器在接受（accept）从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待</li></ul></li><li>发送ping命令：通过发送PING命令可以检查套接字的读写状态是否正常和检查主服务器能否正常处理命令请求。其有下面三种情况：<ul><li>如果主服务器向从服务器返回了一个命令回复，但从服务器却不能在规定的时限（timeout）内读取出命令回复的内容，那么表示主从服务器之间的网络连接状态不佳，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器断开并重新创建连向主服务器的套接字。</li><li>如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器断开并重新创建连向主服务器的套接字。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only callSCRIPT KILL or SHUTDOWN NOSAVE.错误。</li><li>如果从服务器读取到”PONG”回复，那么表示主从服务器之间的网络连接状态正常，并且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可以继续执行复制工作的下个步骤。</li></ul></li><li>身份验证：<ul><li>如果主服务器没有设置requirepass选项，并且从服务器也没有设置masterauth选项，那么主服务器将继续执行从服务器发送的命令，复制工作可以继续进行</li><li>如果从服务器通过AUTH命令发送的密码和主服务器requirepass选项所设置的密码相同，那么主服务器将继续执行从服务器发送的命令，复制工作可以继续进行。与此相反，如果主从服务器设置的密码不相同，那么主服务器将返回一个invalid password错误</li><li>如果主服务器设置了requirepass选项，但从服务器却没有设置masterauth选项，那么主服务器将返回一个NOAUTH错误。另一方面，如果主服务器没有设置requirepass选项，但从服务器却设置了masterauth选项，那么主服务器将返回一个no password is set错误</li></ul></li><li>发送端口信息：从服务器将执行命令REPLCONFlistening-port ＜port-number＞，向主服务器发送从服务器的监听端口号。主服务器在接收到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的slave_listening_port属性中。<strong>slave_listening_port属性目前唯一的作用就是在主服务器执行INFO replication命令时打印出从服务器的端口号。</strong></li><li>同步：同步操作后，主服务器也会成为从服务器的客户端（这样才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命令传播操作的基础）</li><li>命令传播：当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。</li></ol></li></ul><h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h4><ul><li><p>定义：从服务器默认会以每秒一次的频率，向主服务器发送命令：其中replication_offset是从服务器当前的复制偏移量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure></li><li><p>检测主从服务器的网络连接状态：主从服务器可以通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接是否正常：如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了；通过向主服务器发送INFO replication命令，在列出的从服务器列表的<strong>lag一栏</strong>中，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令距离现在过了多少秒</p></li><li><p>辅助实现min-slaves配置选项：Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>那么在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令，这里的延迟值就是上面提到的INFO replication命令的lag值</p></li><li><p>检测命令丢失：如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p></li></ul><h4 id="Sentinel（哨兵）"><a href="#Sentinel（哨兵）" class="headerlink" title="Sentinel（哨兵）"></a>Sentinel（哨兵）</h4><ul><li><p>定义：Redis的高可用性（highavailability）解决方案，由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><ul><li>假设主服务器server1进入下线状态，当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行故障转移操作：<ul><li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</li><li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li><li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器</li></ul></li></ul></li><li><p>启动并初始化</p><ul><li><p>启动一个Sentinel命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-sentinel /path/to/your/sentinel.conf</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server /path/to/your/sentinel.conf --sentinel</span></span><br></pre></td></tr></table></figure></li><li><p>初始化服务器：Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器。（大致类似于普通服务器的初始化，只不过还原数据库状态啥的没有）</p></li><li><p>使用Sentinel专用代码：如 Sentinel使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define REDIS_SENTINEL_PORT 26379</span><br></pre></td></tr></table></figure></li><li><p>初始化Sentinel状态：服务器会初始化一个sentinel.c/sentinelState结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> current_epoch;<span class="comment">//当前纪元</span></span><br><span class="line">    dict *masters;<span class="comment">//保存监视的主服务器，键是主服务器的名字，值指向一个sentinelRedisInstance结构的指针</span></span><br><span class="line">    <span class="keyword">int</span> tilt;<span class="comment">//是否进入TILT模式</span></span><br><span class="line">    <span class="keyword">int</span> running_scripts;<span class="comment">//目前正在执行的脚本的数量</span></span><br><span class="line">    <span class="keyword">mstime_t</span> tilt_start_time;<span class="comment">//进入TILT模式的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> previous_time;<span class="comment">//最后一次执行时间处理器的时间</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;<span class="comment">//一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化Sentinel状态的masters属性：masters字典记录了所有被Sentinel监视的主服务器的相关信息，字典的键是被监视主服务器的名字，字典的值则是被监视主服务器对应的sentinel.c/sentinelRedisInstance结构。每个sentinelRedisInstance结构（后面简称“实例结构”）代表一个被Sentinel监视的Redis服务器实例（instance），这个实例可以是主服务器、从服务器，或者另外一个Sentinel。（这个masters字典的初始化根据被载入的Sentinel配置文件进行）</p></li><li><p>创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息，对于每个被Sentinel监视的主服务器来说，Sentinel会创建<strong>两个</strong>连向主服务器的<strong>异步网络连接</strong></p><ul><li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复</li><li>另一个是订阅连接，这个连接专门用于订阅主服务器的<strong>sentinel</strong>:hello频道（在Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失<strong>sentinel</strong>:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息）</li></ul></li></ul></li><li><p>获取主服务器信息</p><ul><li>Sentinel默认会以<strong>每十秒一次</strong>的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。<ul><li>一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</li><li>另一方面是关于主服务器属下所有从服务器的信息，每个从服务器都由一个”slave”字符串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器。生成slaves字典保存数据：<ul><li>字典的键是由Sentinel自动设置的从服务器名字，格式为ip:port：如对于IP地址为127.0.0.1，端口号为11111的从服务器来说，Sentinel为它设置的名字就是127.0.0.1:11111</li><li>至于字典的值则是从服务器对应的实例结构：比如说，如果键是127.0.0.1:11111，那么这个键的值就是IP地址为127.0.0.1，端口号为11111的从服务器的实例结构。</li><li>同时校验从服务器对应的实例结构已经存在，存在则更新，不存在添加</li></ul></li><li>主从服务器实例之间的区别<ul><li>主服务器实例结构的flags属性的值为SRI_MASTER，而从服务器实例结构的flags属性的值为SRI_SLAVE</li><li>主服务器实例结构的name属性的值是用户使用Sentinel配置文件设置的，而从服务器实例结构的name属性的值则是Sentinel根据从服务器的IP地址和端口号自动设置的</li></ul></li></ul></li></ul></li><li><p>获取从服务器信息</p><ul><li>Sentinel会创建连接到从服务器的命令连接和订阅连接</li><li>在创建命令连接之后，Sentinel在默认情况下，会以<strong>每十秒一次</strong>的频率通过命令连接向从服务器发送INFO命令，根据INFO命令的回复，Sentinel会提取出以下信息<ul><li>从服务器的运行ID run_id</li><li>从服务器的角色role</li><li>主服务器的IP地址master_host，以及主服务器的端口号master_port</li><li>主从服务器的连接状态master_link_status</li><li>从服务器的优先级slave_priority</li><li>从服务器的复制偏移量slave_repl_offset</li></ul></li></ul></li><li><p>向主从服务器发送消息（发消息和订阅消息时一个频道）</p><ul><li><p>Sentinel会以<strong>每两秒一次</strong>的频率，通过命令连接向所有被监视的主服务器和从服务器的 __ sentinel__:hello频道发送以下格式的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH _sentinel_:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure><p>其中以s_开头的参数记录的是Sentinel本身的信息, m_开头的参数记录的则是主服务器的信息(如果Sentinel正在监视的是主服务器，那么这些参数记录的就是主服务器的信息；如果Sentinel正在监视的是从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息)</p></li></ul></li><li><p>接受来自主从服务器的频道信息</p><ul><li><p>当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过<strong>__ sentinel__:hello的频道</strong>订阅连接(订阅会持续到Sentinel与服务器断开连接)，向服务器发送以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE _sentinel_:hello</span><br></pre></td></tr></table></figure></li><li><p>当一个Sentinel从<strong>sentinel</strong>:hello频道收到一条信息时，Sentinel会对这条信息进行分析，提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查</p><ul><li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理</li><li>相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，<strong>对相应主服务器的实例结构进行更新</strong></li><li>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接，<strong>最终监视同一主服务器的多个Sentinel将形成相互连接的网络</strong>：Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接</li><li>连接其他Sentinel时，却只会创建命令连接，而不创建订阅连接。这是因为Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新Sentinel，所以才需要建立订阅连接，而相互已知的Sentinel只要使用命令连接来进行通信就足够了。</li></ul></li></ul></li><li><p>检测主观下线状态</p><ul><li>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。<ul><li>有效回复：实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种</li><li>无效回复：实例返回除+PONG、-LOADING、-MASTERDOWN三种回复之外的其他回复，或者在指定时限内没有返回任何回复。</li></ul></li><li>Sentinel配置文件中的<strong>down-after-milliseconds</strong>选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，<strong>在结构的flags属性中打开SRI_S_DOWN标识</strong>，以此来表示这个实例已经进入主观下线状态</li><li>配置文件中的<strong>down-after-milliseconds</strong>选项不仅会成为Sentinel判断master进入主观下线的标准，还会成为Sentinel判断master属下所有从服务器，以及所有同样监视master的其他Sentinel进入主观下线的标准</li><li>每个sentinel都会有自己的down-after-milliseconds，所以主观判断不相同</li></ul></li><li><p>检查客观下线状态</p><ul><li><p>使用 如下命令，询问其他sentinel是否同意主服务器已下线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt;&lt;port&gt;&lt;current_epoch&gt;&lt;runid&gt;</span><br></pre></td></tr></table></figure></li><li><p>目标sentinel收到源sentinel后，根据参数，确定主服务器是否下线，给予回复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;down_state&gt;&#x2F;&#x2F;1代表下线，0代表未下线</span><br><span class="line">&lt;leader_runid&gt;</span><br><span class="line">&lt;leader_epoch&gt;</span><br></pre></td></tr></table></figure></li><li><p>收到回复下线的sentinel数量大于启动时配置的数量，则认为主服务器已经进入客观下线状态</p></li><li><p>同样，因为配置不同，每个sentinel也判断客观下线不一定</p></li></ul></li><li><p>选举领头sentinel</p><ul><li>规则和方法如下：<ul><li>所有在线的Sentinel都有被选为领头Sentinel的资格，换句话说，监视同一个主服务器的多个在线Sentinel中的任意一个都有可能成为领头Sentinel。</li><li>每次进行领头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的。</li><li>在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。</li><li>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。</li><li>当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINELis-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel。</li><li>Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。</li><li>目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，将向源Sentinel返回一条命令回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元。</li><li>源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel。</li><li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成为领头Sentinel。</li><li>因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel。</li><li>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止。</li></ul></li></ul></li><li><p>故障转移</p><ul><li>选择新的主服务器，按照以下规则<ul><li>删除列表中所有处于下线或者断线状态的从服务器，这可以保证列表中剩余的从服务器都是正常在线的</li><li>删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的</li><li>删除所有与已下线主服务器连接断开超过down-after-milliseconds<em>10毫秒的从服务器：down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过 down-after-milliseconds</em>10毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，换句话说，列表中剩余的从服务器保存的数据都是比较新的</li><li>然后按照优先级从高到底（前面出现过的一个属性），偏移量从大到小，运行id从小到大，选出一个从服务器（前一个相同，看后一个属性）</li></ul></li><li>向选出的从服务器发送SLAVEOF no one命令，发送之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升级的从服务器发送INFO命令，并观察命令回复中的角色（role）信息，当被升级服务器的role从原来的slave变为master时，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了</li><li>修改从服务器的复制目标：向从服务器发送SLAVEOF命令，让已下线主服务器属下的所有从服务器去复制新的主服务器</li><li>将旧的主服务器变为从服务器：当旧主服务器重新上线时，Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器</li></ul></li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul><li><p>节点（node）</p><ul><li><p>一个Redis集群由多个节点组成，一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式，节点会继续使用所有在单机模式中使用的服务器组件</p></li><li><p>集群数据结构</p><ul><li>clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号等等，每个节点有一个自己的clusterNode，同时给所有主从节点创建一个相应的clusterNode结构</li><li>clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区（redisClient结构和其一样，但是redisClient用来连接客户端，而clusterLink用来连接节点）</li><li>clusterState结构：这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元，诸如此类</li></ul></li><li><p>向一个节点node发送CLUSTER MEET命令，可以让node节点与ip和port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure><p>握手步骤：</p><ol><li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>之后，节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）</li><li>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面</li><li>之后，节点B将向节点A返回一条PONG消息</li><li>如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息</li><li>之后，节点A将向节点B返回一条PING消息</li><li>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成</li></ol></li></ul></li><li><p>槽指派</p><ul><li><p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p></li><li><p>当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p></li><li><p>命令将槽点设置给各个服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster addslots &lt;slot&gt;  [slot ...]</span><br></pre></td></tr></table></figure></li><li><p>clusterNode结构中的slots属性（二进制数组，长度为16384/8=2048个字节，共包含16384个二进制位）和numslot属性记录节点负责的处理槽和长度，也即是slots数组中值为1的二进制位的数量</p><ul><li>Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位的值来判断节点是否负责处理槽i；为1则表示节点负责处理槽i，值为0则不负责</li><li>节点也保存其他节点的槽记录，因为集群中的每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面，因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点。</li></ul></li><li><p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息；slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针：如果slots[i]指针指向NULL，那么表示槽i尚未指派给任何节点。如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点</p></li></ul></li><li><p>集群中执行命令</p><ul><li><p>计算键属于哪个槽：其中CRC16（key）语句用于计算键key的CRC-16校验和，而&amp;16383语句则用于计算出一个介于0至16383之间的整数作为键key的槽号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def slot_number(key): </span><br><span class="line">    return CRC16(key) &amp; 16383</span><br><span class="line">CLUSTER KEYSLOT &lt;key&gt; &#x2F;&#x2F;查看一个给定键属于哪个槽</span><br></pre></td></tr></table></figure></li><li><p>判断槽点是否由当前节点负责</p><ul><li>如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令</li><li>如果clusterState.slots[i]不等于clusterState.myself，那么说明槽i并非由当前节点负责，节点会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，向客户端返回MOVED错误，指引客户端转向至正在处理槽i的节点</li></ul></li><li><p>MOVED错误格式：MOVED <slot> <ip> :<port></p></li><li><p><strong>集群模式的redis-cli客户端在</strong>接收到MOVED错误时，并不会打印出MOVED错误，而是根据MOVED错误自动进行节点转向，并打印出转向信息，所以我们是看不见节点返回的MOVED错误的;<strong>单机可以</strong></p></li><li><p>集群中的节点只能用0号数据库，而单机redis可以用全部</p></li><li><p>除了将键值对保存在数据库里面之外，节点还会用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系，slots_to_keys跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键：</p><ul><li>每当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到slots_to_keys跳跃表</li><li>当节点删除数据库中的某个键值对时，节点就会在slots_to_keys跳跃表解除被删除键与槽号的关联</li></ul></li></ul></li><li><p>重新分片</p><ul><li><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。<strong>在线（online）进行</strong>,<strong>且源节点和目标节点都可以继续处理命令请求</strong>。</p></li><li><p>步骤：</p><ol><li>redis-trib对目标节点发送CLUSTER SETSLOT＜slot＞IMPORTING＜source_id＞命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对</li><li>redis-trib对源节点发送CLUSTER SETSLOT＜slot＞MIGRATING＜target_id＞命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点</li><li>redis-trib向源节点发送CLUSTER GETKEYSINSLOT＜slot＞＜count＞命令，获得最多count个属于槽slot的键值对的键名（key name）</li><li>对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE＜target_ip＞＜target_port＞＜key_name＞0＜timeout＞命令，将被选中的键原子地从源节点迁移至目标节点。</li><li>重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止</li><li>redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT＜slot＞NODE＜target_id＞命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点</li></ol></li></ul></li><li><p>ASK错误：当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时</p><ul><li><p>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令</p></li><li><p>相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令</p></li><li><p>ASK错误格式 : ASK<slot> <ip> :<port></p></li><li><p>在对集群进行重新分片的时候，向目标节点发送命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT&lt;i&gt; IMPORTING &lt;SOURCE_id&gt;</span><br></pre></td></tr></table></figure><p>可以将目标节点clusterState.importing_slots_from[i]的值设置为source_id所代表节点的clusterNode结构。(如果importing_slots_from[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在从clusterNode所代表的节点导入槽i。)</p></li><li><p>在对集群进行重新分片的时候，向源节点发送命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</span><br></pre></td></tr></table></figure><p>可以将源节点clusterState.migrating_slots_to[i]的值设置为target_id所代表节点的clusterNode结构（如果migrating_slots_to[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在将槽i迁移至clusterNode所代表的节点。）</p></li><li><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识;</p></li><li><p>当客户端接收到ASK错误并转向至正在导入槽的节点时,客户端会<strong>先向节点发送一个ASKING命令</strong>，然后才重新发送想要执行的命令，这是因为如果客户端不发送ASKING命令，而直接发送想要执行的命令的话，那么客户端发送的命令将被节点拒绝执行，并返回MOVED错误。（因为槽的指派还没有换过来）</p></li><li><p>客户端的REDIS_ASKING标识是一个一次性标识，当节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，客户端的REDIS_ASKING标识就会被移除。所以下次启动要再执行下这个命令。</p></li><li><p>ASK错误和MOVED错误区别：</p><ul><li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点，因为该节点就是目前负责槽i的节点</li><li>与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，但这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现</li></ul></li></ul></li><li><p>复制与故障转移</p><ul><li><p>Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求</p></li><li><p>向一个节点发送命令:可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_ip&gt;</span><br></pre></td></tr></table></figure><ul><li><p>节点首先会在自己的clusterState.nodes字典中找到node_id所对应节点的clusterNode结构，并将自己的clusterState.myself.slaveof指针指向这个结构，以此来记录这个节点正在复制的主节点；</p></li><li><p>然后节点会修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识，表示这个节点已经由原来的主节点变成了从节点。</p></li><li><p>最后，节点会调用复制代码，并根据clusterState.myself.slaveof指向的clusterNode结构所保存的IP地址和端口号，对主节点进行复制。因为节点的复制功能和单机Redis服务器的复制功能使用了相同的代码，所以让从节点复制主节点相当于向从节点发送命令SLAVEOF</p></li><li><p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点，集群中的所有节点都会在代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单</p></li></ul></li><li><p>故障检测</p><ul><li>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线（probable fail，PFAIL）</li><li>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL），将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线</li></ul></li><li><p>故障转移</p><p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤</p><ol><li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li><li>被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li><li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ol></li><li><p>选举新的主节点（类似Sentinel选举）</p><ol><li>集群的配置纪元是一个自增计数器，它的初始值为0；</li><li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li><li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li><li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li><li>如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li><li>每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li><li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</li><li>因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li><li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li></ol></li></ul></li><li><p>消息</p><ul><li><p>集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者.<strong>一条消息由消息头（header）和消息正文（data）组成</strong></p></li><li><p>节点发送的消息类型</p><ul><li>MEET消息：当发送者接到客户端发送的CLUSTERMEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</li><li>PING消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。除此之外，如果节点A最后一次收到节点B发送的PONG消息的时间，距离当前时间已经超过了节点A的cluster-node-timeout选项设置时长的一半，那么节点A也会向节点B发送PING消息，这可以防止节点A因为长时间没有随机选中节点B作为PING消息的发送对象而导致对节点B的信息更新滞后。</li><li>PONG消息：当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。另外，一个节点也可以通过向集群广播自己的PONG消息来让集群中的其他节点立即刷新关于这个节点的认识，例如当一次故障转移操作成功执行之后，新的主节点会向集群广播一条PONG消息，以此来让集群中的其他节点立即知道这个节点已经变成了主节点，并且接管了已下线节点负责的槽。</li><li>FAIL消息：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。</li><li>PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li></ul></li><li><p>消息头（结构略）：节点发送的所有消息都由一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身的一些信息，因为这些信息也会被消息接收者用到，所以严格来讲，我们可以认为消息头本身也是消息的一部分。<strong>接收者会根据这些信息，在自己的clusterState.nodes字典里找到发送者对应的clusterNode结构，并对结构进行更新。</strong></p></li><li><p>消息的实现：</p><ul><li><p>Redis集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG三种消息实现；节点通过消息头的type属性来判断消息类型（发送者同时携带从自己的已知节点列表中随机选出的俩个节点，主从皆可能），接受者根据节点是否已知，进行更新维护或者进行握手</p></li><li><p>当集群里的主节点A将主节点B标记为已下线（FAIL）时，主节点A将向集群广播一条关于主节点B的FAIL消息，所有接收到这条FAIL消息的节点都会将主节点B标记为已下线</p></li><li><p>当客户端向集群中的某个节点发送命</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH &lt;channel&gt; &lt;message&gt;</span><br></pre></td></tr></table></figure><p> 的时候，接收到PUBLISH命令的节点不仅会向channel频道发送消息message，它还会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会向channel频道发送message消息。</p></li></ul></li></ul></li></ul><h2 id="独立功能"><a href="#独立功能" class="headerlink" title="独立功能"></a>独立功能</h2><h4 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h4><ul><li>Redis将所有<strong>频道的订阅</strong>关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端。<ul><li>SUBSCRIBE命令订阅某个或某些频道</li><li>UNSUBSCRIBE命令让服务器将从pubsub_channels中解除客户端与被退订频道之间的关联</li><li>订阅或者退订的频道有键存在在字典里，则在链表中添加或者删除该客户端，没有的则在字典里添加或者删除频道的键</li></ul></li><li>服务器将所有频道的订阅关系都保存在服务器状态的pubsub_channels属性里面，与此类似，服务器也将所有<strong>模式的订阅关系</strong>都保存在服务器状态的pubsub_patterns属性里面（模式以正则表达式的形式存储如news.* 可能频道的是news.it;news.me等等  则这个频道是这个模式）<ul><li>pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsub Pattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端</li><li>PSUBSCRIBE命令订阅某个或某些模式的时候，新建一个pubsubPattern结构，将结构的pattern属性设置为被订阅的模式，client属性设置为订阅模式的客户端；将这个结构添加到链表末尾</li><li>PUNSUBSCRIBE命令则是从链表中查找并删除这个结构</li></ul></li><li>发送消息 PUBLISH <channel> <message><ul><li>将消息message发送给channel频道的所有订阅者（在pubsub_channels字典里找到频道channel的订阅者名单（一个链表），然后将消息发送给名单上的所有客户端）</li><li>如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。（PUBLISH命令要做的就是遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端）</li></ul></li><li>查看订阅信息<ul><li>PUBSUB CHANNELS [pattern]子命令用于返回服务器当前被订阅的频道（例如 PUBSUB CHANNELS “news.[is]*”   pattern可以是正则表达式）<ul><li>如果不给定pattern参数，那么命令返回服务器当前被订阅的所有频道</li><li>如果给定pattern参数，那么命令返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道</li></ul></li><li>PUBSUB NUMSUB[channel-1 channel-2…channel-n]子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量（这个子命令是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的（订阅者链表的长度就是频道订阅者的数量））</li><li>PUBSUB NUMPAT子命令用于返回服务器当前被订阅模式的数量。（这个子命令是通过返回pubsub_patterns链表的长度来实现的，因为这个链表的长度就是服务器被订阅模式的数量）</li></ul></li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li><p>事务的实现</p><ul><li><p>事务开始：MULTI命令   显示切换执行该命令的客户端，从非事务状态切换至事务状态，通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成</p></li><li><p>命令入队：事务状态下的客户端，服务器会根据这个客户端发来的不同命令执行不同的操作</p><ul><li>如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令</li></ul></li></ul></li><li><p>与此相反，如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个<strong>事务队列</strong>里面，然后向客户端返回QUEUED回</p></li><li><p>事务队列是一个先进先出的队列，是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span>&#123;</span></span><br><span class="line">    robj **argv; <span class="comment">//参数</span></span><br><span class="line">    <span class="keyword">int</span> argc;<span class="comment">//参数数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span><span class="comment">//命令指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>+ 当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果**全部**返回给客户端</code></pre><ul><li><p>WATCH命令</p><ul><li>WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。（别的客户端进行的修改）</li><li>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端</li><li>命令 WATCH “name” “age”  让客户端监视键name和age，即在这俩个键的链表中加上当前客户端</li><li>所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。</li><li>一个客户端发来EXEC命令提交事务时，服务器根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务</li></ul></li><li><p>事务的ACID性质</p><ul><li>原子性：redis事务支持原子性（但是不支持回滚，所以就算执行失败也会全部执行一遍）</li><li>一致性：<ul><li>入队错误：Redis 2.6.5以后直接拒绝事务</li><li>执行错误：在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。</li><li>服务器停机：根据RDB或者AOF模式恢复数据，恢复不了则空白，也保证一致性</li></ul></li><li>隔离性：因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</li><li>持久性：根据redis本身启用的持久化模式决定是否具有耐久性，（不论Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事务的耐久性，不过因为这种做法的效率太低，所以并不具有实用性。）</li></ul></li></ul><h4 id="LUA脚本"><a href="#LUA脚本" class="headerlink" title="LUA脚本"></a>LUA脚本</h4><ul><li>Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性、安全性等方面的需要。（一些优化，比如对于不确定命令加入排序（列表不加排序，根据添加不同输出会不同），random函数自定义，去除掉lua脚本的该函数会有副作用）</li><li>协作组件<ul><li>Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令。</li><li>Redis服务器为Lua环境创建的另一个协作组件是lua_scripts字典，这个字典的键为某个Lua脚本的SHA1校验和（checksum），而字典的值则是SHA1校验和对应的Lua脚本</li></ul></li><li>Redis使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能。</li><li>脚本管理命令<ul><li>EVAL命令为客户端输入的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。</li><li>EVALSHA命令通过直接调用Lua环境中已定义的函数来执行脚本。</li><li>SCRIPT FLUSH命令会清空服务器lua_scripts字典中保存的脚本，并重置Lua环境。</li><li>SCRIPT EXISTS命令接受一个或多个SHA1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。</li><li>SCRIPT LOAD命令接受一个Lua脚本为参数，为该脚本在Lua环境中创建函数，并将脚本保存到lua_scripts字典中。</li></ul></li><li>服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行情况时，客户端可以通过向服务器发送SCRIPT KILL命令（未执行写命令相关操作）来让钩子停止正在执行的脚本，或者发送SHUTDOWN nosave命令（执行了写命令相关操作）来让钩子关闭整个服务器。</li><li>脚本复制<ul><li>主服务器复制EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的方法和复制普通Redis命令一样，只要将相同的命令传播给从服务器就可以了。</li><li>主服务器在复制EVALSHA命令时，必须确保<strong>所有从服务器都已经载入了EVALSHA命令指定的SHA1校验和所对应的Lua脚本</strong>，（主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器）如果不能确保这一点的话，主服务器会将EVALSHA命令转换成等效的EVAL命令，并通过传播EVAL命令来获得相同的脚本执行效果。</li></ul></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>命令的实现（快速排序实现实际排序）：<ul><li>SORT <key>  （ASC | DESC）（数字值排序 升降序） 默认升序从小到大<ul><li>创建个和要排序的列表长度相同的数组，该数组里obj指针指向每个列表项完成绑定关系，u.score属性保存由列表项值转成的double类型的浮点数。</li><li>遍历数组，根据u.score属性从小到大排序，排序结果传给客户端，完成排序</li></ul></li><li>SORT <key> ALPHA  （ASC | DESC）（字符串值排序  升降序） 默认升序从小到大<ul><li>创建个和要排序的列表长度相同的数组，该数组里obj指针指向每个列表项完成绑定关系，u.score属性保存字符串值。</li><li>遍历数组，根据u.score属性的字符串值从小到大排列，排序结果传给客户端，完成排序</li></ul></li><li>SORT命令可以指定某些字符串键，或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序   （例如  SORT fruits BY *-price 权重值数值型    SORT fruits BY *-id ALPHA 权重值为字符串型 ） <ul><li>这里相对于不使用by，就是在实际排序时，*<em>BY选项所给定的模式</em>-price，查找相应的权重键，将各个权重键的值转换成一个double类型的浮点数，然后保存在相应数组项的u.score属性里面，之后进行排序**。</li><li>将各个数组项的u.cmpobj指针分别指向相应的权重键（一个字符串对象），以各个数组项的权重键的值为权重，对数组执行字符串排序</li></ul></li><li>LIMIT选项  格式为LIMIT＜offset＞＜count＞<ul><li>offset参数表示要跳过的已排序元素数量</li><li>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量</li><li>实际逻辑类似排序，就是在起始索引处用offset的值，取出来的数量用count的值</li></ul></li><li>GET选项<ul><li>SORT students ALPHA GET *-name   排序students之后，返回以students各个元素+-name的键对应的值</li><li>SORT students ALPHA GET *-name GET *-birth 排序students之后，返回students各个元素+-name的键和+-birth的键对应的值</li></ul></li><li>STORE选项<ul><li>SORT 例如（students ALPHA STORE sorted_students）  sort命令只向客户端返回排序结果，而不保存排序结果，通过使用STORE选项，我们可以将排序结果保存在指定的键里面</li><li>这里实际实现时，先排序，排序完成后，检查sorted_students键是否存在，存在删除，设置一个空的sorted_students键，然后依次压入，完成存储</li></ul></li><li>多选项执行顺序<ul><li>排序：在这一步，命令会使用ALPHA、ASC或DESC、BY这几个选项，对输入键进行排序，并得到一个排序结果集</li><li>限制排序结果集的长度：在这一步，命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中。</li><li>获取外部键：在这一步，命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。</li><li>保存排序结果集：在这一步，命令会使用STORE选项，将排序结果集保存到指定的键上面去。</li><li>向客户端返回排序结果集：在最后这一步，命令遍历排序结果集，并依次向客户端返回排序结果集中的元素。</li><li>调用SORT命令时，除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。（GET选项顺序不一样，导致取数不一样，所以会影响）</li></ul></li></ul></li></ul><h4 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h4><ul><li><p>GETBIT：用于返回位数组bitarray在offset偏移量上的二进制位的值</p><ul><li>命令格式  GETBIT <bitarray> <offset><ul><li>计算byte=offset÷8」，byte值记录了offset偏移量指定的二进制位保存在位数组bitarray的哪个字节</li><li>计算bit=（offset mod 8）+1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li><li>根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位，并返回这个位的值。</li></ul></li><li>例如：GETBIT <bitarray> 3    <ul><li>3÷8」的值为0</li><li>（3 mod 8）+1的值为4。</li><li>定位到buf[0]字节上面，然后取出该字节上的第4个二进制位（从左向右数）的值。</li><li>向客户端返回二进制位的值1。</li></ul></li></ul></li><li><p>SETBIT命令：SETBIT用于将位数组bitarray在offset偏移量上的二进制位的值设置为value，并向客户端返回二进制位被设置之前的旧值</p><ul><li>命令格式：SETBIT <bitarray> <offset><value><ul><li>定位二进制数组第几个字节第几位和GETBIT一样（多了一步对数组长度检查，长度不够会扩展）</li><li>设置新值value为这个二进制位的值</li><li>向客户端返回oldvalue变量的值</li></ul></li></ul></li><li><p>BITCOUNT命令：用于统计给定位数组中，值为1的二进制位的数量。</p><ul><li><p>算法实现：</p><ul><li><p>遍历</p></li><li><p>查表算法：空间换时间，我们可以创建一个表，表的键为某种排列的位数组，而表的值则是相应位数组中，值为1的二进制位的数量，如16位，则一个二进制位数组，没16位组合查一次表直接获得值。</p></li><li><p>variable-precision SWAR算法（因为swar函数是一个常数复杂度的操作，所以我们可以按照自己的需要，在一次循环中多次执行swar，从而按倍数提升计算汉明重量的效率，1次32位）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">swar</span><span class="params">(<span class="keyword">uint32_t</span> i)</span></span>&#123;</span><br><span class="line">    i=(i &amp; <span class="number">0x55555555</span>) + ((i&gt;&gt;<span class="number">1</span>)&amp;<span class="number">0x55555555</span>);<span class="comment">//步骤1</span></span><br><span class="line">    i=(i &amp; <span class="number">0x33333333</span>) + ((i&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x33333333</span>);<span class="comment">//步骤2</span></span><br><span class="line">    i=(i &amp; <span class="number">0x0F0F0F0F</span>) + ((i&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0x0F0F0F0F</span>);<span class="comment">//步骤3</span></span><br><span class="line">    i=(i * (<span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);<span class="comment">//步骤4</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❑步骤1计算出的值i的二进制表示可以按每两个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</p><p>❑步骤2计算出的值i的二进制表示可以按每四个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</p><p>❑步骤3计算出的值i的二进制表示可以按每八个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</p><p>❑步骤4的i*0x01010101语句计算出bitarray的汉明重量并记录在二进制位的最高八位，而＞＞24语句则通过右移运算，将bitarray的汉明重量移动到最低八位，得出的结果就是bitarray的汉明重量。</p></li><li><p>redis实现：</p><ul><li>如果未处理的二进制位的数量小于128位，那么程序使用查表算法来计算二进制位的汉明重量。：查表算法使用键长为8位的表，表中记录了从00000000到1111 1111在内的所有二进制位的汉明重量</li><li>如果未处理的二进制位的数量大于等于128位，那么程序使用variable-precision SWAR算法来计算二进制位的汉明重量：variable-precision SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision SWAR算法来计算这128个二进制位的汉明重量。</li></ul></li></ul></li></ul></li><li><p>BITOP命令：BITOP AND <key> <bitarray> <bitarray>（例如：BITOP AND result x y）</p><ul><li>在执行BITOP AND命令时，程序用&amp;操作计算出所有输入二进制位的逻辑与结果，然后保存在指定的键上面</li><li>在执行BITOP OR命令时，程序用|操作计算出所有输入二进制位的逻辑或结果，然后保存在指定的键上面</li><li>在执行BITOP XOR命令时，程序用^操作计算出所有输入二进制位的逻辑异或结果，然后保存在指定的键上面</li><li>在执行BITOP NOT命令时，程序用~操作计算出输入二进制位的逻辑非结果，然后保存在指定的键上面</li></ul></li></ul><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><ul><li><p>定义：Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度（服务器使用先进先出的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除）</p><ul><li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上</li><li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。</li></ul></li><li><p>慢查询记录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redusServer</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;<span class="comment">//下一条慢查询日志的id</span></span><br><span class="line">    <span class="built_in">list</span> *slowlog;<span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than;<span class="comment">//执行超过多少时间的命令记录到日志</span></span><br><span class="line">    <span class="keyword">unsigned</span> slowlog-max-len;<span class="comment">//服务器最多保存多少条慢查询日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;<span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">time_t</span> time;<span class="comment">//命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration;<span class="comment">//执行命令消耗的时间，以微妙为单位</span></span><br><span class="line">    robj **argv;<span class="comment">//命令与命令参数</span></span><br><span class="line">    <span class="keyword">int</span> argc;<span class="comment">//命令与命令参数的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>慢查询命令</p><ul><li>SLOWLOG GET命令查询所有的慢查询日志</li><li>SLOWLOG LEN命令查看日志数量</li><li>SLOWLOG RESET命令清除所有慢查询日志</li></ul></li><li><p>添加新日志（slowlogPushEntryIfNeeded函数完成）</p><ul><li>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，服务器会将这个时长作为参数之一传给slowlogPushEntryIfNeeded函数<ul><li>检查命令的执行时长是否超过slowlog-log-slower-than选项所设置的时间，如果是的话，就为命令创建一个新的日志，将redisServer.slowlog_entry_id的值增1，并将新日志添加到slowlog链表的表头，</li><li>检查慢查询日志的长度是否超过slowlog-max-len选项所设置的长度，如果是的话，那么将多出来的日志从slowlog链表中删除掉。</li></ul></li></ul></li></ul><h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><p>发送MONITOR命令可以让一个普通客户端变为一个监视器，客户端的REDIS_MONITOR标志会被打开，并且这个客户端本身会被添加到monitors链表的表尾；服务器在每次处理命令请求之前，都会调用replicationFeedMonitors函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;本章节根据《Redis设计与实现》和笔者自身理解所写&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://zhhw137.github.io/categories/Redis/"/>
    
    
    <category term="数据库" scheme="https://zhhw137.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Redis" scheme="https://zhhw137.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>并发编程卷一</title>
    <link href="https://zhhw137.github.io/2020/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87%E5%8D%B7%E4%B8%80/"/>
    <id>https://zhhw137.github.io/2020/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87%E5%8D%B7%E4%B8%80/</id>
    <published>2020-10-07T13:30:00.000Z</published>
    <updated>2020-11-02T01:32:34.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>编程本书基于《java并发编程之美》,持续更新中…源码太枯燥了</p><a id="more"></a><h2 id="并发编程之美"><a href="#并发编程之美" class="headerlink" title="并发编程之美"></a>并发编程之美</h2><h3 id="并发编程线程基础"><a href="#并发编程线程基础" class="headerlink" title="并发编程线程基础"></a>并发编程线程基础</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li><p>线程的创建方式</p><ul><li>实现Runnable接口的run方法<ul><li>优点：接口不占用继承名额</li><li>缺点：使用参数不方便，只能使用主线程里面被声明为final的变量</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am a thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    RunableTask task=<span class="keyword">new</span> RunableTask();</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>继承Thread类并重写run方法</p><ul><li>优点 传参方便，可以自己添加成员变量，通过set或者是构造函数的方法传递参数</li><li>缺点  java不支持多继承，占用了继承名额</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am a thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread thread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用FutureTask即Callable接口（这种的有返回值）</p><ul><li>优点   有返回值</li><li>缺点   使用不便</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw InterruptedException</span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallTask());</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        String result=futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>线程通知和等待（Object类方法；线程和共享变量都可以）</p><ul><li><p>wait()函数</p><ul><li>使用该共享对象的notify（）或者notifyAll（）方法唤醒。</li><li>其他线程调用该线程的interrupt（）方法，该线程抛出InterruptedException异常返回</li><li>虚假唤醒：一个线程可以从挂起状态变为可以运行状态（也就是被唤醒），即使该线程没有被其他线程调用notify（）、notifyAll（）方法进行通知，或者被中断，或者等待超时（可以循环验证）；</li><li>如果调用wait（）方法的线程没有事先获取该对象的监视器锁，则调用wait（）方法时调用线程会抛出IllegalMonitorStateException异常</li><li>调用共享对象的wait方法是，只会释放当前共享对象的锁，不会释放线程持有的其他对象的锁</li><li>wait(long timeout)，没有被上述方式唤醒或者中断，则到时间自动返回。wait(0)==wait()</li></ul></li><li><p>notify()</p><ul><li>随机唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。</li><li>被唤醒的线程还需要和其他线程竞争共享变量的监视器锁，只有竞争到了才会继续执行，否则等待</li><li>只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify（）方法，否则会抛出IllegalMonitorStateException异常</li></ul></li><li><p>notifyAll()</p><ul><li>唤醒所有的调用wait（）方法而放入阻塞集合的线程。</li></ul></li></ul></li><li><p>等待线程执行终止的join方法（Thread类的方法）</p><ul><li>join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。</li><li>join（long timeout）到时间线程开始并行执行。  join()==join(0)</li><li>线程A调用线程B的join方法后会被阻塞，当其他线程调用了线程A的interrupt（）方法中断了线程A时，线程A会抛出InterruptedException异常而返回(但是实际线程并没有终止)，这里是在调用那句话的地方抛出异常不执行</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread threadOne=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadOne begin&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread mainThread=Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        Thread threadTwo=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                mainThread.interrupt();</span><br><span class="line">                System.out.println(<span class="string">&quot;threadTwo run&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadOne.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main thread:&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>让线程睡眠的sleep方法（Thread类中的静态方法）</p><ul><li>调用该方法的线程暂时让出指定时间的执行权，也就是在<strong>这段时间不参与CPU调度</strong>，但是该线程所拥有的监视器资源比如锁，不会让出。指定时间到了后函数正常返回，线程处于就绪状态。</li><li>在睡眠期间其他线程调用了该线程的interrupt（）方法中断了该线程，则该线程会在调用sleep方法的地方抛出InterruptedException异常而返回。</li></ul></li><li><p>让出CPU执行权的yield方法（Thread类中的静态方法）</p></li><li><p>调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，<strong>线程调度器下一次调度时就有可能调度到当前线程执行</strong>。</p></li><li><p>线程中断</p><ul><li><p>void interrupt()方法:中断线程  </p><p>当线程A运行时，线程B可以调用线程A的interrupt（）方法来设置线程A的中断标志为true并立即返回。设置标志仅仅是设置标志，线程A实际并没有被中断，它会继续往下执行。如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起，这时候若线程B调用线程A的interrupt（）方法，线程A会在调用这些方法的地方抛出InterruptedException异常而返回。</p></li><li><p>boolean isInterrupted（）方法：检测当前线程是否被中断，如果是返回true，否则返回false</p></li><li><p>boolean interrupted() 方法：检测当前线程是否被中断，如果是返回true，否则返回false。与isInterrupted不同的是，该方法如果发现<strong>当前线程被中断，则会清除中断标志</strong>，并且该方法是static方法，可以通过Thread类直接调用。如下图代码，所以这个方法总是判断的<strong>当前线程</strong></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>线程上下文切换（CPU采用时间片轮转策略）</p><ul><li>当前线程的CPU时间片使用完</li><li>当前线程被其他线程打断时</li></ul></li><li><p>死锁(一般用资源的有序性破坏死锁)</p><ul><li>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去</li><li>操作系统层面的4个条件<ul><li>互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源</li><li>请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源</li><li>不可剥夺条件:指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源</li><li>环路等待条件:指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0, T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源</li></ul></li></ul></li><li><p>守护线程与用户线程</p><ul><li><p>JVM会自动启动一个叫作DestroyJavaVM的线程，该线程会等待所有用户线程结束后终止JVM进程</p></li><li><p>子线程的生命周期不受父线程的影响。（因此设置子线程是守护线程还是用户线程能控制，程序执行完成后这个子线程是否还要继续执行）</p></li><li><p>daemon线程（守护线程）</p><ul><li><p>不管当前是否有守护线程，当最后一个非守护线程结束时，JVM正常退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread daemonThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li>user线程（用户线程）</li></ul><ul><li>ThreadLocal<ul><li>Thread类中有threadLocals和inheritableThreadLocals，他们都是ThreadLocalMap类型的变量（定制化的Hashmap）<ul><li>void set（T value）  设置值到map中，key为当前线程</li><li>T get（） 获取当前线程作为key对应的值</li><li>void remove（） 清除ThreadLocal的本地变量</li></ul></li><li>InheritableThreadLocal类解决ThreadLocal类不支持继承的问题</li></ul></li></ul><h4 id="Java程序"><a href="#Java程序" class="headerlink" title="Java程序"></a>Java程序</h4><ul><li>共享变量内存可见性     线程有自己的工作内存，互相之间不可见，可能导致数据的异常，和主内存间数据不一致<ul><li>synchronized  可以解决，但是会造成线程上下文切换开销   锁方法进而锁对象</li><li>volatile   给变量加保证变量可见性</li></ul></li><li>原子性<ul><li>synchronized  可以解决原子性，但是降低并发性</li><li>CAS   compareAndSwap   比较并交换   存在ABA问题   JDK中用AtomicStampedReference类给每个变量的状态值配备一个时间戳，避免ABA问题。<ul><li>对象内存位置</li><li>对象中的变量的偏移量</li><li>变量预期值</li><li>新的值</li></ul></li></ul></li><li>Unsafe类 提供的都是native方法，直接操作内存的<ul><li>boolean compareAndSwapLong（Object obj, long offset, longexpect, long update）方法：比较对象obj中偏移量为offset的变量的值是否与expect相等，相等则使用update值更新，然后返回true，否则返回false。</li></ul></li><li>指令重排序</li><li>伪共享<ul><li>出现伪共享的原因：因为从主内存读入二级缓存时会一次性读取一个缓存行大小数据。比如读入1，可能后面带上2,3,4,5。</li><li>造成现象：变量x和y同时被放到了CPU的一级和二级缓存，当线程1使用CPU1对变量x进行更新时，首先会修改CPU1的一级缓存变量x所在的缓存行，这时候在缓存一致性协议下，CPU2中变量x对应的缓存行失效。那么线程2在写入变量x时就只能去二级缓存里查找，这就破坏了一级缓存。而一级缓存比二级缓存更快，这也说明了多个线程不可能同时去修改自己所使用的CPU中相同缓存行里面的变量。更坏的情况是，如果CPU只有一级缓存，则会导致频繁地访问主内存</li><li>sun.misc.Contended<strong>注解修饰类和变量</strong>  @Contended注解只用于Java核心类，比如rt包下的类。如果用户类路径下的类需要使用这个注解，则需要添加JVM参数：-XX:-RestrictContended。填充的宽度默认为128，要自定义宽度则可以设置-XX:ContendedPaddingWidth参数。</li></ul></li><li>锁<ul><li>加锁时机<ul><li>乐观锁：它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测</li><li>悲观锁：对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁</li></ul></li><li>获取锁抢占机制<ul><li>公平锁：公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁</li><li>非公平锁：而非公平锁则在运行时闯入，也就是先来不一定先得。</li></ul></li><li>持有锁线程个数<ul><li>独占锁：保证任何时候都只有一个线程能得到锁（悲观锁，读取也是一个时间只能有一个线程）</li><li>共享锁：可以同时由多个线程持有（读的时候可以多个线程）</li></ul></li><li>一个线程是否可以反复获得锁：<ul><li>可重入锁：即为锁是否有线程标识，有的可以重入，每次获得锁 就是标识+1，到0释放锁，线程标识置为null。</li><li>不可重入锁：自己再次获取线程阻塞</li></ul></li><li>自旋锁<ul><li>线程的挂起和唤醒都要由用户态切换到内核态，状态切换浪费时间影响效率。（java线程与cpu线程是一一对应的导致的）</li><li>当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取（默认次数是10，可以使用-XX:PreBlockSpinsh参数设置该值）</li></ul></li></ul></li></ul><h3 id="并发编程高级"><a href="#并发编程高级" class="headerlink" title="并发编程高级"></a>并发编程高级</h3><h4 id="并发编程中的常用类"><a href="#并发编程中的常用类" class="headerlink" title="并发编程中的常用类"></a>并发编程中的常用类</h4><ul><li><p>ThreadLocalRandom</p><ul><li>原因：java.util.Random是通过使用上一个种子重新按照固定规则计算下一个种子返回。为了防止多线程取到同一个旧种子而产生同一个新随机数，使用CAS自旋</li><li>类原理：针对原因，用threadlocal的原理解决，即将种子保存在线程的本地变量中，即threadLocalRandomSeed</li></ul></li><li><p>Atomic类 原子操作类，使用unsafe自旋保证原子性</p><ul><li><p>LongAdder类（AtomicLong类的改进），只能new一个默认为0的值，用add等方法赋值</p></li><li><p>里面 有base；Cells[]；cellsBusy；</p><ul><li>base  并发量不大的情况下就是value，等同于AtomicLong 的用法</li><li>高并发下，采用cells数组，各个线程获得一个cell变量（初始化，扩容等等），一个cell自增，最终的值是所有的cell+value</li><li>cellsBusy用来做自旋锁，状态值只有0和1，当创建Cell元素，扩容Cell数组或者初始化Cell数组时，使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。</li></ul></li><li><p>LongAdder类是LongAccumulator的特列，LongAccumulator可以从非0开始，同时可以指定累加规则（LongAdder只能默认为初始0，相加进行累加）</p><pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, ExecutionException, InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LongAdder longAdder=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LongAdder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        longAdder.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        longAdder.add(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LongBinaryOperator addStr = (n1, n2) -&amp;gt; n1 * n2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LongAccumulator longAccumulator=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LongAccumulator(addStr,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        longAccumulator.accumulate(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(longAdder+&lt;span class=&quot;string&quot;&gt;&amp;quot;......&amp;quot;&lt;/span&gt;+longAccumulator);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre></li></ul></li><li><p>CopyOnWriteArrayList</p><ul><li>初始化  <ul><li>无参构造函数   创造大小为0的Object数组</li><li>有参构造函数   集合或者数组，复制生成一个array存</li></ul></li><li>添加元素<ul><li>先获取独占锁    保证原子性</li><li>添加元素时，是进行复制快照后，处理快照，而不是在原来的数组上进行</li></ul></li><li>获取元素<ul><li>方法没有进行加锁</li><li>所有更新数组的操作会加锁，然后复制快照操作快照，再更换数组指向。多线程时，因为获取元素线程之前的引用导致指向之前的引用计数为1，不会删除，仍然指向之前的数组。所以仍然能获得数。（写时复制策略产生的弱一致性问题）</li></ul></li><li>修改元素<ul><li>首先获取了独占锁，从而阻止其他线程对array数组进行修改，然后获取当前数组，并调用get方法获取指定位置的元素，如果指定位置的元素值与新值不一致则创建新数组并复制元素，然后在新数组上修改指定位置的元素值并设置新数组到array。如果指定位置的元素值与新值一样，则为了保证volatile语义，还是需要重新设置array，虽然array的内容并没有改变。</li></ul></li><li>删除元素<ul><li>首先获取独占锁以保证删除数据期间其他线程不能对array进行修改，然后获取数组中要被删除的元素，并把剩余的元素复制到新数组，之后使用新数组替换原来的数组，最后在返回前释放锁</li></ul></li><li>迭代弱一致性<ul><li>迭代的时候指向旧数组，这样其他操作数组的都是复制了快照，然后将数组引用指向新数组，所以使用迭代器元素时，其他线程对该list进行的增删改不可见。</li></ul></li></ul></li></ul><h4 id="并发包中的锁"><a href="#并发包中的锁" class="headerlink" title="并发包中的锁"></a>并发包中的锁</h4><ul><li>LockSupport工具类 （每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport类的方法的线程是不持有许可证的）<ul><li>void park()<ul><li>如果调用该方法的线程已经获得了LockSupport的许可证（LockSupport.unpark(Thread.currentThread()) 比如调用这个方法就会获得该有的许可证），则直接返回</li><li>没有许可证，线程阻塞挂起</li><li>其他线程调用unpark（Thread thread）方法并将当前线程作为参数可以让阻塞线程返回</li><li>如果其他线程调用了阻塞线程的interrupt（）方法，设置了中断标志或者线程被虚假唤醒，则阻塞线程也会返回</li><li>因调用park（）方法而被阻塞的线程被其他线程中断而返回时并不会抛出InterruptedException异常。</li></ul></li><li>void unpark(Thread thread)<ul><li>如果传入的线程没有阻塞挂起，让参数传入的线程获得许可</li><li>如果传入的线程阻塞挂起了，唤醒该线程</li></ul></li><li>void parkNanos（long nanos）类似于park，只是多了时间参数，到达时间后自动唤醒</li><li>void park（Object blocker）当线程在没有持有许可证的情况下调用park方法而被阻塞挂起时，这个blocker对象会被记录到该线程内部。诊断工具是通过调用getBlocker（Thread）方法来获取blocker对象的</li><li>void parkUntil(Object blocker, long  deadline)方法   记录阻塞原因，再加上到哪个时间点，这个时间点相较于1970年计算的。可以让线程具体到某个时间而不是相对时间了</li><li>void parkNanos(Object blocker, long  nanos)方法  记录阻塞原因，再加上阻塞时间长短</li></ul></li></ul><h4 id="抽象同步队列"><a href="#抽象同步队列" class="headerlink" title="抽象同步队列"></a>抽象同步队列</h4><ul><li><p>AQS   （AbstractQueuedSynchronizer）</p><ul><li><p>是一个FIFO双向队列：通过节点head 和tail记录队首和队尾（Node类型）</p></li><li><p>state 单一状态信息state，实现类根据不同功能使用</p></li><li><p>Node（静态内部类）</p><ul><li>prev记录当前节点的前驱节点</li><li>next记录当前节点的后继节点</li><li>thread变量   存放进入AQS队列的线程</li><li>shared变量   用来标记该线程是获取共享资源时被阻塞挂起后放入AQS队列的</li><li>exclusive变量  用来标记线程是获取独占资源被挂起后放入AQS队列的</li><li>waitStatus变量  记录当前线程等待状态，可以为可以为<ul><li>CANCELLED（线程被取消了）</li><li>SIGNAL（线程需要被唤醒）</li><li>CONDITION（线程在条件队列里面等待）</li><li>PROPAGATE（释放共享资源时需要通知其他节点）</li></ul></li></ul></li><li><p>ConditionObject(内部类)   每个条件变量对应一个条件队列（单向链表队列），其用来存放调用条件变量的await方法（AQS中的方法）后被阻塞的线程，其内部方法包括加入该队列和唤醒线程删除队列，该队列的头尾分别为firstWaiter和lastWaiter</p></li><li><p>线程同步的关键是对状态值state进行的操作（具体的tryAcquire和tryRelease方法，需要由具体的子类实现）</p><ul><li>独占方式下     根据state是否属于一个线程（调用方法中给获得资源的线程标记）<ol><li>void acquire(int arg)<ul><li>会首先使用tryAcquire方法尝试获取资源，具体是设置状态变量state的值，成功则直接返回</li><li>失败则将当前线程封装为类型为Node.EXCLUSIVE的Node节点后插入到AQS阻塞队列的尾部，并调用LockSupport.park（this）方法挂起自己</li></ul></li><li>void acquireInterruptibly(int arg)<ul><li>同上面步骤，区别在会对其他线程的中断反应，抛出InterruptedExcepiton异常而返回</li></ul></li><li>boolean release(int arg)<ul><li>尝试使用tryRelease操作释放资源，这里是设置状态变量state的值，然后调用LockSupport.unpark（thread）方法激活AQS队列里面被阻塞的一个线程（thread）。</li><li>被激活的线程则使用tryAcquire尝试，看当前状态变量state的值是否能满足自己的需要，满足则该线程被激活，然后继续向下运行</li><li>否则还是会被放入AQS队列并被挂起</li></ul></li></ol></li><li>共享方式下（与具体线程不相关，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用CAS方式进行获取即可。比如Semaphore信号量，当一个线程通过acquire（）方法获取信号量时，会首先看当前信号量个数是否满足需要，不满足则把当前线程放入阻塞队列，如果满足则通过自旋CAS获取信号量）<ol><li>void acquireShared(int arg)<ul><li>会首先使用tryAcquireShared尝试获取资源，具体是设置状态变量state的值，成功则直接返回</li><li>失败则将当前线程封装为类型为Node.SHARED的Node节点后插入到AQS阻塞队列的尾部，并使用LockSupport.park（this）方法挂起自己。</li></ul></li><li>void acquireSharedInterruptibly(int arg)<ul><li>同上面步骤，区别在会对其他线程的中断反应，抛出InterruptedExcepiton异常而返回</li></ul></li><li>boolean releaseShared(int arg)<ul><li>会尝试使用tryReleaseShared操作释放资源，这里是设置状态变量state的值，然后使用LockSupport.unpark（thread）激活AQS队列里面被阻塞的一个线程（thread）。</li><li>被激活的线程则使用tryReleaseShared查看当前状态变量state的值是否能满足自己的需要，满足则该线程被激活，然后继续向下运行</li><li>否则还是会被放入AQS队列并被挂起</li></ul></li></ol></li></ul></li><li><p>入队操作：当一个线程获取锁失败后该线程会被转换为Node节点，然后就会使用enq（final Node node）方法将该节点插入到AQS的阻塞队列</p></li><li><p>条件变量（感觉上没有实际含义，就是个序号一样）</p><p>下代码可以看出，一个锁对应一个AQS阻塞队列，对应多个条件变量，每个条件变量有自己的一个条件队列。（就是根据await和signal从阻塞队列和对应条件队列里切换，而不是让其一直CAS自旋竞争锁浪费时间）</p><ul><li>当多个线程同时调用lock.lock（）方法获取锁时，只有一个线程获取到了锁，其他线程会被转换为Node节点插入到lock锁对应的<strong>AQS阻塞队列</strong>里面，并做自旋CAS尝试获取锁</li><li>取到锁的线程又调用了对应的条件变量的await（）方法，则该线程会释放获取到的锁，并被转换为Node节点插入到<strong>条件变量对应的条件队列</strong>里面</li><li>因为调用lock.lock（）方法被阻塞到AQS队列里面的一个线程会获取到被释放的锁，如果该线程也调用了条件变量的await（）方法则该线程也会被放入条件变量的条件队列里面</li><li>另外一个线程调用条件变量的signal（）或者signalAll（）方法时，会把条件队列里面的一个或者全部Node节点移动到AQS的阻塞队列里面，等待时机获取锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition=lock.newCondition();</span><br><span class="line">    Condition condition2=lock.newCondition();</span><br><span class="line">    Thread thread2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始唤醒&quot;</span>);</span><br><span class="line">                condition2.signal();</span><br><span class="line">                System.out.println(<span class="string">&quot;唤醒结束&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread.start();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>独占锁ReentrantLock原理</p><ul><li><p>非公平锁（NonfairSync子类实现）</p><ul><li>这里因为没有顺序的处理，存在别的线程调用lock（）执行代码,锁还未释放，别的调用lock（）方法时锁释放了的时间差</li><li>当前锁没有被其他线程持有,标记当前线程持有，state从0设置成1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>可重入锁实现:识别到是同一个线程，则状态值加1，然后返回true，这里需要注意，nextc&lt;0说明可重入次数溢出了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(current == getExclusiveOwnerThread())&#123;</span><br><span class="line">    <span class="keyword">int</span> nextc=getState()+acquires;</span><br><span class="line">    <span class="keyword">if</span>(nextc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>公平锁（FairSync子类实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Node t=tail;</span><br><span class="line">       Node h=head;</span><br><span class="line">       Node s;</span><br><span class="line">       <span class="keyword">return</span> h!=t &amp;&amp; ((s = h.next)==<span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>一些方法</p><ul><li>boolean tryLock() 方法 尝试获取锁</li><li>boolean tryLock(long timeout, TimeUnitunit) 方法 尝试获取锁，与tryLock（）的不同之处在于，它设置了超时时间，如果超时时间到没有获取到该锁则返回false。</li></ul></li></ul></li><li><p>读写锁ReentrantReadWriteLock原理</p><ul><li>依赖Sync同样实现公平锁和非公平锁</li><li>巧妙地使用state的高16位表示读状态，也就是获取到读锁的次数；使用低16位表示获取到写锁的线程的可重入次数</li><li>写锁WriteLock这个静态内部类实现是独占锁和可重入锁（读锁也会影响写锁）总的来说类似于ReentrantReadWriteLock</li><li>读锁ReadLock这个静态内部类实现是共享锁（但是会受到写锁影响）。<ul><li>如果当前锁没有线程获得，返回true获得锁、</li><li>如果有线程获得了写锁，本线程持有的写锁，也可以获取锁，但是释放的时候记得俩个锁都释放；不是本线程持有的写锁，返回false</li><li>没有线程持有写锁，获取读锁的个数</li><li>如果队列里面存在一个元素，则判断第一个元素是不是正在尝试获取写锁，如果不是，则当前线程判断当前获取读锁的线程是否达到了最大值</li><li>记录第一个获取读锁的线程并统计该线程获取读锁的可重入数</li><li>记录最后一个获取到读锁的线程和该线程获取读锁的可重入数，readHolds记录了当前线程获取读锁的可重入数</li></ul></li></ul></li><li><p>StampedLock（不可重入锁；不是直接实现Lock或ReadWriteLock接口，在内部自己维护了一个双向阻塞队列；非公平锁）（获取乐观读锁时只是检测状态，不需要CAS提升了效率）</p><ul><li>写锁writeLock：是一个排它锁或者独占锁，某时只有一个线程可以获取该锁，当一个线程获取该锁后，其他请求读锁和写锁的线程必须等待，这类似于ReentrantReadWriteLock的写锁（不同的是这里的写锁是不可重入锁）；当目前没有线程持有读锁或者写锁时才可以获取到该锁。请求该锁成功后会返回一个stamp变量用来表示该锁的版本，当释放该锁时需要调用unlockWrite方法并传递获取锁时的stamp参数。并且它提供了非阻塞的tryWriteLock方法。</li><li>悲观读锁readLock：是一个共享锁，在没有线程获取独占写锁的情况下，多个线程可以同时获取该锁。如果已经有线程持有写锁，则其他线程请求获取该读锁会被阻塞，这类似于ReentrantReadWriteLock的读锁（不同的是这里的读锁是不可重入锁）。这里说的悲观是指在具体操作数据前其会悲观地认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在读少写多的情况下的一种考虑。请求该锁成功后会返回一个stamp变量用来表示该锁的版本，当释放该锁时需要调用unlockRead方法并传递stamp参数。并且它提供了非阻塞的tryReadLock方法。</li><li>乐观读锁tryOptimisticRead：它是相对于悲观锁来说的，在操作数据前并没有通过CAS设置锁的状态，仅仅通过位运算测试。如果当前没有线程持有写锁，则简单地返回一个非0的stamp版本信息。获取该stamp后在具体操作数据前还需要调用validate方法验证该stamp是否已经不可用，也就是看当调用tryOptimisticRead返回stamp后到当前时间期间是否有其他线程持有了写锁，如果是则validate会返回0，否则就可以使用该stamp版本的锁对数据进行操作。由于tryOptimisticRead并没有使用CAS设置锁状态，所以不需要显式地释放该锁。该锁的一个特点是适用于读多写少的场景，因为获取读锁只是使用位操作进行检验，不涉及CAS操作，所以效率会高很多，但是同时由于没有使用真正的锁，在保证数据一致性上需要复制一份要操作的变量到方法栈，并且在操作数据时可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。</li><li>StampedLock还支持这三种锁在一定条件下进行相互转换。例如long tryConvertToWriteLock（long stamp）期望把stamp标示的锁升级为写锁，这个函数会在下面几种情况下返回一个有效的stamp（也就是晋升写锁成功）：<ul><li>当前锁已经是写锁模式了。 </li><li>当前锁处于读锁模式，并且没有其他线程是读锁模式</li><li>当前处于乐观读模式，并且当前写锁可用。</li></ul></li></ul></li></ul><h4 id="并发队列原理"><a href="#并发队列原理" class="headerlink" title="并发队列原理"></a>并发队列原理</h4><ul><li><p>offer、poll、take、put等方法源码</p></li><li><p>ConcurrentLinkedQueue   </p><ul><li>线程安全的无界非阻塞队列</li><li>单向链表实现；出入队使用CAS实现原子性</li><li>volatile修饰tail、head节点保证可见性</li><li>size和contains，remove等方法不准，因为当时获得10，可能CAS过程中别的线程有删除</li></ul></li><li><p>LinkedBlockingQueue</p><ul><li>独占锁实现的有界阻塞队列</li><li>单链表实现：head、last表示首尾节点。初始值为0的count变量记录元素个数</li><li>使用takeLock和putLock俩个独占锁（ReentrantLock实例），控制元素入队和出队的原子性</li><li>notEmpty和notFull是条件变量，内部有一个条件队列用来存放进队和出队时被阻塞的线程</li><li>构造方法俩种，无参的默认队列容量Integer.MAX_VALUE，有参的只有一个int参数，为自定义的队列容量。</li><li>俩个锁分别控制入队和出队，所以可以并行，内部逻辑中都有count变量的++或者–，但是同类操作同时只能一个，保证了类似于count&gt;0这样的操作不会因为别的线程调用了poll、take、remove等而导致刚过来校验又不符合了。</li></ul></li><li><p>ArrayBlockingQueue</p><ul><li>独占锁实现的有界阻塞队列</li><li>有界数组方式实现：数组item存放队列，putindex表示入队元素下标，takeIndex表示出队下标，count统计队列元素个数。</li><li>有个独占锁lock用来保证出、入队操作的原子性</li><li>notEmpty和notFull是条件变量，内部有一个条件队列用来存放进队和出队时被阻塞的线程</li><li>构造方法必须传入int 类型capacity，同时只有一个独占锁，另一个构造函数支持boolean类型参数，决定使用公平锁还是非公平锁，默认false非公平锁</li></ul></li><li><p>PriorityBlockingQueue</p><ul><li>带优先级（根据compareTo排序）的无界阻塞队列</li><li>数组queue存放队列元素，size存放队列元素个数。</li><li>allocationSpinLock是个自旋锁，其使用CAS操作来保证同时只有一个线程可以扩容队列，状态为0或者1，其中0表示当前没有进行扩容，1表示当前正在扩容</li><li>由于这是一个优先级队列，所以有一个比较器comparator用来比较元素大小</li><li>有个独占锁lock用来保证出、入队操作的原子性</li><li>notEmpty条件变量用来实现take方法阻塞模式</li></ul></li><li><p>DelayQueue</p><ul><li>无界阻塞延迟队列</li><li>DelayQueue内部使用PriorityQueue存放数据，使用ReentrantLock实现线程同步。另外，队列里面的元素要实现Delayed接口，由于每个元素都有一个过期时间，所以要实现获知当前元素还剩下多少时间就过期了的接口，由于内部使用优先级队列来实现，所以要实现元素之间相互比较的接口；available条件队列存储阻塞等待的队列</li></ul></li></ul><h4 id="并发包中线程池ThreadPoolExecutor"><a href="#并发包中线程池ThreadPoolExecutor" class="headerlink" title="并发包中线程池ThreadPoolExecutor"></a>并发包中线程池ThreadPoolExecutor</h4>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;编程本书基于《java并发编程之美》,持续更新中…源码太枯燥了&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://zhhw137.github.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://zhhw137.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="多线程" scheme="https://zhhw137.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://zhhw137.github.io/2020/09/14/JVM%E7%AF%87/"/>
    <id>https://zhhw137.github.io/2020/09/14/JVM%E7%AF%87/</id>
    <published>2020-09-14T12:30:00.000Z</published>
    <updated>2020-09-23T01:35:07.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Jvm篇根据《深入理解Java虚拟机:JVM高级特性与最佳实践（第三版）》，加上笔者自己的验证理解所做。</p><a id="more"></a><h2 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h2><h3 id="1、JVM内存区域"><a href="#1、JVM内存区域" class="headerlink" title="1、JVM内存区域"></a>1、JVM内存区域</h3><p><img src="/images/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JVM内存模型"></p><ul><li><p>程序计数器  </p><ul><li>是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>每个线程都有一个自己的程序计数器，属于线程私有</li><li>唯一一个不会发生OutOfMemoryError情况的区域</li></ul></li><li><p>Java虚拟机栈（-Xss 128k）</p><ul><li>线程私有，生命周期和线程相同</li><li>每个方法被执行时，jvm会同步创建一个用于存储局部变量表、操作数栈、动态连接、方法出口等信息的栈帧，其入栈到出栈过程即对应着一个方法从被调用到执行完毕的过程。<ul><li>局部变量表：存放了编译器可知的参数类型：java的8大基本类型、对象引用（可能是引用指针或者相关地址）和returnAddress类型（指向了一条字节码指令的地址）。用局部变量槽slot表示局部变量表的存储空间。（long和double64位的这俩个用俩个变量槽，其他一个）</li></ul></li><li>进入方法时，栈帧的分配多大的局部变量空间就完全确定了，方法运行期间不会改变局部变量表的变量槽数量。</li><li>虚拟机栈存在俩种异常<ul><li>Stack Overflow Error 线程请求的栈深度大于虚拟机所允许的深度（深度可以理解成数量）</li><li>OutOfMemory Error 如果虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存（HotSpot不可动态扩展，该异常只会发生在线程一开始申请时）</li></ul></li></ul></li><li><p>本地方法栈  与虚拟机栈类型，只不过本地方法栈调用本地方法即native方法。（所谓native方法，就是可能并非用java实现的底层方法）</p></li><li><p>java堆（又称为GC堆，是垃圾收集器管理的内存区域）</p><ul><li>虚拟机管理内存中最大的一块。</li><li>被所有线程共享的内存区域</li><li><strong>对象实例信息</strong>，几乎所有的对象实例和数组都应当在堆上分配（随着java的发展，可能存在不在上面的对象）</li><li>堆的大小可以是固定大小，也可以使可扩展的（基本都是可扩展的），如果没有内存完成实例分配，又不能继续扩展，抛出OutOfMemoryError异常</li></ul></li><li><p>方法区（java虚拟机的规范，HotSpot在jdk1.8之前用永久代实现，之后用元空间）</p><ul><li><strong>对象类型信息</strong>，各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li><li>JDK1.8前HotSpot用永久代实现方法区原因：省去专门为方法区编写内存管理的工作。（永久代在堆上浪费堆内存）</li><li>JDK1.8后HotSpot用元空间实现方法区：避免了永久代实现的容易内存溢出的问题（永久代有-xx：MaxPermSize的上限，即使不设置也有默认大小）元空间使用本地内存实现，不容易内存溢出</li><li>不需要连续内存，可以选择固定大小或者可扩展。这区域的回收目标主要针对常量池的回收和对类型的卸载，内存回收效果难令人满意尤其是类型的卸载（<a href="https://blog.csdn.net/skzxyzj/article/details/82841061">CSDN博客</a>），条件相当苛刻，但是又是必须的。</li></ul></li><li><p>运行时常量池（方法区的一部分）</p><ul><li>用于存放编译期生成的各种字面量与符号引用</li><li>受限于方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常</li></ul></li><li><p>直接内存</p><ul><li><p>并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p></li><li><p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p></li><li><p>受到本机总内存大小和处理器寻址空间的限制。其他区域动态扩展或者本身动态扩展时大于物理内存限制，出现OutOfMemoryError异常</p></li></ul></li></ul><h3 id="2、对象"><a href="#2、对象" class="headerlink" title="2、对象"></a>2、对象</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p>指针碰撞  假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离</p></li><li><p>空闲列表  但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</p></li><li><p>对象并发创建：</p><ul><li>采用CAS配上失败重试的方式保证更新操作的原子性</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</li></ul></li><li><p>对象头创建</p><ul><li>用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li><li>类型指针 即对象指向它的类型元数据的指针 Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li></ul></li><li><p>执行构造函数方法，给字段赋默认值。完成构造</p></li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。</p><ul><li>句柄    如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息（优点   reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。）</li><li>直接指针   Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销（优点，速度更快，节省了一次指针定位的时间开销）</li></ul><h3 id="3、垃圾收集器与内存分配策略"><a href="#3、垃圾收集器与内存分配策略" class="headerlink" title="3、垃圾收集器与内存分配策略"></a>3、垃圾收集器与内存分配策略</h3><h4 id="确定对象生死"><a href="#确定对象生死" class="headerlink" title="确定对象生死"></a>确定对象生死</h4><ul><li><p>引用计数法  占用额外内存空间进行计数，在对象中添加一个引用计数器，每有一个引用则加一，引用失效则减一，计数器为0则表示不可能再被使用。<strong>优点</strong>：原理简单，判定效率很高。<strong>缺点</strong>：需要配合大量额外处理才能保证正确的工作（比如循环引用就无法计数器为0，释放回收对象，但实际不算使用）</p></li><li><p>可达性算法    通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p>GC Roots的对象包括以下几种</p><ul><li>虚拟机栈中引用的对象  比如各个线程被调用方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象</li><li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li><li>本地方法栈中JNI引用的对象（也就是native方法引用的对象）</li><li>java虚拟机内部的引用：如基本数据类型对应的class对象，一些常驻的异常对象（NullPointException，OutOfMemoryError）等，还有，系统类加载器</li><li>所有被同步锁（synchronized关键字）持有的对象 </li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul></li><li><p>引用类型分类</p><ul><li>强引用  指在程序代码之中普遍存在的引用赋值，即类似Object obj=newObject()   只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</li><li>软引用：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，会在即将内存溢出时，先将这些对象列进回收列表中，进行第二次回收，如果还不够才抛出异常</li><li>弱引用：用来描述那些非必须对象，他的引用强度比软引用更弱。被弱引用关联的对象，在下一次垃圾收集发生则无论内存是否足够都进行回收</li><li>虚引用：最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</li></ul></li><li><p>对象的自我救赎    finalize()  （现在已经放弃，最好别用了）</p></li><li><p>方法区的回收</p><ul><li>废弃的常量回收   常量池中其他类(接口)、方法、字符的符号引用、常量，虚拟机判断没有对其的引用，就会清理出常量池</li><li>不再使用的类型回收   需要满足下面的3个条件<ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul></li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li><p>分代收集理论</p><ul><li><p>弱分代假说：绝大数对象都是朝生夕灭的（诞生新生代）</p></li><li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡（诞生老生代）</p></li><li><p>跨代引用假说：跨代引用相对于同代引用来说仅占极少数（新生代上诞生了记忆集：把老年代划分成若干小块，标识出老年代哪一块内存会存在跨代引用。这样发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描，虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。）</p></li></ul></li><li><p>收集分类</p><ul><li><p>部分收集（Partial GC）指不是完整收集整个Java堆的垃圾收集</p><ul><li><p>新生代收集（Minor GC/Young GC） 指目标只是新生代的垃圾收集</p></li><li><p>老年代收集（Major GC/Old GC）指目标只是老年代的垃圾收集（目前只有CMS收集器会有单独）</p></li><li><p>混合收集（Mixed GC）指目标是收集整个新生代以及部分老年代的垃圾收集（目前只有G1收集器会有这种行为）</p><ul><li>整堆收集（Full GC） 收集整个JAVA堆和方法区的垃圾收集</li></ul></li></ul></li></ul></li><li><p>收集算法</p><ul><li>标记-清除算法   <ul><li>标记阶段：标记要回收或者要存活的对象</li><li>清除阶段：回收标记回收的对象，或者回收标记了存活对象之外未被标记的对象</li><li>缺点：执行效率不稳定，每次要回收的对象数量不确定。内存空间的碎片化问题</li></ul></li><li>标记-复制算法<ul><li>采用半区复制的算法。将内存空间分割成大小相等的俩部分，每次只使用其中一块，当某一块内存用完，将还存活的对象复制到另一块中，这一块的内存空间直接一次清理掉。</li><li>缺点：空间浪费严重</li></ul></li><li>标记-整理算法<ul><li>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</li><li>缺点：移动存活对象，如果是老年代这种，每次都有大量对象存活区域，则会是一个极为负重的操作。而且会导致“Stop The World”：对象移动操作必须全程暂停用户应用程序才能进行。</li></ul></li></ul></li><li><p>HoSpot算法细节实现</p><ul><li>根节点枚举  使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在<strong>特定的位置</strong>记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找（待验证）</li><li>安全点 上述的特殊的位置即为安全点，选取标准为“是否具有让程序长时间执行的特征”，用户程序必须在安全点才能够暂停，这样不需要每一条指令都生成对应的OopMap<ul><li>抢先式中断  （淘汰）垃圾收集发生时，中断所有用户线程，如果发现有用户线程中断的地方不在安全点，则恢复这条线程，一会再重新中断，直到跑到最近安全点上。</li><li>主动式中断  当垃圾收集需要中断线程时，仅仅简单的设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己再最近的安全点上主动中断挂起。轮询标志的地方和安全点重合，再加上所有创建对象和其他需要再java堆上分配内存的地方，这是为了检测是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li></ul></li></ul></li><li><p>安全区域  指能够确保在某一段代码片段之中，引用关系不会发生变化。因此，在这个区域中任意地方开始垃圾收集都是安全的（存在sleep或者blocked状态的线程，无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂机自己，虚拟机也不可能持续等待线程重新被激活分配处理器时间）   实际使用就是，线程执行进入安全区域时标识自己进入了安全区域。当线程要离开时，要检查虚拟机是否已经完成了类似于根节点枚举这样的暂停用户线程阶段，完成了继续执行，没有则等待完成信号。</p></li><li><p>记忆集与卡表</p><ul><li>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</li><li>卡表是记忆集的一种实现方式，HotSpot采用字节数组的方式，其中每一个元素对应着其标识的内存区域中一块特定大小的内存块，称之为卡页。一个卡页内通常包含不只一个对象。当存在跨代指针时，卡表的数组元素即卡页标识为1，称这个元素变脏，当垃圾收集发生时，就取出变脏的卡页，加入GC Roots中一并扫描。</li></ul></li><li><p>写屏障</p><ul><li>将卡表元素变脏的方式。用Aop通知的形式。</li><li>更新时的<strong>伪共享问题</strong>，参数-XX：+UseCondCardMark控制是否在更新卡表的时候，增加一个条件判断。如果当前要更新的缓存行已经被标记为变脏则不在去更新。</li></ul></li><li><p>并发的可达性分析</p><ul><li>采用三色标记，作为工具辅助推到，把遍历对象图过程中遇到的对象，按照“是否访问过”标记成三种颜色<ul><li>白色 表示对象尚未被垃圾收集器访问过。</li><li>黑色 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。</li><li>灰色 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li></ul></li><li>对象消失问题<ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；采用增量更新解决：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。采用原始快照解决:当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</li></ul></li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li><p>Serial收集器 新生代收集器   标记整理算法 单线程工作的收集器，HotSpot默认的新生代收集器</p><ul><li>进行垃圾收集时，必须暂停其他所有工作线程（stop the world）</li><li>优点：简单高效，额外内存消耗最小，对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</li></ul></li><li><p>ParNew收集器  新生代收集器 标记整理算法  支持多线程并行收集，其他与Serial收集器相比并没有太多创新之处。另外主要是因为除了Serial只有它能和CMS配合使用</p></li><li><p>Parallel Scavenge收集器  新生代收集器  基于标记-复制算法 ，该收集器的目标是达到一个可控制的吞吐量（运行用户代码时间/（运行用户代码时间+运行垃圾收集时间））</p><ul><li>-XX：MaxGCPauseMillis参数 控制最大垃圾收集停顿时间</li><li>-XX：GCTimeRatio参数 直接设置吞吐量大小</li><li>-XX：+UseAdaptiveSizePolicy  启动开关，启动后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</li></ul></li><li><p>Serial Old收集器   老年代收集器   标记整理算法   单线程   Serial的老年代版本</p></li><li><p>Parallel Old收集器   老年代收集器  标记复制算法  多线程  Parallel Scavenge老年代版本</p></li><li><p>CMS收集器  标记清除算法实现，老年代收集器   该收集器是一种以获取最短回收停顿时间为目标的收集器</p><ul><li>初始标记  标记GC Roots直接关联对象   stop the world</li><li>并发标记   初始标记的直接关联对象，开始遍历整个对象图的过程。    可以与用户线程并发运行  </li><li>重新标记   修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比初始标记稍长，远短于并发标记） stop the world</li><li>并发清除 清理删除掉标记阶段判断已经死亡对象   与用户线程同时并发。</li><li>缺点<ul><li>与用户并行时会占用一部分线程导致运行速度变慢</li><li>浮动垃圾：在并发标记和并发清除阶段产生的垃圾对象。所以，CMS需要再运行期间预留内存空间，而当预留的内存无法满足程序分配新对象的需要时，出现一次“并发失败”。这时候虚拟机采用备案，使用Serial Old收集器进行老年代的垃圾收集，stop the world</li><li>内存空间碎片 标记清除算法产生的内存空间碎片，在无法找到足够大的连续空间来分配当前对象时，触发full GC  stop the world</li><li>参数-XX：CMSInitiatingOccu-pancyFraction 可以设置CMS的触发百分比</li></ul></li></ul></li><li><p>Garbage First收集器</p><ul><li>面向整个堆内存任何部分来组成回收集（Mixed GC）</li><li>将堆内存划分为大小相等的独立区域Region。每个独立区域可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间，<strong>针对不同的Region采用不同的策略处理</strong></li><li>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。而对于超过了整个Region容量的超级大对象，采用N个连续的Humongous Region存储。</li><li>参数-XX：G1HeapRegionSize 设定Region大小</li><li>参数-XX：MaxGCPauseMillis（默认值200ms）设定允许的收集停顿时间</li><li>初始标记   标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值</li><li>并发标记  从GC Roots中开始对堆中对象进行可达性分析  可以用户程序并发执行。  重新处理SATB记录下的并发是有引用变动的对象</li><li>最终标记  stop the world 处理并发阶段结束后遗留下来的那些少量SATB记录</li><li>筛选回收  负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li><li>缺点<ul><li>G1的记忆集在存储结构的本质是一种哈希表。由于每一个Region都维护有自己的记忆集，内存占用更大（一般要到java堆容量的10%到20%）</li><li>G1通过原始快照算法（SATB）实现重新标记  程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围</li><li>G1收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。换句话说，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</li></ul></li></ul></li><li><p>Shenandoah收集器  G1的下一代升级版</p><ul><li>改进：<ul><li>支持并发整理</li><li>默认不使用分代收集</li><li>将G1中的记忆集更改为连接矩阵。Region N引用Region M则N行M列打上一个标记</li></ul></li><li>初始标记   标记与GC Roots直接关联的对象  会stop the world 但是停顿时间与堆大小无关，只与GC Roots数量有关</li><li>并发标记  与G1一样，遍历对象图，标记出全部可达的对象。与用户线程一起并发。时间长短取决于堆中存活数量以及对象图的结构复杂程度。  并发执行</li><li>最终标记  与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将其构成一组回收集。   短暂 stop the world</li><li>并发清理  清理那些整个区域连一个存活对象都没有找到的Region    并发执行</li><li>并发回收  Shenandoah回收器的核心差异点。这个阶段，回收集里面的存活对象先复制一份到其他未使用的Region之中，采用读屏障（存在新对象复制，旧对象写入，转发指针改变的并发问题，采用读屏障解决）和Brooks Pointers的转发指针（就是直接多了一步转发，对象都指向转发地址，只需要改转发地址就可以）来解决并发阶段的困难 时间长短取决于回收集的大小  并发执行 </li><li>初始引用更新   只是建立一个线程集合点确保上一个阶段对象移动任务已经完成   stop the world</li><li>并发引用更新  进行引用更新操作，只需要按照内存物理地址的顺序，线性地搜索出引用类型，将旧对象的引用地址修正到新对象引用地址。    时间长短取决于内存中涉及的引用数量的多少。 并发执行</li><li>最终引用更新  解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。  停顿时间与GC Roots数量有关    stop the world</li><li>并发清理  调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li></ul></li><li><p>ZGC收集器   基于Region内存布局的，（暂时）不设分代，使用读屏障、染色指针和内存多重映射等技术来实现的<strong>可并发标记-整理算法</strong>，以低延迟为首要目标的一款垃圾收集器。</p><ul><li>Region具有动态性：动态创建和销毁，以及动态的区域容量大小。<ul><li>小型Region    容量固定为2MB，用于放置小于256KB的小对象</li><li>中型Region   容量固定为32MB，用于放置大于等于256KB但小于4MB的对象</li><li>大型Region   容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。一个大型Region中只会存放一个大对象。所以可能大型的Region的容量小于中型Region</li></ul></li><li>染色指针  直接将少量额外信息存储在指针上   通过4个标志信息，可以看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能够通过finalize（）方法才能被访问<ul><li>一旦某个Region存活对象被移动走后，能够立即释放这个Region并重用（Shenandoah在极端情况下要1:1才行）</li><li>大幅度降低内存屏障的使用数量。</li><li>是一种可扩展的存储结构，可以记录更多与对象标记、重定位过程相关数据，以便日后进一步提高性能。</li></ul></li><li>初始标记   初始化GC Roots      stop the world</li><li>并发标记  遍历对象图做可达性分析（初始，并发，最终）初始和最终也会短暂停顿。不同的是，ZGC的标记在染色指针上更新Marked 0、Marked 1标志位</li><li>并发预备重分配   ZGC划分Region，但是其目的不是为了像G1那样做收益优先的增量回收。相反，ZGC每次会扫描所有的Region（用扫描成本省去G1中的记忆集维护成本）因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。此外，在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。</li><li>并发重分配   ZGC核心阶段：这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（ForwardTable），记录从旧对象到新对象的转向关系（指针自愈：得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象）因为指针自愈的关系，不需要像Shenandoah的Brooks转发指针每次都转，只有第一次访问旧对象才会。</li><li>并发重映射：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，不同于Shenandoah的迫切，因为自愈特性，ZGC将其放在了下一次垃圾回收的并发标记阶段去执行，省去了一次遍历对象图的开销。</li><li>缺点：对象产生速率太快的情况下，<strong>因为没有采用分代</strong>，导致浮动垃圾越来越多，堆中剩余可腾挪的空间就越来越小</li></ul></li><li><p>对象的分配</p><ul><li>对象优先在Eden区中分配，当Eden区没有足够空间进行分配时，进行一次minor GC  <ul><li>-XX：Survivor-Ratio=8  设置eden和一个survivor区容量对比</li><li>-Xms20M   java堆大小为20MB</li><li>-Xmx20M 20=20 所以是设置堆不可扩展</li><li>-Xmn10M 新生代10MB</li></ul></li><li>大对象直接进入老年代（最典型的大对象是很长的字符串，或者元素数量很庞大的数组）<ul><li>-XX：PretenureSizeThreshold=3M 可以设置多大算大对象，这里大于3M在老年代创建对象（只针对Serial和PerNew俩款新生代收集器有效）</li></ul></li><li>长期存活的对象将进入老年代（分代收集）<ul><li>虚拟机给每个对象定义一个对象年龄计数器 Age，存储在对象头中。当对象在Eden区中诞生，经历过一次Minor GC并存活，且能被Survivor容纳，则进入Survivor，age设置为1，每进来一次Minor GC年长一岁，经历过设置的晋升老年代的阈值（默认15），则进入老年代。</li><li>-XX：MaxTenuringThreshold 设置晋升阈值</li></ul></li><li>动态对象年龄判断<ul><li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代</li></ul></li><li>空间分配担保（JDK6 之后参数无效，一定会担保）<ul><li>发生Minor GC之前，虚拟机必须检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果条件成立，则执行，不成立则虚拟机检查XX：HandlePromotionFailure参数的设置值是否允许担保失败；如果允许，那会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象平均大小，大于则尝试进行一次Minor GC，小于，或者该参数设置不允许冒险，则改为进行一次Full GC</li></ul></li></ul></li></ul><h3 id="4、虚拟机辅助工具"><a href="#4、虚拟机辅助工具" class="headerlink" title="4、虚拟机辅助工具"></a>4、虚拟机辅助工具</h3><h4 id="Java虚拟机自带命令行工具（一些基本工具，其余使用过程中需要再学）"><a href="#Java虚拟机自带命令行工具（一些基本工具，其余使用过程中需要再学）" class="headerlink" title="Java虚拟机自带命令行工具（一些基本工具，其余使用过程中需要再学）"></a>Java虚拟机自带命令行工具（一些基本工具，其余使用过程中需要再学）</h4><ul><li><p>jps：虚拟机进程状况工具</p><ul><li><p>jps [options] [hostid] （windows需要到jps所在路径下执行）   列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。（使用哪个虚拟机进程的hostid说明在操作哪个虚拟机）</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出LVMID，省略主类的名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main（）函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果进程执行的是jar包，则输出jar路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时的JVM参数</td></tr></tbody></table></li></ul></li></ul><ul><li><p>jstat：虚拟机统计信息监视工具</p><ul><li><p>jstat  [option vmid [ interval [s|ms] [count] ] (示例  jstat -gc 2764 250 250 表示250ms查一次进程2764垃圾收集状况，一共查询20次)  (当时远程虚拟机进程时vmid格式应当是)    [protocol:] [//] lvmid [@hostname [:port] /servername]  </p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载，卸载数量，总空间以及类装载所耗费的时间</td></tr><tr><td>-gc</td><td>监视java堆状况，包括Eden区，2个Survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代垃圾收集状况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代垃圾收集状况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>-compiler</td><td>输出即时编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被即时编译的方法</td></tr></tbody></table></li></ul></li><li><p>jinfo：Java配置信息工具（有部分运行期参数修改数值的能力）</p><ul><li>实时查看和调整虚拟机各项参数。  jinfo [option]  pid  （jinfo -flag CMSInitiatingOccupancyFraction 1444）</li><li>java -XX：+PrintFlagsFinal 查看参数默认值</li></ul></li><li><p>jmap：Java内存映像工具</p><ul><li><p>该命令用于生成堆转储快照，它还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。（一般称为heapdump或dump文件）（如果不使用jmap命令，要想获取Java堆转储快照也还有一些比较“暴力”的手段：譬如在第2章中用过的-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。）</p></li><li><p>jmap [option] vmid  （示例：jmap -dump：format=b，file=eclipse.bin 3500）</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成Java堆转储快照。格式为-dump：[live,] format=b,file=<filename> ,其中live子参数说明是否只dump出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在f-queue中等待Finalizer线程执行finalize方法的对象，只在linux/Solaris平台下有效</td></tr><tr><td>-heap</td><td>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等，只在Linux/Solaris平台下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-permstat</td><td>以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台下有效</td></tr><tr><td>-F</td><td>当虚拟机进程对-dump选项没有响应事，可使用这个选项强制生成dump快照，只在Linux/Solaris平台有效</td></tr></tbody></table></li></ul></li><li><p>jhat：虚拟机堆转储快照分析工具（分析功能相对来说比较简陋，耗费性能所以一般要拷贝到另一台机器进行分析，既然复制了，用其他工具则更好。）</p></li><li><p>jstack ：Java堆栈跟踪工具</p><ul><li><p>用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因：如线程间死锁、死循环、请求外部资源导致的长时间停顿挂起等</p></li><li><p>从JDK 5起，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈</p></li><li><p>jstack [option] vmid</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用到本地方法的话，可以显示C/C++ 的堆栈</td></tr></tbody></table></li></ul></li></ul><h4 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h4><ul><li>JConsole：Java监视与管理控制台  JDk正式成员  免费</li><li>JHSDB：基于服务性代理的调试工具   JDK正式成员 免费</li><li>VisualVM：多合-故障处理工具  独立开源项目 免费</li><li>JMC：可持续在线的监控工具  OpenJDK组织管理开源   收费（需要与HotSpot内部的“飞行记录仪”-JFR配合工作，JFR收费）</li></ul><h4 id="HotSpot虚拟机插件"><a href="#HotSpot虚拟机插件" class="headerlink" title="HotSpot虚拟机插件"></a>HotSpot虚拟机插件</h4><ul><li>HSDIS:JIT生成代码反汇编  可以将即时编译器动态生成的本地代码还原为汇编代码输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题</li></ul><h3 id="5、调优案例分析与实战"><a href="#5、调优案例分析与实战" class="headerlink" title="5、调优案例分析与实战"></a>5、调优案例分析与实战</h3><ul><li><p>大内存硬件程序部署策略（一台大电脑）</p><ul><li>逻辑集群部署（在一台物理机器上启动多个应用服务器进程，为每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。使用无Session复制的亲合式集群是一个相当合适的选择。）</li><li>单独java虚拟机（控制Full GC频率，让其在深夜定时执行，避免GC时间过长影响用户使用）</li></ul></li><li><p>集群间同步导致的内存溢出</p><ul><li>全局缓存，在收到正确信息前，发送的信息一直存在内存中保留，在网络传输不满足时，重发数据累计</li></ul></li><li><p>堆外内存导致的溢出错误</p><ul><li>直接内存：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出OutOf-MemoryError或者OutOfMemoryError：Direct buffer memory</li><li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（如果线程请求的栈深度大于虚拟机所允许的深度）或者OutOfMemoryError（如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存）。</li><li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，可能会抛出IOException：Toomany open files异常。</li><li>JNI代码：如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中，而是占用Java虚拟机的本地方法栈和本地内存的。</li></ul></li><li><p>外部命令导致系统缓慢</p><ul><li>使用java调用外部shell脚本等会导致创建新的进程，抢占了系统的处理器资源。</li></ul></li><li><p>服务器虚拟机进程奔溃</p><ul><li>与别的系统接口对接，如果对方服务响应时间长，而这边采用同步/异步的方式，会建立大量的Socket连接，最终导致进程奔溃。解决方法：一个是对方系统加快响应，一个是本机系统用消息队列</li></ul></li><li><p>不恰当数据结构导致内存占用过大</p></li><li><p>由windows虚拟内存导致的长时间停顿</p><ul><li>程序最小化后，工作内存被自动交换到磁盘的页面文件之中，这样发生垃圾收集时，就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。</li></ul></li><li><p>由安全点导致长时间停顿（在循环中等待进入安全点）</p><ul><li>HotSpot虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用int类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环（CountedLoop），相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为不可数循环（Uncounted Loop），将会被放置安全点。</li></ul></li></ul><h2 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h2><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><ul><li><p>无符号数  基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p></li><li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯的以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质也可以视作一张表。</p></li><li><p>class文件(在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。使用javap工具的-verbose参数输出的TestClass.class文件字节码内容   javap -verbose TestClass)</p><ul><li><p>魔数（Magic Number）头4个字节，用于确定这个文件是否为一个能被虚拟机接受的class文件。（值为0xCAFEEBABE）</p></li><li><p>第5,6位字节是次版本号（Minor Version）第7,8位字节是主版本号（Major Version） Java的版本号从45开始，JDK1.1支持45.0<del>45.65535；JDK1.2支持45.0</del>46.65535；JDK13 45.0~57.65535（关于次版本号，曾经在现代Java（即Java 2）出现前被短暂使用过，JDK 1.0.2支持的版本45.0～45.3（包括45.0～45.3）。JDK 1.1支持版本45.0～45.65535，从JDK 1.2以后，直到JDK12之前次版本号均未使用，全部固定为零。而到了JDK 12时期，由于JDK提供的功能集已经非常庞大，有一些复杂的新特性需要以“公测”的形式放出，所以设计者重新启用了副版本号，将它用于标识“技术预览版”功能特性的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号标识为65535，以便Java虚拟机在加载类文件时能够区分出来。）</p></li><li><p>常量池：主次版本号之后为其入口。Class文件出现的第一个表类型数据项目，因为其数量不固定，入口放置一项u2类型数据代表常量池容量计数值（constant_pool_count) <strong>这个容量计数从1开始而不是0；比如0x0016对应十进制22，即容量为21</strong>   常量池主要内容是</p><ul><li>字面量（Literal） 字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等</li><li>符号引用（Symbolic References）<ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul></li></ul></li><li><p>访问标志（access_flags）：常量池结束之后，紧接着的2个字节。这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等</p></li><li><p>类索引、父类索引与接口索引集合</p><p>Class文件中由这三项数据来确定该类型的继承关系</p><ul><li>类索引（this_class） u2类型  类索引用于确定这个类的全限定名</li><li>父类索引（super_class） u2类型 父类索引用于确定这个类的父类的全限定名</li><li>接口索引集合（interfaces）一组u2类型 （入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量）  被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</li></ul></li><li><p>字段表集合  用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。   包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）</p></li><li><p>方法表集合 Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样。包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes） <strong><em>方法重载（Overload），除了要求和原方法具有相同的简单名称之外，还需要一个与原方法不同的特征签名</em></strong> java代码层面的特征签名只包括，方法名称、参数顺序及参数类型，而字节码还额外包括方法返回值以及受查异常表。</p></li><li><p>属性表集合（不需要严格的顺序，其他地方需要）</p><ul><li><p>code属性</p><ul><li>max_stack代表了操作数栈（Operand Stack）深度的最大值</li><li>max_locals代表了局部变量表所需的存储空间</li></ul><p><strong><em>在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。这个处理只对实例方法有效，如果代码清单6-1中的inc()方法被声明为static，那Args_size就不会等于1而是等于0了。</em></strong></p></li><li><p>Exceptions属性  Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。(try catch finally 属于异常表)</p></li><li><p>LineNumberTable属性    用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点</p></li><li><p>LocalVariableTable及LocalVariableTypeTable属性   用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值</p></li><li><p>SourceFile及SourceDebugExtension属性    用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p></li><li><p>ConstantValue属性   通知虚拟机自动为静态变量赋值 <a href="https://www.jianshu.com/p/8a14ed0ed1e9">简书init和clinit对比</a></p><p>对非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>()方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<clinit>()方法中或者使用ConstantValue属性。目前Oracle公司实现的Javac编译器的选择是，如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就将会生成ConstantValue属性来进行初始化；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<clinit>()方法中进行初始化。</p></li><li><p>InnerClasses属性  用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p></li><li><p>Deprecated及Synthetic属性</p><ul><li>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</li><li>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的</li></ul></li><li><p>StackMapTable属性   复杂的变长属性，位于code属性的属性表中    这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p></li><li><p>Signature属性  记录泛型签名信息</p></li><li><p>BootstrapMethods属性  它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符</p></li><li><p>MethodParameters属性   变长属性  记录方法的各个形参名称和信息</p></li><li><p>模块化相关属性</p></li><li><p>运行时注解相关属性</p></li></ul></li></ul></li></ul><h3 id="2、字节码指令简介"><a href="#2、字节码指令简介" class="headerlink" title="2、字节码指令简介"></a>2、字节码指令简介</h3><ul><li><p>加载和存储指令</p><ul><li>将一个局部变量加载到操作栈：iload、iload_&lt; n&gt;、lload、lload_&lt; n&gt;、fload、fload_&lt; n&gt;、dload、dload_&lt; n&gt;、aload、aload_&lt; n&gt;·</li><li><em>将一个数值从操作数栈存储到局部变量表：istore、istore</em>&lt; n&gt;、lstore、lstore_&lt; n&gt;、fstore、fstore_&lt; n&gt;、dstore、dstore_&lt; n&gt;、astore、astore_&lt; n&gt;</li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt; i&gt;、lconst_&lt; l&gt;、fconst_&lt; f&gt;、dconst_&lt; d&gt;</li><li>扩充局部变量表的访问索引的指令：wide</li></ul></li><li><p>运算指令</p><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor·按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul></li><li><p>类型转换指令</p></li><li><p>窄化类型转换 i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f</p></li><li><p>对象创建与访问指令</p><ul><li>创建类实例的指令：new</li><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li><li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul></li><li><p>操作数栈管理指令</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值互换：swap</li></ul></li><li><p>控制转移指令</p><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li><li>复合条件分支：tableswitch、lookupswitch</li><li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li></ul></li><li><p>方法调用和返回指令（方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的）</p><ul><li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li><li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li><li>invokestatic指令：用于调用类静态方法（static方法）。</li><li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><p>返回指令：</p><ul><li>ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn</li></ul></li><li><p>异常处理指令</p><ul><li>athrow：显示抛出异常的操作（throw语句）</li><li>一些虚拟机自己定义的异常状况：idiv或ldiv指令。抛出ArithmeticException异常</li></ul></li><li><p>同步指令（锁）</p><ul><li>方法级  方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</li><li>代码块  同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有<strong>monitorenter</strong>和<strong>monitorexit</strong>两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持</li></ul></li></ul><h3 id="3、类加载机制"><a href="#3、类加载机制" class="headerlink" title="3、类加载机制"></a>3、类加载机制</h3><p>Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的</p><h4 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h4><ul><li><p>加载（Loading）</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li><p>连接（Linking）（加载阶段优先于连接阶段，但是会有部分交叉在加载阶段进行执行）</p><ul><li><p>验证（Verification）</p><ul><li><p>文件格式验证  如之前的版本号，魔数开头，文件本身或各个部分是否有被删除或者附加其他信息；<strong>目的</strong>：保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p></li><li><p>元数据验证    这个类的父类是否继承了不允许被继承的类；如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。等等</p><p><strong>目的</strong>：对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</p></li><li><p>字节码验证  对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：保证任何跳转指令都不会跳转到方法体以外的字节码指令上</p><p><strong>目的</strong>：通过数据流分析和控制力分析，确定程序语义是合法的、符合逻辑的。</p></li><li><p>符合引用验证（这是验证第4阶段，一般在解析阶段进行）  通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。例如 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。对应java.lang.NoSuchFieldError、java.lang.NoSuchMethodError</p></li></ul></li></ul><p><strong>目的</strong>  符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验。</p><ul><li><p>准备（Preparation）为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。（这个时候的变量赋值为0，真正初始化在<clinit>方法；如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值例如：public static final int value=123）</p></li><li><p>解析（Resolution）</p><ul><li>符号引用 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li><li>直接引用  直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li><li>类解析<ul><li>假设在D类中加载C类，如果C不是一个数组类型，则将全限定名传给D之后进行各种验证</li><li>如果C是数组类型，如果是对象数组。重复步骤1，如果不是，由虚拟机生成一个代表该数组维度和元素的数组对象。</li><li>上述俩步没问题，则进行最后的权限验证。如果不具备访问权限，抛出java.lang.illegalAccessError异常（由于jdk1.9模块的引入导致public类也存在权限问题）</li></ul></li><li>字段解析<ul><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li><li>将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ul></li><li>方法解析<ul><li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li><li>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ul></li><li>接口解析<ul><li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li><li>在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常。</li></ul></li></ul></li></ul></li><li><p>初始化（Initialization）（有且只有下列6种情况）</p><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。（对应的java代码场景：使用new关键字实例化对象的时候、读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候、调用一个类型的静态方法的时候）</li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</li><li>当初始化类的时候，如果发现其父类还没有初始化，则需要先触发其父类的初始化（接口不需要，只有在真的用到父接口时初始化）</li><li>虚拟机启动时，用户指定的一个要执行的主类（main方法那个类），虚拟机会先初始化这个主类</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li><li><clinit>   （没有静态变量和语句块，没有该方法）<ul><li>编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的静态变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</li><li><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是Object类。所以这也意味着父类中定义的静态语句块优先于子类的变量赋值操作。</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</li><li>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞</li></ul></li></ul></li><li><p>使用（Using）</p></li><li><p>卸载（Unloading）</p></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><p>类加载器 （判断俩个对象是否是同一个，一定要用同一个类加载器）</p><ul><li>自定义类加载器</li><li>启动类加载器 类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中</li><li>扩展类加载器  这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>应用程序类加载器  这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li></ul></li><li><p>双亲委派模型  （为了使所有的类加载转接到同一个父类上，保证是同一个对象）</p><ul><li><p>原理  要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p></li><li><p>工作过程  果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p></li><li><p>双亲委派模型的突破</p><ul><li><p>为了向下兼容：如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p></li><li><p>自身缺陷：有基础类型又要调用回用户的代码 例如：JNDI服务（JDBC这种）   引入了一个不太优雅的设计：线程上下文类加载器（Thread ContextClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<strong>这是一种父类加载器去请求子类加载器完成类加载的行为</strong></p></li><li><p>用户对程序动态性的追求：代码热替换（Hot Swap）、模块热部署（HotDeployment）等   </p><p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><ul><li>将以java.*开头的类，委派给父类加载器加载</li><li>否则，将委派列表名单内的类，委派给父类加载器加载。</li><li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li><li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li><li>否则，类查找失败。</li></ul></li></ul></li></ul></li></ul><h4 id="java模块化"><a href="#java模块化" class="headerlink" title="java模块化"></a>java模块化</h4><ul><li>依赖其他模块的列表。</li><li>导出的包列表，即其他模块可以使用的列表。</li><li>开放的包列表，即其他模块可反射访问模块的列表。</li><li>使用的服务列表。</li><li>提供服务的实现列表。</li><li>模块兼容性<ul><li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（UnnamedModule）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li><li>模块在模块路径的访问规则：模块路径下的具名模块（NamedModule）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</li><li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li></ul></li><li>扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代</li><li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载</li></ul><h3 id="4、虚拟机字节码执行引擎"><a href="#4、虚拟机字节码执行引擎" class="headerlink" title="4、虚拟机字节码执行引擎"></a>4、虚拟机字节码执行引擎</h3><h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><ul><li><p>局部变量表   一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。其在Java程序被编译为Class文件时，就确定了最大容量（在方法的Code属性的max_locals数据项中确定了）</p><ul><li>变量槽为最小单位，一个变量槽可以存放32位以内的数据类型：boolean、byte、char、short、int、float、reference和returnAddress。俩个变量槽 存 long和double（虽然被分割成俩个变量槽了，但是jvm不允许任何操作其中某一个的变量槽，再加上线程私有所以也安全）</li><li>局部变量表的调用采用索引，32位n代表第n个变量槽，64位n代表n和n+1个，对于实例方法，空出来0索引作为本方法的对象实例（this），其他从1开始</li><li>变量槽可以重用，在方法体内的变量可能并不需要生存整个方法体，垃圾回收发生在方法未结束时，不显示置为null或者别的变量覆盖的情况下，会影响垃圾回收（局部变量表是GCroots的一部分）（<strong>不推荐使用，因为现在的编译优化了，而且实际虚拟机使用解释器时可能也有处理</strong>）这些情况可以看情况进行显示清空<strong>（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到即时编译器的编译条件）</strong></li></ul></li><li><p>操作数栈     也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。</p><ul><li>操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</li><li>方法刚开始时，操作数栈为空。方法执行过程中，各种字节码指令往操作数栈中写入和提取内容，也就是出入栈操作。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，iadd指令只能操作俩个int类型相加</li></ul></li><li><p>动态连接    个栈帧都包含一个指向运行时常量池[插图]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p><ul><li>我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为<strong>静态解析</strong>。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为<strong>动态连接</strong></li></ul></li><li><p>方法返回地址</p><ul><li>正常调用完成    执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定</li><li>异常调用完成    在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出</li></ul></li></ul><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><ul><li>解析  解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成<ul><li>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析<ul><li>invokestatic。用于调用静态方法</li><li>invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法</li><li>invokevirtual。用于调用所有的虚方法（重写的方法，因为只有调用的时候才知道是不是多态的，是不是往上找）  （就是被final修饰方法不是虚方法但是也是这个指令），Java对象里面的方法默认（即不使用final修饰）就是虚方法</li><li>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象</li><li>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的</li></ul></li></ul></li><li>分派<ul><li>静态分派 （解释了为什么调用的是父类的方法）（重载  Overload）<ul><li>“Human”称为变量的“静态类型”（Static Type），或者叫“外观类型”（Apparent Type），后面的“Man”则被称为变量的“实际类型”（Actual Type）或者叫“运行时类型”（Runtime Type）。</li><li>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么</li></ul></li><li>动态分派 （Override 重写）<ul><li>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</li><li>实例方法是使用 invokevirtual指令调用的<ul><li>找到操作数栈顶的第一个元素所指向的对象的<strong>实际类型</strong>，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ul></li><li>只存在虚方法不存在虚字段，要是类里面有同名字段，则子类字段会遮蔽父类的同名字段</li></ul></li><li>单分派与多分派<ul><li>静态分派属于多分派类型  实际类型和参数作为宗量</li><li>动态分派属于单分派类型 只有实际类型作为宗量</li></ul></li><li>虚拟机动态分派的实现<ul><li>一般建立一个虚方法表，存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址</li><li>在invokeinterface执行时也会用到接口方法表——InterfaceMethod Table，简称itable</li></ul></li></ul></li></ul><h4 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h4><ul><li><p>invokedynamic指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        MethodType mt=MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">        Field lookupImpl=MethodHandles.Lookuo.class.getDeclaredField(&quot;IMPL_LOOKUP&quot;);</span><br><span class="line">        lookupImpl.setAcceddible(<span class="keyword">true</span>);</span><br><span class="line">        MethodHandle mh=((MethodHandles.Lookup)lookupImpl.get(<span class="keyword">null</span>)).findSpecial(GrandFather.class,&quot;thinking&quot;,mt,GrandFather.class);</span><br><span class="line">        mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h4><ul><li>基于栈的指令集<ul><li>主要优点 是可移植，因为寄存器由硬件直接提供[插图]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束</li><li>主要缺点是理论上执行速度相对来说会稍慢一些，所有主流物理机的指令集都是寄存器架构也从侧面印证了这点</li></ul></li></ul><h4 id="类加载架构"><a href="#类加载架构" class="headerlink" title="类加载架构"></a>类加载架构</h4><ul><li>正统类加载结构<ul><li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离</li><li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享</li><li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响</li><li>支持JSP应用的Web服务器，十有八九都需要支持HotSwap（热替换）功能。</li><li>以tomcat为例实现上述功能：<ul><li>放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</li><li>放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</li><li>放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li><li>放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li><li>tomcat6以后简化了默认的目录结构；将/common,/server和/shared3个目录默认合并到了一起变成一个/lib目录，如果默认设置不满足，可以通过修改配置文件，指定server.loader和share.loader的方式重新启用原来完整的加载器架构</li></ul></li></ul></li><li>OSGi：灵活的类加载器架构 （有存在出现循环依赖的可能，jdk7之后，将锁粒度到了类级别，有一定缓解）<ul><li>Bundle    OSGi中的每个模块（称为Bundle）与普通的Java类库区别并不太大，两者一般都以JAR格式进行封装[插图]，并且内部存储的都是Java的Package和Class。但是一个Bundle可以声明它所依赖的Package（通过Import-Package描述），也可以声明它允许导出发布的Package（通过Export-Package描述）。在OSGi里面，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖，而且类库的可见性能得到非常精确的控制，一个模块里只有被Export过的Package才可能被外界访问，其他的Package和Class将会被隐藏起来。</li><li>加载方式<ul><li>以java.*开头的类，委派给父类加载器加载。</li><li>否则，委派列表名单内的类，委派给父类加载器加载</li><li>否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载</li><li>否则，查找当前Bundle的Classpath，使用自己的类加载器加载。</li><li>否则，查找是否在自己的Fragment Bundle中，如果是则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载</li><li>否则，类查找失败。</li></ul></li></ul></li></ul><h2 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h2><p>编译期</p><ul><li>前端编译期：把*.java文件转变成  *.class文件的过程   JDK的javac</li><li>即时编译期 运行期把字节码转变成本地机器码的过程  HotSpot的C1、C2编译器</li><li>提前编译期 直接把程序编译成与目标机器指令集相关的二进制代码的过程  JDK的Jaotc</li></ul><h4 id="JavaC编译器（前端编译）"><a href="#JavaC编译器（前端编译）" class="headerlink" title="JavaC编译器（前端编译）"></a>JavaC编译器（前端编译）</h4><ul><li><p>准备过程：初始化插入式注解处理器</p></li><li><p>解析与填充符号表过程</p><ul><li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树  <ul><li>词法分析   com.sun.tools.javac.parser.Scanner类实现  是将源代码的字符流转变为标记（Token）集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。    int a=b+2，包含6个标记   </li><li>语法分析是  com.sun.tools.javac.parser.Parser类实现   根据标记序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</li><li>这个阶段产出的抽象语法树是以com.sun.tools.javac.tree.JCTree类表示的</li></ul></li><li>填充符号表。产生符号地址和符号信息<ul><li>符号表（Symbol Table）填充符号表的过程由com.sun.tools.javac.comp.Enter类实现   是由一组符号地址和符号信息构成的数据结构，读者可以把它类比想象成哈希表中键值对的存储形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等各种形式）。</li></ul></li></ul></li><li><p>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段</p><ul><li>可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次（Round）</li><li>插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</li></ul></li><li><p>分析与字节码生成过程</p><ul><li>标注检查。对语法的静态信息进行检查  Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类<ul><li>注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等</li><li>常量折叠优化 int a=1+2 和 int a=3 是一个工作量</li></ul></li><li>数据流及控制流分析。对程序动态运行过程进行分析   com.sun.tools.javac.comp.Flow类来完成<ul><li>它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题   </li></ul></li><li>解语法糖。将简化代码编写的语法糖还原为原有形式  解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成</li><li>字节码生成。将前面各个步骤所生成的信息转化成字节码。  Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成<ul><li>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作 比如 <clinit>和没有申明<init> 方法时的空<init>方法</li></ul></li><li>com.sun.tools.javac.jvm.ClassWriter类 最终输出Class文件</li></ul></li><li><p>语法糖</p><ul><li><p>泛型：java是类型擦除式泛型  在运行期再实际</p><ul><li>“裸类型”（Raw Type）  该泛型的父类    该泛型可以使ArrayList<int>  ArrayList<String>等待</li><li>为了解决int和long之类的转换。  直接加入自动拆装箱</li></ul></li><li><p>自动拆装箱与遍历循环</p></li><li><p>条件编译  使用条件为常量的if语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;block 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h4><h5 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h5><p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器激进优化时后备的“逃生门”（如果情况允许，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行，因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作</p><ul><li><p>解释器：直接将代码解释为机器可以执行的</p></li><li><p>编译器：将代码编译成本地机器码。</p></li><li><p>分层编译（用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量）</p><ul><li>第0层。程序纯解释执行，并且解释器不开启性能监控功能</li><li>第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能</li><li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能</li><li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息</li><li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化</li></ul></li><li><p>热点代码</p><ul><li>被多次调用的方法  由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式</li><li>被多次执行的循环体  但编译器依然必须以整个方法作为编译对象，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）。这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为“栈上替换”（OnStack Replacement，OSR），即方法的栈帧还在栈上，方法就被替换了。</li></ul></li><li><p>热点代码识别方式</p><ul><li>基于采样的热点探测（Sample Based Hot Spot CodeDetection）。 采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li>基于计数器的热点探测（Counter Based Hot Spot CodeDetection）。<ul><li>-XX：CompileThreshold 设置方法计数器阈值   服务端默认10000次，客户端默认1500次</li><li>-XX：BackEdgeThreshold供用户设置，但是当前的HotSpot虚拟机实际上并未使用此参数，我们必须设置另外一个参数-XX：OnStackReplacePercentage来间接调整回边计数器的阈值<ul><li>虚拟机运行在客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以OSR比率（-XX：OnStackReplacePercentage）除以100。其中-XX：OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为13995</li><li>虚拟机运行在服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以（OSR比率（-XX：OnStackReplacePercentage）减去解释器监控比率（-XX：InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，-XX：InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为10700</li></ul></li><li>-XX：-UseCounterDecay来关闭热度衰减   当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半；这个时间周期被称为半衰周期。</li><li>-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒</li><li>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程</li><li>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值（这个阈值是<strong>方法计数器+回边计数器</strong>（即为栈上计数器，为循环体上的次数））就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li></ul></li><li>参数-XX：-BackgroundCompilation来禁止后台编译  <ul><li>在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行；  </li><li>后台编译被禁止后，当达到触发即时编译的条件时，执行线程向虚拟机提交编译请求以后将会一直阻塞等待，直到编译过程完成再开始执行编译器输出的本地代码。</li></ul></li></ul></li></ul><h5 id="提前编译器"><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h5><ul><li>提前编译器（JAVA 9引入Jaotc作为提前编译器，代码质量相对较好，可以极限榨取性能）<ul><li>静态提前编译   在程序运行之前把程序代码编译成机器码的静态翻译工作（可以采用很多重负载优化手段，如过程间分析）</li><li>动态提前编译  把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用。（本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题）（<strong>限制了使用的HotSpot虚拟机的参数，和运行的目标机器也有关</strong>）</li></ul></li><li>即时编译器编译的代码质量的部分优点<ul><li>性能分析制导优化    如果一个条件分支的某一条路径执行特别频繁，而其他路径鲜有问津，那就可以把热的代码集中放到一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它    <strong>比如热代码</strong></li><li>激进预测性优化  相对于提前编译来说，即时编译的策略就可以不必这样保守，如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果   <strong>比如虚方法调用（大部分方法都是直接调用虚方法，不对再回退）</strong></li><li>链接时优化 （LTO） java天生动态链接，但是C和C++不是</li></ul></li></ul><h5 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h5><ul><li>方法内联（最重要）<ul><li>Java虚拟机首先引入了一种名为类型继承关系分析（Class Hierarchy Analysis，CHA）的技术，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。<ul><li>如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的</li><li>如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为守护内联（GuardedInlining）不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。假如在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</li><li>假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用是真正发生了的，但是比起直接查虚方法表还是要快一些。内联缓存是一个建立在目标方法正常入口之前的缓存，它的工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种单态内联缓存（Monomorphic Inline Cache）。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。但如果真的出现方法接收者不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成超多态内联缓存（Megamorphic Inline Cache），其开销相当于真正查找虚方法表来进行方法分派。</li></ul></li></ul></li><li>逃逸分析（最前沿）<ul><li>基本原理：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</li><li>栈上分配（HotSpot目前不支持）：Java虚拟机中，Java堆上分配创建对象的内存空间几乎是Java程序员都知道的常识，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。</li><li>标量替换：若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java中的对象就是典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</li><li>同步消除（Synchronization Elimination）：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉</li><li>参数-XX：+DoEscapeAnalysis来手动开启逃逸分析</li><li>使用+XX：+EliminateLocks来开启同步消除</li><li>使用参数-XX：+PrintEliminateAllocations查看标量的替换情况</li></ul></li><li>公共子表达式消除（语言无关）<ul><li>如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E</li><li>如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common SubexpressionElimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global CommonSubexpression Elimination）</li><li>int d=（c * b）* 12+a+(b * c+a );  可以优化成  int d=E*12+a+(E+a)  有些编译器还可能采用代数化简 int d=E * 13+a+a;</li></ul></li><li>数组边界检查消除、自动装箱消除、安全点消除、消除反射（语言相关）</li><li>Graal编译器</li></ul><h2 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h2><h3 id="Java内存模型（并发）"><a href="#Java内存模型（并发）" class="headerlink" title="Java内存模型（并发）"></a>Java内存模型（并发）</h3><ul><li><p>java内存模型</p><ul><li>主内存（Main Memory）：所有变量存储的地方</li><li>工作内存  保存了被该线程使用的变量的主内存副本[插图]，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据[插图]。</li><li>线程   不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</li></ul></li><li><p>内存间交互操作</p><ul><li>lock  锁定  作用于主内存变量，把一个变量标识为一条线程独占的状态</li><li>unlock 解锁 作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read 读取 作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便load动作使用</li><li>load 载入 作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use 使用  作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</li><li>assign 赋值 作用于工作内存变量，把一个从执行引擎接受的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li>store 存储  作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后write操作使用</li><li>write 写入 作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul></li><li><p>执行上述8种基本操作时必须满足的规则</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</li></ul></li><li><p>volatile变量使用场景</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li><li>变量不需要与其他状态变量共同参与不变约束</li><li>禁止指令重排序优化<ul><li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现。                 <strong>这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改</strong></li><li>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现            <strong>这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改</strong></li><li>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q                                                           <strong>这条规则要求volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同</strong></li></ul></li></ul></li><li><p>原子性、可见性、有序性</p><ul><li>原子性（Atomicity） 锁之外的6个基本操作，保证了基本类型的访问、读写都是具备原子性的。lock和unlock保证了synchronized块之间的操作具备原子性</li><li>可见性（Visibility）指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改<ul><li>volatile变量：保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</li><li>synchronized 同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的</li><li>final关键字：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值</li></ul></li><li>有序性 <ul><li>volatile关键字本身就包含了禁止指令重排序的语义</li><li>而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul></li><li>先行发生原则（时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准）<ul><li>程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构</li><li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</li><li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li><li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li><li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。</li><li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul></li></ul></li></ul><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><ul><li><p>内核线程实现（1:1线程模型）</p><ul><li>定义：直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核（Multi-ThreadsKernel）</li><li>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（我们通常意义上所讲的线程）<ul><li>优点：每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作、</li><li>缺点：各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源</li></ul></li><li>一个系统支持的轻量级进程的数量有限；由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程</li></ul></li><li><p>用户线程（1：n线程模型（绿色线程））</p><ul><li>定义：<ul><li>广义上一个线程只要不是内核线程，都可以认为是用户线程（UserThread，UT）的一种(包括了轻量级进程)</li><li>狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的</li></ul></li><li>优点：不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理</li><li>缺点：线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的。因为使用用户线程实现的程序通常都比较复杂</li></ul></li><li><p>混合实现（m:n线程模型）</p><ul><li>定义：在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险</li></ul></li><li><p>java线程</p><ul><li>java虚拟机在主流平台上采用1：1的线程模型</li><li>采用抢占式线程调度<ul><li>协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。（线程阻塞导致不稳定）</li><li>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定</li></ul></li><li>java存在线程优先级（但只是参考不准）（setPriority()方法 1~10  10个值 10最大，一般默认5）</li></ul></li><li><p>java线程状态  在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换</p><ul><li>新建（New）   创建后尚未启动的线程处于这种状态</li></ul></li><li><p>运行（Runnable） 包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间</p><ul><li><p>无限期等待（Waiting） 处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：</p><ul><li>没有设置Timeout参数的Object::wait()方法</li></ul></li></ul></li><li><p>没有设置Timeout参数的Thread::join()方法 （thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。）</p><ul><li>LockSupport::park()方法（LockSupport类是Java6(JSR166-JUC)引入的一个类，提供了基本的线程同步原语类似于wait和notify）</li></ul></li><li><p>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p><ul><li>Thread::sleep()方法<ul><li>设置了Timeout参数的Object::wait()方法；</li></ul></li><li>设置了Timeout参数的Thread::join()方法；</li><li>LockSupport::parkNanos()方法；</li><li>LockSupport::parkUntil()方法。<ul><li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   ThreadTest threadTest=<span class="keyword">new</span> ThreadTest(sb,stringBuilder,<span class="number">1</span>);</span><br><span class="line">LockSupport.park(threadTest);<span class="comment">//wait</span></span><br><span class="line">   LockSupport.unpark(threadTest);<span class="comment">//notify</span></span><br></pre></td></tr></table></figure><h4 id="java与协程"><a href="#java与协程" class="headerlink" title="java与协程"></a>java与协程</h4><ul><li>纤程（Fiber）  java的有栈携程 还在开发中（Loom项目，2018开始）</li></ul><h3 id="线程安全与锁优化（高效）"><a href="#线程安全与锁优化（高效）" class="headerlink" title="线程安全与锁优化（高效）"></a>线程安全与锁优化（高效）</h3><h4 id="线程安全分类"><a href="#线程安全分类" class="headerlink" title="线程安全分类"></a>线程安全分类</h4><ul><li>不可变<ul><li>如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的</li><li>如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。（最简单的一种就是把对象里面带有状态的变量都声明为final；String就是）</li></ul></li><li>绝对线程安全  线程安全的类（即各个方法都加上了synchronized），任然需要再实际调用方法中增加锁</li><li>相对线程安全  我们通常意义上所讲的线程安全。它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</li><li>线程兼容 指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。</li><li>线程对立 指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码<ul><li>suspend()和resume()方法</li><li>System.setIn()、Sytem.setOut()和System.runFinalizersOnExit()</li></ul></li></ul><h4 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h4><ul><li>互斥同步（Mutual Exclusion &amp;Synchronization）<ul><li>定义：是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用</li><li>互斥手段：临界区（CriticalSection）、互斥量（Mutex）和信号量（Semaphore）</li><li>synchronized  <ul><li>转化成monitorenter和monitorexit进行块锁定  这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</li><li>被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况</li><li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出</li></ul></li><li>ReentrantLock（重入锁）<ul><li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助</li><li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<strong>synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。</strong></li><li>锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可</li></ul></li><li>synchronized与ReentrantLock<ul><li>synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized</li><li>Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放</li><li>尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li></ul></li></ul></li><li>非阻塞同步  基于冲突检测的乐观并发策略<ul><li>硬件指令集CAS发展产生无锁编程</li><li>CAS比较并交换（Compare-and-Swap）<ul><li>CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</li><li>ABA问题：可以用版本号解决</li></ul></li></ul></li><li>无同步方案<ul><li>定义    要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系。同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的</li><li>可重入代码（简单判断原则：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的）<ul><li>不依赖全局变量</li><li>存储在堆上的数据和公用的系统资源</li><li>用到的状态量都由参数中传入</li><li>不调用非可重入的方法</li></ul></li><li>线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。典型引用：web交互模型：一个请求对应一个服务器线程。</li><li>如果一个变量只要被某个线程独享。可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</li></ul></li></ul><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul><li>自旋锁与自适应自旋<ul><li>自旋锁定义：现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁</li><li>优点：锁占用时间短，可以避免线程切换的开销</li><li>缺点：一直自旋，会拜拜消耗处理器时间。</li><li>自适应自旋：如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。</li></ul></li><li>锁消除<ul><li>对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除（主要依据逃逸分析的数据支持）</li></ul></li><li>锁粗化<ul><li>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。比如循环方法</li></ul></li><li>轻量级锁（在无竞争的情况下使用CAS操作去消除同步使用的互斥量）<ul><li>能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。</li><li>加锁是首先通过CAS操作，CAS操作成功则避免使用互斥量的开销。不成功，则轻量级锁也会膨胀成重量级锁，再加上CAS操作，反而会更慢。</li></ul></li><li>偏向锁（在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了）<ul><li>参数-XX：-UseBiasedLocking来禁止偏向锁优化</li><li>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作则一直不需要同步操作（加锁、解锁及对Mark更新等）</li><li>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;Jvm篇根据《深入理解Java虚拟机:JVM高级特性与最佳实践（第三版）》，加上笔者自己的验证理解所做。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://zhhw137.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://zhhw137.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="https://zhhw137.github.io/2020/09/07/mysql%E7%AF%87/"/>
    <id>https://zhhw137.github.io/2020/09/07/mysql%E7%AF%87/</id>
    <published>2020-09-07T13:30:00.000Z</published>
    <updated>2020-11-02T01:14:08.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Mysql的深入点了解，主要建立在《MySQL技术内幕：Innodb存储引擎（第二版）》的基础上，记录的知识点和一些自己验证后发现的自己的个人感觉书里表述不清的地方，当然，笔者是java后端的开发，一些比较偏DBA的地方有进行略过。</p><a id="more"></a><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>数据库：物理操作系统文件或其他形式文件类型的集合(数据的仓库)</p><p>实例：Mysql数据库由后台线程以及一个共享内存区组成(进程，也是我们实际以为的数据库)</p><p>范式：<a href="https://zhuanlan.zhihu.com/p/20028672">知乎</a></p><p>存储引擎 到表级别  show ENGINEs 查看    InnoDB，MyISAM       其他</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>innoDB 缓冲池  大小默认1G 个数默认1个（可扩展增加性能）</p><p>内存缓冲池管理技术 ： LRU list: lru和unzip_LRU   Free List     Flush list</p><p>​            脏页刷新回磁盘 CheckPoint  ( 类比redis缓存失效)   </p><ul><li>master thread 定时刷新  </li><li>flush_lru_list  不能保证100个空闲页供使用     LRU列表尾端淘汰的页</li><li>Async/Sync Flush Checkpoint  重做日志文件不可用   flush list 腾出空间来</li><li>Dirty Page too much 为了保持缓冲池中有足够的页</li></ul><p>InnoDB 关键特性</p><ul><li>插入缓冲</li><li>俩次写（doublewrite）<ul><li>partial page write ： InnoDB 的Page Size一般是16KB，其数据校验也是针对这16KB来计算的，将数据写入到磁盘是以Page为单位进行操作的。而计算机硬件和操作系统，在极端情况下（比如断电）往往并不能保证这一操作的原子性，16K的数据，写入4K 时，发生了系统断电/os crash ，只有一部分写是成功的，这种情况下就是 partial page write 问题。<br>很多DBA 会想到系统恢复后，MySQL 可以根据redolog 进行恢复，而mysql在恢复的过程中是检查page的checksum，checksum就是pgae的最后事务号，发生partial page write 问题时，page已经损坏，找不到该page中的事务号，就无法恢复。</li><li>为了解决 partial page write 问题 ，当mysql将脏数据flush到data file的时候, 先使用memcopy 将脏数据复制到内存中的double write buffer ，之后通过double write buffer再分2次，每次写入1MB到共享表空间，然后马上调用fsync函数，同步到磁盘上，避免缓冲带来的问题，在这个过程中，doublewrite是顺序写，开销并不大，在完成doublewrite写入后，在将double write buffer写入各表空间文件，这时是离散写入。<br>如果发生了极端情况（断电），InnoDB再次启动后，发现了一个Page数据已经损坏，那么此时就可以从doublewrite buffer中进行数据恢复了。</li></ul></li><li>自适应哈希索引</li><li>异步IO</li><li>刷新邻接页</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>参数文件   正常mysql的参数配置文件(可以没有，mysql有自己默认的一套)</li><li>socket文件    UNIX域套接字方式连接时候的文件</li><li>pid文件   mysql实例的进程id文件</li><li>mysql表结构文件   用来存放mysql表结构定义文件</li><li>存储引擎文件<ul><li>表空间文件</li><li>重做日志文件（redo log）</li></ul></li><li>日志文件<ul><li>错误日志文件   记录错误信息和警告</li><li>二进制文件  记录对数据库有更改的无所谓是否成功的操作(即不包括show和select)，主要用于恢复、复制、审计作用（通过信息，判断是否有注入攻击）</li><li>慢查询日志文件   根据参数long_query_time默认10s  记录执行慢的查询语句，即一个语句如果执行之间超过这个参数记录下来。  log_queries_not_using_indexes 记录没有使用索引的语句 。 slow_query_type  表示启用慢查询日志的方式：0 不记录，1记录超时的，2记录逻辑io次数超的，3都记录</li><li>查询日志文件 记录所有执行的sql语句，包括未能执行的。具体其他和慢查询一样</li></ul></li></ul><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul><li><p>索引组织表：根据主键顺序组织存放的表(因此数据即索引，索引即数据)</p></li><li><p>InnoDB逻辑存储结构</p><ul><li><p>表空间</p></li><li><p>段     索引段(非叶子节点)、数据段（叶子节点）、回滚段</p></li><li><p>区   由连续页组成，大小一定为1MB</p></li><li><p>页  管理最小单元    数据页、undo页、系统页、事务数据页、插入缓冲位图也、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页</p></li><li><p>行  存储格式:redundant(不推荐使用了)  compact(存储溢出数据的前768字节)/dynamic(8以后的默认格式，存储溢出数据的前20个字节)  针对text，blob大类型数据一旦溢出就拆分多个页存储     compressed 压缩格式，对数据索引都压缩其物理存储层面，读取到内存中要转换，影响性能  </p><p>多字节字符（utf-8，gbk）情况下 char和varchar没有区别，会自己填充</p></li></ul></li><li><p>页详细结构    </p><ul><li>File Header 文件头 38字节</li><li>Page Header 页头 56字节</li><li>Infimun和Supremum Records 限定边界</li><li>User Records 行记录</li><li>Free Space 空闲空间</li><li>Page Directory 页目录  B+树索引只能找到对应的页位置，时间数据是页加载到内存中，再进行二叉查找</li><li>File Trailer  文件结尾信息  8字节</li></ul></li><li><p>约束机制保证数据完整性</p><p>约束方式</p><ul><li>Primary Key 主键约束</li><li>Unique key 唯一索引约束</li><li>Foreign key 外键约束</li><li>Default 默认值</li><li>NOT NULL 不为空</li></ul><p>添加方式</p><ul><li>表建立时进行约束定义</li><li>利用Alter Table 命令进行创建</li><li>Unique Key 可以通过 create unique index建立</li><li>enum（男，女） set(1,2,’1,2’)建立约束</li></ul><p>约束和索引的区别：约束是逻辑概念，用来保证数据完整性，索引是物理和逻辑概念是一个数据结构，也代表着物理存储方式 详细解释 ：<a href="https://www.cnblogs.com/zjfjava/p/6922494.html">博客</a></p><p>不符合约束条件的错误数据：mysql底层转换成正确数据，发出警告（可通过sql_mode参数进行提示调整和报错）</p></li><li><p>触发器</p><ul><li><p>一个表最多建6个触发器：(update delete insert) * (before after)</p><p>基本语法 create trigger name  before|after   update|insert|delete   on  table  for each row (rtigger_stmt   此处为按照语法写的处理逻辑)</p></li></ul></li><li><p>外键约束</p><ul><li>MyISAM 不支持外键，其只是一种类似的注释作用</li><li>alter table stumarks add foreign key (stuno) references stuinfo(id) on delete set null on update cascade;   通过on delete和on update定义父表执行该操作时，子表的处理逻辑。<ul><li>cascade 同步</li><li>set null 子表中的数据更新为null 子表允许的情况下</li><li>no action 抛出错误不允许操作</li><li>restrict  抛出错误不允许操作，也是不指定外键类型的时候的默认值</li></ul></li></ul></li><li><p>视图</p><ul><li>由sql查询语句定义的虚表，没有实际物理存储</li><li>语法  create( or replace)  View name (column_list) as (select_stmt sql查询语句)   with  cascaded|local check option       cascaded 满足所有相关视图和表的条件，local 满足自身条件<ul><li>delete 操作，只能操作视图中存在的数据，有无 with check option相同</li><li>update 有时，必须update之后的数据符合视图条件</li><li>insert 有符合视图条件</li></ul></li></ul></li><li><p>物化视图（oralce自带，mysql通过触发器实现）</p><p>​    该视图转成真的基表实际存在的实表，加快在复杂sql语句生成的视图是查询效率慢的问题。</p><p>​    查询重写：查询基表时判断是否能够从其对应的物化视图中读取数据，可以就直接从视图中读取</p><ul><li>俩种创建方式<ul><li>build immediate 创建物化视图的时候就进行数据的生成</li><li>build deferred 创建视图时候不生成数据，后期再说</li></ul></li><li>刷新模式<ul><li>on demand 用户根据需要的时候再刷新数据</li><li>on commit 基本DML操作提交后直接刷新数据</li></ul></li><li>刷新方式<ul><li>fast 增量刷新</li><li>complete 全量刷新</li><li>force 数据库判断用fast还是complete</li><li>never 物化视图不进行刷新</li></ul></li></ul></li><li><p>分区表(分区字段一定要是主键或者是联合主键中的一个)</p><p>mysql只支持分平分和局部分区索引，即一个分区既存放了数据又存放了索引。而全局分区是所有数据索引单独存放爱一个对象中，只有数据存放在各个分区中</p><ul><li>RANGE分区 分区值连续,但是也需要指定一个大于或者小于的范围数据在哪个分区，多用来做时间的分隔，如按年分区，一年一区，想查某一年数据则只会查一个分区，想删除某一年数据直接删除分区  alter table 表名 drop partoion 分区名</li><li>LIST分区  分区离散 指定固定的值分布在哪个分区</li><li>HASH分区  通过自定的hash函数，将数据分布在哪个分区，在给定的数不是离散的情况下，可以较好的做到均匀分布 还有一种 LINEAR HASH 分区 <strong><em>优点</em></strong>：增加、删除、合并和拆分分区更快捷适合处理含有大量数据的表。**<em>缺点**</em>：相比较于hash分区，分布可能不太均匀</li><li>KEY分区 通过mysql自带的哈希函数进行分区  LINEAR就是其中一种</li><li>COLUMNS 分区   可以使用<strong>任一列作为分区，而不是像之前四种只能用整型(key支持使用除了text和blob之外的类型)，可以使用多个列进行分区</strong>，具有RANGE和LIST有RANGE COLUMNS和LIST COLUMNS俩种</li><li>子分区 在分区的基础上再进行分区，也就是复合分区即range和list上面进行hash和key分区</li></ul><p>对null值的处理，mysql会把null视为比任何值都小的值，所以range放在最左边分区，list需要显示指定null分区，hash和key会将其计算为0</p></li></ul><h3 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h3><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul><li>普通索引：create index index_name on tab_name (col_name); 仅加速查询</li><li>唯一索引: create unique index index_name on tab_name (col_name); 加速查询+列值唯一，但值允许为null</li><li>主键索引: primary key  加速查询+列值唯一+表中只能有一个，且值不能为null</li><li>联合索引 create [unique] index index_name on tbl_name (col_name,col_name)  多列值组成一个索引，专门用于组合搜索，效率大于索引合并（对多个索引分别按照条件扫描，将结果进行合并)。最左匹配原则，且对第二个键进行了排序。**(a,b,c)给a,b,c三列建联合索引则a,b同时使用时c有进行排序，(a,b)给a,b建立的索引有给b建立索引**<ul><li>select .. from tbl where a=xxx order by b   和    where a=xxx and b=xx order by c   (a,b,c) 可以使用到索引</li><li>select … from tbl where a=xxx  order by c  (a,b,c)不使用索引 (a,c)使用索引</li></ul></li><li>全文索引：对文本内容进行分词，进行搜索</li><li>覆盖索引: (或称索引覆盖)应该算一种辅助索引命中场景，即从辅助索引中就可以得到查询的记录,而不需要根据存储的信息查找聚集索引中的记录。(其叶子节点存着数据primary key1 和primary key2,key1,key2,执行类似select primary key1,key2 from tbl where key1=xx)。另外<strong>执行统计</strong>的时候，因为辅助索引数量远小于聚集索引,选择辅助索引可以减少IO操作。</li></ul><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ul><li><p>B+树是平衡查找树但不是二叉树 B 指代的是balance 根据键值对快速查找到数据所在的页，再将页读取到内存中进行 <strong>二分查找</strong>  (详情见数据结构篇)   。<strong>支持like ‘xxx%’这种索引方式</strong></p><ul><li>聚集索引  按照每张表的主键构造的一棵B+树,每个表唯一,叶子节点中存放的即为整张表的行记录数据，即数据页，每个数据页通过一个双向链表来进行链接,页中的数据也通过双向链表链接。因为双向链表的数据顺序性，适合范围查询和排序查找。<ul><li>聚集索引是逻辑上连续而物理存储上并不一定连续(符合链表的存储结构且消耗相对小)</li></ul></li><li>辅助索引(也称为非聚集索引)   叶子节点并不包含所有的行记录数据。叶子节点除了包含键值对以外，还包括一个书签(bookmark)，用来告诉innodb在哪里可以找到索引对应的数据记录(其就是对应行记录的聚集索引键)。辅助索引指向的是最高的那层树即辅助索引高度3 聚集索引高度3 查找数据要io访问6次</li></ul></li><li><p>索引管理</p><ul><li><p>增加 create [unique] index index_name [index_type] on tbl_name (index_col_name)   删除 drop index index_name on tbl_name</p></li><li><p>show index from tbl_name 展示索引的具体属性</p><ul><li>table 表名</li><li>non_unique  0代表是唯一的索引，1代表非唯一索引</li><li>seq_in_index 该列在索引中的位置，组合索引因为有最左匹配原则</li><li>collation 列以什么方式存储再索引中，A或null  B+树索引是排序的所以是A，hash索引则是null</li><li>Cardinality  索引中唯一值的数目的估计值，（3行记录，则没有重复显示3行,有一行重复显示2行,尽可能与行记录数一值,该值<strong>不是实时更新</strong> 可以通过<strong>analyze table company</strong>进行强制更新），非常小，则应该考虑删除索引</li><li>sub_part  是否是列的部分被索引，显示100则为前100字符进行索引</li><li>NULl 代表索引中是否允许含有null值</li></ul></li><li><p>索引创建机制    </p><ul><li><p>针对辅助索引：Fast Index Creation 快速索引创建FIC，给表增加S锁，表只读</p></li><li><p>针对主键索引：</p><ul><li>创建一张临时表(和原表一样的结构),</li><li>导入原表数据</li><li>删除原表</li><li>将临时表命名为原来的表</li></ul></li><li><p>Online Schema change</p></li><li><p>Online DDL   在线数据定义,是将DML操作日志写入缓存中,索引创建完毕再执行达到一致性。缓存大小默认128MB由innodb_online_alter_log_max_size控制。</p><p>  语法，在正常语句(alter table tbl_name add index index_name (col_name))后面+（,ALGORITHM=DEFAULT|INPLACE|COPY）(,LOCK=DEFAULT|NONE|SHARED|EXCLUSIVE)</p><ul><li>ALGORITHM 指定创建删除索引的算法 copy创建临时表形式，inplace不创建临时表,根据参数old_alter_table判断OFF(默认)inplace       on则为 copy</li><li>lock则是加锁情况(<strong><em>其他语句也可以用</em></strong>)   none,不加锁  share 加S锁只读    exclusive x锁排他,阻塞所有线程     default从none开始判读是否可用直到exclusive</li></ul></li></ul></li><li><p>Cardinality  索引中不重复记录数量的预估值。cardinality/n_rows_in_table 应该尽可能接近1。越接近1代表着索引是高选择性的，即这列的每个值越不相同。</p><ul><li>更新策略：采样方法  cardinality=(8个叶子节点记录数)*B+树索引叶子节点数量/8  因此每次的值可能不同,且值并不准确。innodb_stats_method判断如何对待索引中出现的null值记录,<ul><li>nulls_equal    null视为同一条记录即100个null也是一条</li><li>nulls_unequal  null视为不同记录100个也是100条</li><li>nulls_ignored  null不视为一条记录</li></ul></li><li>更新节点：1、表中1/16的数据已发生过变化；2、stat_modified_counter&gt;2000 000 000 inndb存储引擎内部有这么个计数器，用来记录发生变化的次数</li></ul></li></ul></li><li><p>索引的特殊场景</p><ul><li>优化器不使用索引   范围查找数据(就算辅助索引查到了之后是离散的数据，需要主键索引再差消耗io更大。而主键索引是顺序读的远快于离散读)且需要的是整行数据(辅助索引只存了主键), 可使用 force index 强制使用某个索引</li><li>Multi-Range Read优化（重点是排序后顺序查找）     MRR优化目的是为了减少磁盘的随机访问，将它转化为较为顺序的数据访问。就是将通过辅助索引查询到的结果，按照<strong>主键进行排序</strong>，在按照排序顺序进行书签查找，这可以减少缓冲池中页被替换的次数以及批量处理对键值的查询操作。(处理键值对的时候会进行拆分，这样可以在拆分过程中,直接过滤一些不符合查询条件的数据 select * from t where a&gt;1000 and a&lt;2000 and b=100,可以在取出来符合a的范围数据后，通过b进行过滤，性能巨大提升)<ul><li>mrr 表示是否启用mrr优化  on/off   set @@optimizer_switch=’mrr=on’</li><li>mrr_cost_based 表示是否通过cost based 方式选择启动mrr，就是说是否基于mrr的成本考虑mrr是否值得  set @@optimizer_switch=’mrr_cost_based=on’</li><li>read_rnd_buffer_size 控制键值的缓冲区大小 默认256K</li></ul></li><li>Index Condition Pushdown（重点是过滤）   ICP  mysql取出索引的同时，判断是否进行where条件的过滤，也就是将where的部分过滤操作放到存储引擎层。在某些查询下，可以大大减少上层sql层对记录的索取，从而提高数据库整体性能。（类似 select * from tbl where a=’1’  and b like ‘%xx’ 按照a索引取的数据，通过b先过滤再取出）</li></ul></li></ul><h4 id="全文索引-Full-Text-Search"><a href="#全文索引-Full-Text-Search" class="headerlink" title="全文索引(Full-Text Search)"></a>全文索引(Full-Text Search)</h4><ul><li><p>倒排索引：一种索引结构，在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射</p><ul><li>inverted file index  表现形式 【单词，单词所在文档id】  （some,2） some这个单词所在记录id为2</li><li>full inverted index 表现形式 【单词，（单词所在文档id，在具体文档中的位置）】（some,(2:3,6)）some这个单词所在记录id为2 ，在单词中3和6都出现了</li></ul></li><li><p>全文索引的构成</p><ul><li>Auxiliary Table 持久的辅助表存放于磁盘上</li><li>FTS Index Cache 全文检索索引缓存，红黑树结构，根据（word，list）（上面的一个2:3(documentid,position)即为list中的一个）排序</li><li>全文检索查询时才将缓存写入辅助表(类似于插入缓存的机制比如缓存满了立即同步到辅助表等)</li><li>FTS Document ID 。innodb中为了有一列与word进行映射支持全文检索，定义了一列FTS_DOC_ID 其类型必须是BIGINT UNSIGNED NOT NULL并且存储引擎会在其上加上名为FTS_DOC_ID_INDEX的Unique Index.可以自己添加也可以由存储引擎加</li><li>删除操作中,辅助表中被删除的记录，会记录其FTS Document ID,并将其保存在delete auxiliaty table中，只能用户手工将记录彻底删除，optimize table</li><li>stopword list 记录word不需要进行索引分词操作的单词，例如 the。可用户自己维护</li><li>全文检索限制：<ul><li>每张表只能有一个全文检索的索引</li><li>由多列组合而成的全文检索的索引必须使用相同的字符集和排序规则</li><li>不支持没有单词界定符的语言，如：中日韩</li></ul></li><li>全文索引具体使用语法：感觉限制了中文，这种全文检索应该被es代替了，不用过多关注</li></ul></li></ul><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>  innodb不支持人为设置hash索引，其具有自适应哈希索引,innodb会监控对表上二级索引的查找，如果发现某二级索引被频繁访问(最近连续被访问三次的数据),二级索引称为热数据，建立哈希索引。且innodb的哈希索引只支持where a=’xx’这种情况</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访（）。innodb支持行锁级</p><ul><li><p>latch  闩锁，轻量级,对象是线程，用于保护内存数据结构，存在于每个数据结构的对象中，持续时间为临界资源，用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制，仅通过应用程序加锁的顺序保证无死锁的情况，要求其锁定时间必须非常短，时间长则应用性能非常差。其有俩种分类</p><ul><li>mutex  互斥量(互斥锁)</li><li>rwlock 读写锁</li></ul></li><li><p>lock  对象是事务，用来保护数据库内容，如表、页、行，持续在整个事务过程中，具有waits-for gtaph、time out等机制进行死锁检测与处理，存在于lock manager的哈希表中</p><ul><li>行锁</li><li>表锁</li><li>意向锁（Intention lock）</li></ul></li></ul><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>一个事务已经获得了行r的共享锁，允许其他事务获得该行的s锁,(锁兼容) 不允许其他事务获得排他锁，只能等上面的共享锁和排他锁都释放了(锁不兼容)</p><ul><li>共享锁 (S Lock) 允许事务读一行数据   允许</li><li>排他锁 (X Lock) 允许事务删除或更新一行数据</li></ul><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>innodb支持多粒度锁定，导致允许事务执行过程中行锁和表锁同时存在。为了支持再不同粒度加锁，诞生了意向锁（intention lock），其不会阻塞除全表扫以外的任何请求。</p><ul><li>意向共享锁（IS Lock）,事务想要获得一张表<strong>某几行</strong>的共享锁</li><li>意向排他锁（IX Lock），事务想要获得一张表中<strong>某几行</strong>的排他锁</li></ul><table><thead><tr><th></th><th>IS</th><th>IX</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>IS</td><td>兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IX</td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><ul><li><p>锁相关表</p><ul><li>select * from information_schema.INNODB_TRX  查看事务的相关信息</li><li>select * from Performance_Schema.data_locks  查看锁相关信息（8以前 information_schema.INNODB_LOCKS） 其中一列lock_data事务锁定的记录的主键值，表锁为null，但是这个值行锁是也并不可信（范围值只锁第一行主键，锁住的页从缓冲池中被刷出，则也会显示null）</li><li>select * from Performance_Schema.data_lock_waits  查看当前等待的事务以及对应的锁（8以前 information_schema.INNODB_LOCK_WAITS）</li></ul></li><li><p>一致性非锁定读</p><p>指innodb通过多版本控制的方法来读取当前执行时间数据库中行的数据。如果读取的行正在执行delete和update操作，不会去等待锁的释放，而是读取undo中该行**<em>上一个版本(事务隔离级别为REPEATALBE REDA(mysql 默认)如果是READ COMMITTED 则不是上一个版本，而是数据最初版本)**</em>的快照数据。（一行数据可能不只一个快照数据，称之为多版本并发控制Multi Version Concurrency Control ，MVCC）</p></li><li><p>一致性锁定读</p><p> 这俩个select 锁定语句必须在事务中进行，所以一定要加上begin，start transaction或者set autocommit=0</p><ul><li>select_stamt for update    末尾加for update 显示的申明给该行加上x锁（不允许其他事务加锁，但是可以读，因为可以一致性非锁定读，读别的快照数据）</li><li>select_stamt lock in share mode  末尾加，显示的申明给该行加上s锁</li></ul></li><li><p>自增长与锁</p><table><thead><tr><th>插入类型</th><th>说明</th></tr></thead><tbody><tr><td>insert-like</td><td>指所有的插入语句如insert、insert …select、repalce、load data等</td></tr><tr><td>simple inserts</td><td>插入时确定了插入的行数如insert</td></tr><tr><td>bulk inserts</td><td>插入时不能确定插入行数 如 insert …select ,replace…select</td></tr><tr><td>mixed-mode inserts</td><td>一部分数据是自增长的一部分数据是确定的，如insert 心痛（‘5’，col）</td></tr></tbody></table></li></ul><table><thead><tr><th>innodb_autoinc_lock_mode</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>只采用表锁AUTO-INC-LOCKING方式实现自增长。</td></tr><tr><td>1</td><td>simple inserts采用互斥量的方式，bulk insert采用表锁。</td></tr><tr><td>2</td><td>只采用互斥量的方式</td></tr></tbody></table><ul><li><p>外键和锁</p><p>为了避免父表数据被更改或者删除，而字表插入数据，之后数据不一致。对字表数据插入时，查询父表的操作不采用一致性非锁定读的方式。</p></li></ul><h4 id="锁定算法"><a href="#锁定算法" class="headerlink" title="锁定算法"></a>锁定算法</h4><ul><li><p>Record Lock 记录锁 单个行记录上的锁</p></li><li><p>Gap Lock 间隙锁，锁定一个范围，但不包含记录本身</p></li><li><p>Next-Key Lock 临键锁：Gap Lock+Record Lock 锁定一个范围，并且锁定记录本身</p><ul><li>Next-Key Locking    左开右闭   （10,100] (<strong>主流</strong>)</li><li>previous-key locking    左闭右开  [10,100)</li></ul></li><li><p>对于唯一索引的锁定，next-key lock会降级成record lock，多列索引只用一个也不会降级。而普通索引则会加上next-key lock，同时给下一个辅助索引范围加上gap lock。**<em>没有索引的列或者索引失效，则进行表锁**</em></p><ul><li>比如 select * from tbl where b=3 for update  数据（b：1,3,6,8）俩列，a为主键，b有辅助索引</li><li>这时给（1,3] 加next-key lock 给（3，6）加gap lock</li></ul></li><li><p>俩种方式关闭</p><ul><li>事务隔离级别设置为READ Committed</li><li>将参数innodb_locks_unsafe_for_binlog 设置为1</li></ul></li><li><p>Phantom Problem指在同一事务下，连续执行俩次同样的sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行。可以用上面的间隙锁进行避免</p></li></ul><h4 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h4><ul><li>脏读  不同事务下，当前事务可以读到另外事务未提交的数据。事务隔离级别是 read uncommitted时才会发生。</li><li>不可重复读    指在一个事务内多次读取同一个数据集合，在这个事务还没结束时，另一个事务进行DML操作，导致第一个事务第二次读数据可能不一样。(锁读完释放了)（脏读读的是未提交的数据，不可重复读读的是提交了的别的事务的值） 事务级别在reda committed以下发生（mysql通过上面的next-key lock算法避免了这样的情况，所以mysql默认的隔离级别是 read repeatable）</li><li>幻读   类似于不可重复读，但是特指插入删除数据，而不可重复读特指修改数据。没有间隙锁前，只对数据加了行锁所以导致可能发生幻读，现在mysql引入间隙锁了，就不会发生了。</li><li>丢失更新   主要是应用层面的，应用a和应用b都已经查出来数据为100，应用a通过事务a提交更新为50，应用b通过事务b更新为90，则最后为90，理论应该为40.解决方式，在其上面用for update加排他锁</li></ul><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源。</p><ul><li>参数  innodb_lock_wait_timeout 默认50秒  阻塞等待时间 ，动态，可以在mysql运行时调整<ul><li>set @@innodb_lock_wait_timeout=60;</li></ul></li><li>参数  innodb_rollback_on_timeout  设定是否在等待超时时对进行中的事务进行回滚操作（默认off，不回滚），静态，不可以在mysql运行时调整<ul><li>set @@innodb_rollback_on_timeout=on;</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>指俩个或俩个以上的事务再执行过程中，因争夺锁资源而造成的一种互相等待的现象。</p><ul><li><p>回滚，将任何等待的事务都直接回滚重新执行</p></li><li><p>超时，设置等待阈值，如上面的innodb_lock_wait_timeout</p></li><li><p>wait-for graph（等待图），采用深度优先的算法主动检测死锁，根据保存的信息生成图，如果图中存在回路，则存在死锁，选择undo量最小的事务进行回滚。需要数据库保存以下俩种信息</p><ul><li>锁的信息链表    就是哪些事务要给该行记录增加锁的列表</li><li>事务等待链表   就是按顺序加入的事务列表</li></ul></li><li><p>锁升级  sql server存储锁按行来时，存储后所占资源内存超过激活内存的40%或者一个对象上持有的锁数量超过阈值时（5000默认）,将行锁向上审计为粗颗粒度的页锁、表锁等。 而mysql不存在这个问题，因为mysql是根据页加锁，一般资源开销不会太大。</p></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>是数据库区别于文件系统的重要特性之一。事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。</p><p>innodb存储引擎中事务完全符合ACID的特性，（也就是说因为某些原因有不符合的比如NDB Cluster不满足D）</p><ul><li>原子性 （atomicity）事务是不可分割的工作单位，要么成功要么不成功</li><li>一致性（consistency）指事务将数据库从一种状态转变为下一种一致的状态。数据库的层面特指的是一致性状态，即在事务前后数据库的完整性约束没有被破坏，例如对于姓名加了个唯一约束，一个事务对姓名进行了修改，但是事务提交或回滚，发现姓名出现重复，则数据库会撤销事务，返回最初状态。**<em>（在业务端则通常认为执行前后，数据保持一致才是一致性，例如转账者和收款人的总额应该保持不变）**</em></li><li>隔离性（isolation）要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常用锁来实现</li><li>持久性（durability）事务一旦提交，其结果就是永久性的。但是事务的持久性针对的是系统的<strong>高可靠性</strong>，数据库本身如RAID卡损坏等本身故障，应该利用其它系统共同配合进行高可用性的实现</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>扁平事务（Flat Transactions）事务类型中最简单也是使用最频繁的的一种，从事务begin到commit/rollback 要么都执行要么都不执行，不存在回滚部分的能力。</li><li>带有保存点的扁平事务（Flat Transactions with Savepoints）（<strong>事务+暂存</strong>）在扁平事务的基础上添加保存点（通过savepoint my2申明记录当前状态，rollback to SAVEPOINT my 则可以回退到那里，可以记录多个保存点），记录事务执行过程中的一个处理状态，以便当之后发生错误时，事务能回到保存点当时的状态。</li><li>链事务（Chained Transacations）（<strong>事务+链表</strong>）保存点模式的一种变种，在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，将提交事务和开启下一个事务操作合并为了一个原子操作。（将一个大的事务拆成各个小的事务，然后链式结构构建成链事务）区别于保存点模式，其只针对当前事务进行回滚（将链式事务当成一个大事务来看，就是只能恢复到最近的一个保存点）</li><li>嵌套事务（Nested Transacations）（innodb不支持，可以通过保存点事务模拟串行的嵌套事务，但是并行的则无能为力）（<strong>事务+树</strong>）是一个层次框架，由一个顶层事务控制各个层次事务。顶层事务嵌套下的事务称为子事务。<ul><li>子事务可以再嵌套事务也可以就是扁平事务</li><li>事务的前驱称为父事务，下一层称为子事务</li><li>子事务可以提交或者回滚，但是他的操作不会马上生效，除非父事务已经提交。</li><li>树中的任意一事务回滚，会引起它的所有子事务一同回滚，所以子事务不具有D的特性。</li><li>父事务具有的锁可以向子事务传递锁。子事务需要父事务不具有的锁，则需要通过反向继承，让父事务持有之后再传递过来</li></ul></li><li>分布式事务（Distributed Transacations）通常是一个分布式环境下运行的扁平事务。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><p>redo</p><ul><li><p>重做日志用来实现事务的原子性和持久性，其包括俩部分：一是内存中的重做日志缓冲（redo log buffer），二是重做日志文件（redo log file）其通过Force Log at Commit机制实现事务持久性，即事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才算完成。（fsync操作：同步内存中所有已修改的文件数据到储存设备。这里就是将重做日志缓存先写入重做日志文件，再写入磁盘）</p><p>参数innodb_flush_log_at+trx_commit用来控制重做日志刷新磁盘的策略</p><ul><li>0 事务提交时不进行写入重做日志操作，这个操作仅再maste thread中完成。master thread中每1秒回进行一次重做日志文件的fsync操作</li><li>1 默认值 每次提交执行一次</li><li>2 事务提交先将重做日志缓存写入重做日志文件的文件缓存中，不进行fsync操作</li></ul></li><li><p>log block  日志块，重做日志文件和日志缓存以512个字节进行存储，即以块的方式。因为日志块的大小和磁盘扇区大小一样，都是512字节，所以可以保证写入的原子性，不需要doublewrite技术，其写入redo log file虽然都是最后部分进行写入，但是不是顺序写入</p></li><li><p>log group 重做日志组  逻辑概念，实际只有一个，由多个重做日志文件组成。</p></li><li><p>重做日志格式：redo_log_type 重做日志的类型；space 表空间的id；page_no 页的偏移量</p></li><li><p>LSN   Log Sequence Number 代表日志序列号</p></li><li><p>恢复   重做日志是物理日志，记录物理修改才做，比如 insert into t select 1,2   其记录的是page(2,3),offset 32 ,value 1,2  可以很快进行恢复</p></li></ul></li><li><p>undo</p><ul><li><p>存储在数据库内部的一个特殊段（segment）中，称为undo段，位于共享表空间内，用于数据库事务的回滚操作，其不是将数据库物理的恢复到某一个状态，而是对之前执行的DML语句进行反向操作。除了回滚，其另一个功能是实现innodb的MVCC(某行记录被事务锁定，通过undo获得之前的行版本信息，实现非锁定读)。同时，undo log的产生伴随着redo log ，因为undo log也需要持久化</p></li><li><p>undo页可以复用。当事务提交时，首先将undo log放入链表，判断undo页的使用空间是否小于3/4，若是则表示可以复用，将记录放在其后面。因此，执行purge操作时，需要涉及到磁盘的离散读操作了。</p></li><li><p><strong>undo log</strong>格式</p><ul><li>insert undo log  因为insert操作的记录，只对事务本身可见，对其他事务不可见，所以undo log提交后直接删除</li><li>update undo log  因为delete和update操作产生的undo log，因为mvcc的需要。事务提交后放入undo log链表，等待purge操作删除</li></ul></li><li><p>purge  delete和update操作可能并不直接删除原有数据，而是在主键列上的记录delete flag设为1，（update也是这么处理原逻辑），而并没有删除，任然在b+树上，有purge最终真正完成删除操作。因为要支持MVCC,不能再事务提交时立即进行处理。</p></li><li><p>group commit   一次fsync可以刷新确保多个事务日志写入文件。</p></li></ul></li><li><p>显示事务控制语句</p><ul><li>显示的开启一个事务：start  transaction |  begin    显示的开启一个事务（在存储过程中，begin会被识别成begin … end所以只能用前者）</li><li>commit | commit work   提交事务 （completion_type值为0时，俩者相同，为1时，后者等同于commit and chain 表示是链式事务，马上自动开启一个相同隔离级别的事务，为2时，commit work等同于commit and release，在事务提交后会自动断开与服务器的连接）</li><li>rollback | rollback work 回滚事务</li><li>savepoint    name  在事务中创建一个保存点</li><li>release savepoint   name  删除一个事务的保存点</li><li>rollback to  savepoint_name  将事务回滚到标记点（只是回滚到保存点，但是不是真正的回滚了事务，还需要显式的执行commit或rollback命令）</li><li>set transaction 设置事务的隔离级别</li></ul></li><li><p>隐式提交的sql语句</p><ul><li>DDL语句：ALTER DATABASE…UPGRADE DATADIRECTORY NAME，ALTER EVENT，ALTERPROCEDURE，ALTER TABLE，ALTER VIEW，CREATEDATABASE，CREATE EVENT，CREATE INDEX，CREATE PROCEDURE，CREATE TABLE，CREATETRIGGER，CREATE VIEW，DROP DATABASE，DROPEVENT，DROP INDEX，DROP PROCEDURE，DROPTABLE，DROP TRIGGER，DROP VIEW，RENAMETABLE，TRUNCATE TABLE。</li><li>用来隐式地修改MySQL架构的操作：CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SETPASSWORD。</li><li>管理语句：ANALYZE TABLE、CACHE INDEX、CHECKTABLE、LOAD INDEX INTO CACHE、OPTIMIZETABLE、REPAIR TABLE。</li></ul></li><li><p>对于事务操作的统计</p><p>显示控制事务的提交和回滚，可以通过com_commit和com_rollback进行统计</p></li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul><li><p>Read UnCommitted</p></li><li><p>Read Committed</p></li><li><p>Repeatable Read</p></li><li><p>Serializable(再innodb中因为间隙锁的存在，主要用于分布式事务)</p><p>查看当前会话的事务隔离级别:select @@tx_isolation</p></li></ul><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul><li><p>XA事务：由一个或多个资源管理器、一个事务管理器以及一个应用程序组成</p><ul><li>资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器</li><li>事务管理器：协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信</li><li>应用程序：定义事务的边界，指定全局事务中的操作</li></ul></li><li><p>分布式事务使用俩段式提交（two-phase commit）</p><ol><li>所有参与全局事务的节点都开始准备，告诉事务管理器他们准备好提交了</li><li>事务管理器告诉资源管理器执行提交或回滚</li><li>任何一个节点显示不能提交，则所有节点被告知回滚</li></ol></li><li><p>内部XA事务</p><ul><li>binlog和innodb存储引擎之间。如果二进制日志写入而redo log没有写入。则slave可能接受到master的二进制日志执行，而master本身没有，造成主从不一致</li><li>MySQL数据库在binlog与InnoDB存储引擎之间采用XA事务。当事务提交时，InnoDB存储引擎会先做一个PREPARE操作，将事务的xid写入，接着进行二进制日志的写入，如果在InnoDB存储引擎提交前，MySQL数据库宕机了，那么MySQL数据库在重启后会先检查准备的UXID事务是否已经提交，若没有，则在存储引擎层再进行一次提交操作。</li></ul></li></ul><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><h4 id="备份的分类"><a href="#备份的分类" class="headerlink" title="备份的分类"></a>备份的分类</h4><ol><li>按照备份方法不同分类<ul><li>热备 Hot BackUp 数据库运行中直接备份。官方称之为Online Backup 在线备份</li><li>冷备 Cold BackUp 数据库停止的情况下备份，一般只需要复制相关数据库物理文件即可。官方称其为Offline Backup 离线备份（只需要备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件（*.ibd），重做日志文件。另外建议定期备份MySQL数据库的配置文件my.cnf，这样有利于恢复的操作。）</li><li>温备 Warm BackUp 在数据库运行中进行，但是会对当前数据库的操作有影响，如加一个全局读锁一保证备份数据额一致性</li></ul></li><li>按照备份后文件内容分类<ul><li>逻辑备份 指备份出的文件可读。内容由一条条sql语句，或者表实际数据组成。优点是可以观察导出文件的内容，适用于数据库迁移升级工作。缺点是恢复所需要的时间往往很长</li><li>裸文件备份 指复制数据库的物理文件，既可以是在数据库运行中的复制，也可以是在数据库停止运行时直接的数据文件复制。这类备份，往往恢复时间较逻辑备份短很多</li></ul></li><li>按照备份数据库的内容来分<ul><li>完全备份 指对数据库进行一个完整的备份。</li><li>增量备份 在上次完全备份的基础上，对更改的数据进行备份。</li><li>日志备份 指Mysql数据库二进制日志的备份，通过对一个完全备份进行二进制日志的重做来完成数据库的point-in-time的恢复工作。MySQL数据库复制（replication）的原理就是异步实时地将二进制日志重做传送并应用到从（slave/standby）数据库。</li></ul></li></ol><ul><li><p>快照备份   主要是利用文件的快照，备份数据库文件。</p></li><li><p>复制 （replication） 其实就是一个完全备份加上二进制日志备份的还原，主要用来建立高可用架构的主从复制（复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时）</p><ul><li>主服务器  把数据更改记录到二进制日志中</li><li>从服务器  把主服务器的二进制日志复制到自己的中继日志中</li><li>从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。</li></ul></li><li><p>复制的主要功能</p><ul><li>数据分布：由于MySQL数据库提供的复制并不需要很大的带宽要求，因此可以在不同的数据中心之间实现数据的复制。</li><li>读取的负载平衡：通过建立多个从服务器，可将读取平均地分布到这些从服务器中，并且减少了主服务器的压力。一般通过DNS的Round-Robin和Linux的LVS功能都可以实现负载平衡。</li><li>数据库备份：复制对备份很有帮助，但是从服务器不是备份，不能完全代替备份。</li><li>高可用性和故障转移:通过复制建立的从服务器有助于故障转移，减少故障的停机时间和恢复时间。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;Mysql的深入点了解，主要建立在《MySQL技术内幕：Innodb存储引擎（第二版）》的基础上，记录的知识点和一些自己验证后发现的自己的个人感觉书里表述不清的地方，当然，笔者是java后端的开发，一些比较偏DBA的地方有进行略过。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://zhhw137.github.io/categories/Mysql/"/>
    
    
    <category term="mysql" scheme="https://zhhw137.github.io/tags/mysql/"/>
    
    <category term="数据库" scheme="https://zhhw137.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>流水线</title>
    <link href="https://zhhw137.github.io/2020/08/26/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>https://zhhw137.github.io/2020/08/26/%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2020-09-08T01:03:21.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>对，你没看错，这篇的主要内容是流水线，IT工人也是工人，流水线加快速度自然是一个更加方便资本主义压榨的好方法了。<img src="/images/%E6%90%9E%E7%AC%91%E7%8B%97%E5%A4%B4%E8%84%B8.jpg" alt="git"></p><a id="more"></a><p>上篇文章，说了一堆关于rancher和k8s的基本概念和知识，其实小编自己也没有弄懂。成本有限的情况下，蹭了一台别人的机器上的虚拟机(配置还是很高的,双核,64G,1T)尝试着搭建了下k8s，照着命令倒是把master和node搭建在这一台机器上成功了，但是rancher成功之后，因为不可抗力最后没有看到实际效果。暂时就放弃了<img src="/images/%E6%8D%82%E8%84%B8%E7%AC%91.jpg" alt="git"></p><p>言归正传。</p><p>所谓流水线，指的是rancher上的流水线，即自动从gitlab上读取代码，打包，构建镜像，部署、启动程序一气呵成的流水线。下面让我们来看下具体流程</p><p>1、harbor镜像仓库安装</p><p>rancher的资源镜像库中添加</p><p>2、流水线配置</p><p>rancher的可视化平台上，工具上进行流水线配置。这里会绑定代码库等配置</p><p>3、实际项目文件书写</p><p>上面俩步，公司的大佬完成后我因为权限不足，也就是结合着其他博客等知识大概看了看，没有实际上手经验就不多说了<img src="/images/%E8%AF%B4%E4%B8%8D%E5%87%BA%E8%AF%9D.jpg" alt="git"></p><p>但是，说道给项目编写配置文件触发流水线<img src="/images/%E4%B8%8D%E5%9B%B0%E4%BA%86.jpg" alt="git"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="rancher-pipeline-yml"><a href="#rancher-pipeline-yml" class="headerlink" title=".rancher-pipeline.yml"></a>.rancher-pipeline.yml</h4><p>​    该配置文件即为流水线的主要配置文件，也是正常看到的流水线clone、build、publish、deploy四步的原因<img src="/images/%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%97%A5%E5%BF%97.png" alt="git"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">runScriptConfig:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">maven:3.6.0-jdk-8-alpine</span></span><br><span class="line">      <span class="attr">shellScript:</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="string">package</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">push-image</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">publishImageConfig:</span></span><br><span class="line">      <span class="attr">dockerfilePath:</span> <span class="string">./Dockerfile</span></span><br><span class="line">      <span class="attr">buildContext:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">tag:</span> <span class="string">scc/hyperloop-baseapi:$&#123;CICD_EXECUTION_SEQUENCE&#125;</span></span><br><span class="line">      <span class="attr">pushRemote:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">registry:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">applyYamlConfig:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">./deployment.yaml</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><ul><li>该配置文件一定要写在项目的根目录下</li><li>clone 根据上面配置的代码库和流水线配置直接去拉取代码，无须写</li><li>bulid mavn命令进行代码打包</li><li>publish  <ul><li>根据dockerfilepath中对应的dockerfile文件读取对应的docker命令发布镜像</li><li>tag本次镜像仓库的地址 scc/hyperloop-baseapi 这里应该为你的镜像仓库地址</li></ul></li><li>deploy  path对应的是部署镜像的文件地址</li></ul><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM    xx&#x2F;system&#x2F;openjdk:8-jdk-alpine</span><br><span class="line">ADD        xx.jar  &#x2F;app.jar</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><ul><li>FROM  指定基础镜像路径</li><li>ADD  生成的jar包名称和打包项目路径</li><li>ENTRYPOINT 运行项目 -D 是新增参数，参数的名字叫 java.security.egd ，参数的值叫 file:/dev/./urandom，是为了解决随机数生成的问题(看解释是因为jdk的一个bug导致,指定随机数生成可以优化性能，在一定程度上加快程序启动)<img src="/images/%E6%90%9E%E7%AC%91%E7%8B%97%E5%A4%B4%E8%84%B8.jpg" alt="git">)</li></ul><h4 id="deployment-yaml"><a href="#deployment-yaml" class="headerlink" title="deployment.yaml"></a>deployment.yaml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  <span class="comment"># 指定api版本，此值必须在kubectl api-versions中  </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  <span class="comment"># 指定创建资源的角色/类型   </span></span><br><span class="line"><span class="attr">metadata:</span>  <span class="comment"># 资源的元数据/属性 </span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo</span>  <span class="comment"># 资源的名字，在同一个namespace中必须唯一</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 部署在哪个namespace中</span></span><br><span class="line">  <span class="attr">labels:</span>  <span class="comment"># 设定资源的标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 资源规范字段</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 声明副本数目</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 匹配标签</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 示在更新过程中能够进入不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模版</span></span><br><span class="line">    <span class="attr">metadata:</span> <span class="comment"># 资源的元数据/属性 </span></span><br><span class="line">      <span class="attr">annotations:</span> <span class="comment"># 自定义注解列表</span></span><br><span class="line">        <span class="attr">sidecar.istio.io/inject:</span> <span class="string">&quot;false&quot;</span> <span class="comment"># 自定义注解名字</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># 设定资源的标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line">    <span class="attr">spec:</span> <span class="comment"># 资源规范字段</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span> <span class="comment"># 容器的名字   </span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">demo:v1</span> <span class="comment"># 容器使用的镜像地址   </span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 每次Pod启动拉取镜像策略，三个选择 Always、Never、IfNotPresent</span></span><br><span class="line">                                      <span class="comment"># Always，每次都检查；Never，每次都不检查（不管本地是否有）；IfNotPresent，如果本地有就不检查，如果没有就拉取 </span></span><br><span class="line">        <span class="attr">resources:</span> <span class="comment"># 资源管理</span></span><br><span class="line">          <span class="attr">limits:</span> <span class="comment"># 最大使用</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">300m</span> <span class="comment"># CPU，1核心 = 1000m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">500Mi</span> <span class="comment"># 内存，1G = 1000Mi</span></span><br><span class="line">          <span class="attr">requests:</span>  <span class="comment"># 容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">livenessProbe:</span> <span class="comment"># pod 内部健康检查的设置</span></span><br><span class="line">          <span class="attr">httpGet:</span> <span class="comment"># 通过httpget检查健康，返回200-399之间，则认为容器正常</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/healthCheck</span> <span class="comment"># URI地址</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment"># 协议</span></span><br><span class="line">            <span class="comment"># host: 127.0.0.1 # 主机地址</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span> <span class="comment"># 表明第一次检测在容器启动后多长时间后开始</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span> <span class="comment"># 检测的超时时间</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">30</span> <span class="comment"># 检查间隔时间</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span> <span class="comment"># 成功门槛</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span> <span class="comment"># 失败门槛，连接失败5次，pod杀掉，重启一个新的pod</span></span><br><span class="line">        <span class="attr">readinessProbe:</span> <span class="comment"># Pod 准备服务健康检查设置</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/healthCheck</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment">#也可以用这种方法   </span></span><br><span class="line">        <span class="comment">#exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常   </span></span><br><span class="line">        <span class="comment">#  command:   </span></span><br><span class="line">        <span class="comment">#    - cat   </span></span><br><span class="line">        <span class="comment">#    - /tmp/health   </span></span><br><span class="line">        <span class="comment">#也可以用这种方法   </span></span><br><span class="line">        <span class="comment">#tcpSocket: # 通过tcpSocket检查健康  </span></span><br><span class="line">        <span class="comment">#  port: number </span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 名称</span></span><br><span class="line">            <span class="attr">containerPort:</span> <span class="number">8080</span> <span class="comment"># 容器开发对外的端口 </span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 协议</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span> <span class="comment"># 镜像仓库拉取密钥</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">harbor-certification</span></span><br><span class="line">      <span class="attr">affinity:</span> <span class="comment"># 亲和性调试</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span> <span class="comment"># 节点亲和力</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># pod 必须部署到满足条件的节点上</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span> <span class="comment"># 节点满足任何一个条件就可以</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">matchExpressions:</span> <span class="comment"># 有多个选项，则只有同时满足这些逻辑选项的节点才能运行 pod</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">beta.kubernetes.io/arch</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">amd64</span></span><br></pre></td></tr></table></figure><p>参考链接</p><ul><li>[k8s官方英文] (<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/%EF%BC%89">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/）</a></li><li>[中文介绍] (<a href="https://feisky.gitbooks.io/kubernetes/content/concepts/deployment.html%EF%BC%89">https://feisky.gitbooks.io/kubernetes/content/concepts/deployment.html）</a></li><li>[博客] (<a href="https://draveness.me/kubernetes-deployment/%EF%BC%89">https://draveness.me/kubernetes-deployment/）</a></li></ul><p>以上就是我目前对流水线的初步认识了，后续了解加深会再补充一篇文章。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;流水线&quot;&gt;&lt;a href=&quot;#流水线&quot; class=&quot;headerlink&quot; title=&quot;流水线&quot;&gt;&lt;/a&gt;流水线&lt;/h2&gt;&lt;p&gt;对，你没看错，这篇的主要内容是流水线，IT工人也是工人，流水线加快速度自然是一个更加方便资本主义压榨的好方法了。&lt;img src=&quot;/images/%E6%90%9E%E7%AC%91%E7%8B%97%E5%A4%B4%E8%84%B8.jpg&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="容器" scheme="https://zhhw137.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="rancher" scheme="https://zhhw137.github.io/tags/rancher/"/>
    
    <category term="k8s" scheme="https://zhhw137.github.io/tags/k8s/"/>
    
    <category term="流水线" scheme="https://zhhw137.github.io/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Rancher+k8s初识</title>
    <link href="https://zhhw137.github.io/2020/08/25/Rancher+k8s%E5%88%9D%E5%A7%8B/"/>
    <id>https://zhhw137.github.io/2020/08/25/Rancher+k8s%E5%88%9D%E5%A7%8B/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-09-08T01:03:07.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rancher-k8s初识"><a href="#Rancher-k8s初识" class="headerlink" title="Rancher+k8s初识"></a>Rancher+k8s初识</h2><p>8月13号，Docker公司的最新服务条款中明确指出：禁止美国“实体清单”上的实体使用(其中包括华为、奇虎360、科大讯飞等中国IT公司)。让这一时下最流行的容器管理技术，又实实在在的火了一波。所以，今天让我们来看看它的替代品之二：rancher+k8s。(主要笔者还不会docker)<img src="/images/%E6%8D%82%E8%84%B8%E7%AC%91.jpg" alt="git"></p><a id="more"></a><h3 id="存在即合理"><a href="#存在即合理" class="headerlink" title="存在即合理"></a>存在即合理</h3><p>1、容器技术的兴起：虚拟机是在容器技术大行其道之前，开发和运维成员的主流技术。但是其高昂的移植成本、启动慢和占用空间大等问题，为以docker为代表的容器管理技术的兴起埋下伏笔。所谓容器化，就是放弃虚拟机虚拟整个操作系统，而是只虚拟一个小规模的环境即可。</p><p>2、微服务：为了满足业务发展而导致的用户量增多，系统数量增多和互相之间调用的依赖关系的赋值，确保系统的高可用、高并发要求，系统的架构慢慢从单机时代迁移到服务SOA时代。应运而生的就是大量的系统和容器使用。于是，一个管理所有容器的技术架构或者说工具迫在眉睫。而k8s的问世，就是提出的一套全新的基于容器技术的分布式架构领先方案。</p><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>k8s全称kubernetes，为了应对微服务而兴起的分布式架构，既然是分布式，则必然有着集群的部署条件。</p><p>k8s集群由master节点和Node节点组成，</p><p><strong>Master节点</strong></p><p>master节点是集群的控制节点，管理和控制整个集群，它负责具体的执行过程，其上运行着：</p><ol><li>Kubernetes Controller Manager（kube-controller-manager）：k8s中所有资源对象的自动化控制中心，维护管理集群的状态，比如故障检测，自动扩展，滚动更新等。</li><li>Kubernetes Scheduler（kube-scheduler）： 负责资源调度，按照预定的调度策略将Pod调度到相应的机器上。</li><li>etcd：保存整个集群的状态。</li></ol><p><strong>Node节点</strong></p><p>除了master以外的节点被称为Node或者Worker节点，可以在master中使用命令 <code>kubectl get nodes</code>查看集群中的node节点。每个Node都会被Master分配一些工作负载（Docker容器），当某个Node宕机时，该节点上的工作负载就会被Master自动转移到其它节点上。在Node上主要运行着：</p><ol><li>kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，实现集群管理的基本功能</li><li>kube-proxy：实现service的通信与负载均衡</li><li>docker（Docker Engine）：Docker引擎，负责本机的容器创建和管理</li></ol><h3 id="rancher"><a href="#rancher" class="headerlink" title="rancher"></a>rancher</h3><p>技术领域，从来不会形成一家独大的情况，一项技术总会有其优缺点，也总会出现某些地方更具有优势的其他技术进行替代。所以早期的rancher的V1版本作为开源的企业级容器管理工具，其上有多种容器编排模式，例如cattle ,swarm,kubernetes。但随着，k8s势不可挡的逐渐成为主流，rancher应运而生的v2版本，则只保留了k8s的部分。</p><p>rancher，本质上可以看成是k8s更上层的管理框架，除了更加友好的界面和操作，同时，也在k8s的基础上，扩展了一些其不具有的功能如权限管理，日志收集。(详细可以看[知乎]（<a href="https://www.zhihu.com/question/309076492/answer/1150097420">https://www.zhihu.com/question/309076492/answer/1150097420</a>))</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Rancher-k8s初识&quot;&gt;&lt;a href=&quot;#Rancher-k8s初识&quot; class=&quot;headerlink&quot; title=&quot;Rancher+k8s初识&quot;&gt;&lt;/a&gt;Rancher+k8s初识&lt;/h2&gt;&lt;p&gt;8月13号，Docker公司的最新服务条款中明确指出：禁止美国“实体清单”上的实体使用(其中包括华为、奇虎360、科大讯飞等中国IT公司)。让这一时下最流行的容器管理技术，又实实在在的火了一波。所以，今天让我们来看看它的替代品之二：rancher+k8s。(主要笔者还不会docker)&lt;img src=&quot;/images/%E6%8D%82%E8%84%B8%E7%AC%91.jpg&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="容器" scheme="https://zhhw137.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="rancher" scheme="https://zhhw137.github.io/tags/rancher/"/>
    
    <category term="k8s" scheme="https://zhhw137.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>git常用指令总结</title>
    <link href="https://zhhw137.github.io/2020/08/23/git%E6%8C%87%E4%BB%A4/"/>
    <id>https://zhhw137.github.io/2020/08/23/git%E6%8C%87%E4%BB%A4/</id>
    <published>2020-08-23T11:09:39.507Z</published>
    <updated>2020-09-08T01:04:55.569Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/git.png" alt="git"></p><p>在这里记录一些常用的<code>git</code>指令，以及使用时碰到的一些问题及相应的解决办法。</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git init [local repository]</span><br></pre></td></tr></table></figure><h2 id="克隆到本地"><a href="#克隆到本地" class="headerlink" title="克隆到本地"></a>克隆到本地</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure><h2 id="添加变化至暂存区-index"><a href="#添加变化至暂存区-index" class="headerlink" title="添加变化至暂存区(index)"></a>添加变化至暂存区(index)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add *</span><br><span class="line">git commit -m &quot;&lt;commit message&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送到指定的远程分支</span></span><br><span class="line">git push oringin &lt;master&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定远程分支并推送</span></span><br><span class="line">git romete add origin &lt;master&gt;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="分支-branch-相关"><a href="#分支-branch-相关" class="headerlink" title="分支(branch)相关"></a>分支(branch)相关</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git branch # 查看本地分支</span><br><span class="line">git branch -r # 查看远程分支</span><br><span class="line">git branch -a # 查看所有分支</span><br><span class="line"></span><br><span class="line">git checkout -b &lt;dev&gt; # 创建本地分支</span><br><span class="line">git checkout &lt;dev&gt; # 切换到本地分支（没有会根据远程分支创建本地分支）</span><br><span class="line"></span><br><span class="line">git branch -d &lt;dev&gt; # 删除本地分支</span><br><span class="line">git push origin -d &lt;remote_dev&gt; # 删除远程分支</span><br><span class="line"></span><br><span class="line">git push origin &lt;dev&gt; # 推送到远程分支，没有会自动创建</span><br><span class="line"></span><br><span class="line">git checkout [branch name] # 切换分支</span><br></pre></td></tr></table></figure><h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git fetch [origin]</span><br></pre></td></tr></table></figure><h2 id="缓存-stash-相关"><a href="#缓存-stash-相关" class="headerlink" title="缓存(stash)相关"></a>缓存(stash)相关</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br><span class="line">git stash save &#x27;&lt;stash name&gt;&#x27;</span><br><span class="line">git stash show</span><br><span class="line">git stash show -p</span><br><span class="line">git stash apply [@&#123;num&#125;]</span><br><span class="line">git stash pop [@&#123;num&#125;]</span><br><span class="line">git stash drop</span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h2 id="状态-status"><a href="#状态-status" class="headerlink" title="状态(status)"></a>状态(status)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/git.png&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这里记录一些常用的&lt;code&gt;git&lt;/code&gt;指令，以及使用时碰到的一些问题及相应的解决办法。&lt;/p&gt;</summary>
    
    
    
    <category term="杂" scheme="https://zhhw137.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="git" scheme="https://zhhw137.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用规则</title>
    <link href="https://zhhw137.github.io/2020/08/21/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/"/>
    <id>https://zhhw137.github.io/2020/08/21/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/</id>
    <published>2020-08-20T16:00:00.000Z</published>
    <updated>2020-08-22T05:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo使用说明。</p><blockquote><p>更多说明请参考：<a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></p></blockquote><a id="more"></a><h2 id="开启本地服务器"><a href="#开启本地服务器" class="headerlink" title="开启本地服务器"></a>开启本地服务器</h2><p>如果想在本地预览效果，在文件根目录使用<code>git</code>指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s #默认端口4000</span><br><span class="line">hexo s -p 8080 #修改端口号为8080(比如端口被占用的时候)</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:4000/">http://localhost:4000/</a>。</p><p>关闭服务器：<code>Ctrl + C</code>.</p><h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><p>如果你的文段没有正常显示，说明没有解析为静态文件（<code>html</code>），这个时候需要手动解析：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #解析静态文件</span><br><span class="line">hexo generate --deploy #解析并自动部署</span><br><span class="line">hexo g --d #简写形式1</span><br><span class="line">hexo d --g #简写形式2</span><br></pre></td></tr></table></figure><h2 id="一件部署"><a href="#一件部署" class="headerlink" title="一件部署"></a>一件部署</h2><p>在执行部署(提交到<code>github</code>或其他站点)指令前，需要设置根目录配置文件<code>_config.yml</code>：找到<code>deploy</code>字段，修改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/fongzhizhi/fongzhizhi.github.io</span> <span class="comment">#改为你的github仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment">#该仓库的默认分支</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">hexo一键部署</span> <span class="comment">#提交信息</span></span><br></pre></td></tr></table></figure><p>然后执行一件部署指令：<strong>可以选择一下指令之一</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy #清除一些缓存并部署到远程</span><br><span class="line">hexo g --d #解析并部署</span><br></pre></td></tr></table></figure><p>然后过几秒钟，刷新你的站点就能看到效果啦！</p><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>文章都放在<code>source\</code>目录的其他下（根据不同类型放置）。写完记得静态解析，然后再部署。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo使用说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更多说明请参考：&lt;a href=&quot;https://hexo.io/zh-cn/docs&quot;&gt;https://hexo.io/zh-cn/docs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂" scheme="https://zhhw137.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="Hexo" scheme="https://zhhw137.github.io/tags/Hexo/"/>
    
    <category term="说明" scheme="https://zhhw137.github.io/tags/%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
</feed>
