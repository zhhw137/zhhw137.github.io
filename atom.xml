<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhhw的Blog</title>
  
  <subtitle>记录java学习成长</subtitle>
  <link href="https://zhhw137.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhhw137.github.io/"/>
  <updated>2020-09-23T01:35:07.785Z</updated>
  <id>https://zhhw137.github.io/</id>
  
  <author>
    <name>zhhw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM</title>
    <link href="https://zhhw137.github.io/2020/09/14/JVM%E7%AF%87/"/>
    <id>https://zhhw137.github.io/2020/09/14/JVM%E7%AF%87/</id>
    <published>2020-09-14T12:30:00.000Z</published>
    <updated>2020-09-23T01:35:07.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Jvm篇根据《深入理解Java虚拟机:JVM高级特性与最佳实践（第三版）》，加上笔者自己的验证理解所做。</p><a id="more"></a><h2 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h2><h3 id="1、JVM内存区域"><a href="#1、JVM内存区域" class="headerlink" title="1、JVM内存区域"></a>1、JVM内存区域</h3><p><img src="/images/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JVM内存模型"></p><ul><li><p>程序计数器  </p><ul><li>是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>每个线程都有一个自己的程序计数器，属于线程私有</li><li>唯一一个不会发生OutOfMemoryError情况的区域</li></ul></li><li><p>Java虚拟机栈（-Xss 128k）</p><ul><li>线程私有，生命周期和线程相同</li><li>每个方法被执行时，jvm会同步创建一个用于存储局部变量表、操作数栈、动态连接、方法出口等信息的栈帧，其入栈到出栈过程即对应着一个方法从被调用到执行完毕的过程。<ul><li>局部变量表：存放了编译器可知的参数类型：java的8大基本类型、对象引用（可能是引用指针或者相关地址）和returnAddress类型（指向了一条字节码指令的地址）。用局部变量槽slot表示局部变量表的存储空间。（long和double64位的这俩个用俩个变量槽，其他一个）</li></ul></li><li>进入方法时，栈帧的分配多大的局部变量空间就完全确定了，方法运行期间不会改变局部变量表的变量槽数量。</li><li>虚拟机栈存在俩种异常<ul><li>Stack Overflow Error 线程请求的栈深度大于虚拟机所允许的深度（深度可以理解成数量）</li><li>OutOfMemory Error 如果虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存（HotSpot不可动态扩展，该异常只会发生在线程一开始申请时）</li></ul></li></ul></li><li><p>本地方法栈  与虚拟机栈类型，只不过本地方法栈调用本地方法即native方法。（所谓native方法，就是可能并非用java实现的底层方法）</p></li><li><p>java堆（又称为GC堆，是垃圾收集器管理的内存区域）</p><ul><li>虚拟机管理内存中最大的一块。</li><li>被所有线程共享的内存区域</li><li><strong>对象实例信息</strong>，几乎所有的对象实例和数组都应当在堆上分配（随着java的发展，可能存在不在上面的对象）</li><li>堆的大小可以是固定大小，也可以使可扩展的（基本都是可扩展的），如果没有内存完成实例分配，又不能继续扩展，抛出OutOfMemoryError异常</li></ul></li><li><p>方法区（java虚拟机的规范，HotSpot在jdk1.8之前用永久代实现，之后用元空间）</p><ul><li><strong>对象类型信息</strong>，各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li><li>JDK1.8前HotSpot用永久代实现方法区原因：省去专门为方法区编写内存管理的工作。（永久代在堆上浪费堆内存）</li><li>JDK1.8后HotSpot用元空间实现方法区：避免了永久代实现的容易内存溢出的问题（永久代有-xx：MaxPermSize的上限，即使不设置也有默认大小）元空间使用本地内存实现，不容易内存溢出</li><li>不需要连续内存，可以选择固定大小或者可扩展。这区域的回收目标主要针对常量池的回收和对类型的卸载，内存回收效果难令人满意尤其是类型的卸载（<a href="https://blog.csdn.net/skzxyzj/article/details/82841061">CSDN博客</a>），条件相当苛刻，但是又是必须的。</li></ul></li><li><p>运行时常量池（方法区的一部分）</p><ul><li>用于存放编译期生成的各种字面量与符号引用</li><li>受限于方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常</li></ul></li><li><p>直接内存</p><ul><li><p>并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p></li><li><p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p></li><li><p>受到本机总内存大小和处理器寻址空间的限制。其他区域动态扩展或者本身动态扩展时大于物理内存限制，出现OutOfMemoryError异常</p></li></ul></li></ul><h3 id="2、对象"><a href="#2、对象" class="headerlink" title="2、对象"></a>2、对象</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p>指针碰撞  假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离</p></li><li><p>空闲列表  但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</p></li><li><p>对象并发创建：</p><ul><li>采用CAS配上失败重试的方式保证更新操作的原子性</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</li></ul></li><li><p>对象头创建</p><ul><li>用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li><li>类型指针 即对象指向它的类型元数据的指针 Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li></ul></li><li><p>执行构造函数方法，给字段赋默认值。完成构造</p></li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。</p><ul><li>句柄    如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息（优点   reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。）</li><li>直接指针   Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销（优点，速度更快，节省了一次指针定位的时间开销）</li></ul><h3 id="3、垃圾收集器与内存分配策略"><a href="#3、垃圾收集器与内存分配策略" class="headerlink" title="3、垃圾收集器与内存分配策略"></a>3、垃圾收集器与内存分配策略</h3><h4 id="确定对象生死"><a href="#确定对象生死" class="headerlink" title="确定对象生死"></a>确定对象生死</h4><ul><li><p>引用计数法  占用额外内存空间进行计数，在对象中添加一个引用计数器，每有一个引用则加一，引用失效则减一，计数器为0则表示不可能再被使用。<strong>优点</strong>：原理简单，判定效率很高。<strong>缺点</strong>：需要配合大量额外处理才能保证正确的工作（比如循环引用就无法计数器为0，释放回收对象，但实际不算使用）</p></li><li><p>可达性算法    通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p>GC Roots的对象包括以下几种</p><ul><li>虚拟机栈中引用的对象  比如各个线程被调用方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象</li><li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li><li>本地方法栈中JNI引用的对象（也就是native方法引用的对象）</li><li>java虚拟机内部的引用：如基本数据类型对应的class对象，一些常驻的异常对象（NullPointException，OutOfMemoryError）等，还有，系统类加载器</li><li>所有被同步锁（synchronized关键字）持有的对象 </li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul></li><li><p>引用类型分类</p><ul><li>强引用  指在程序代码之中普遍存在的引用赋值，即类似Object obj=newObject()   只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</li><li>软引用：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，会在即将内存溢出时，先将这些对象列进回收列表中，进行第二次回收，如果还不够才抛出异常</li><li>弱引用：用来描述那些非必须对象，他的引用强度比软引用更弱。被弱引用关联的对象，在下一次垃圾收集发生则无论内存是否足够都进行回收</li><li>虚引用：最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</li></ul></li><li><p>对象的自我救赎    finalize()  （现在已经放弃，最好别用了）</p></li><li><p>方法区的回收</p><ul><li>废弃的常量回收   常量池中其他类(接口)、方法、字符的符号引用、常量，虚拟机判断没有对其的引用，就会清理出常量池</li><li>不再使用的类型回收   需要满足下面的3个条件<ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul></li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li><p>分代收集理论</p><ul><li><p>弱分代假说：绝大数对象都是朝生夕灭的（诞生新生代）</p></li><li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡（诞生老生代）</p></li><li><p>跨代引用假说：跨代引用相对于同代引用来说仅占极少数（新生代上诞生了记忆集：把老年代划分成若干小块，标识出老年代哪一块内存会存在跨代引用。这样发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描，虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。）</p></li></ul></li><li><p>收集分类</p><ul><li><p>部分收集（Partial GC）指不是完整收集整个Java堆的垃圾收集</p><ul><li><p>新生代收集（Minor GC/Young GC） 指目标只是新生代的垃圾收集</p></li><li><p>老年代收集（Major GC/Old GC）指目标只是老年代的垃圾收集（目前只有CMS收集器会有单独）</p></li><li><p>混合收集（Mixed GC）指目标是收集整个新生代以及部分老年代的垃圾收集（目前只有G1收集器会有这种行为）</p><ul><li>整堆收集（Full GC） 收集整个JAVA堆和方法区的垃圾收集</li></ul></li></ul></li></ul></li><li><p>收集算法</p><ul><li>标记-清除算法   <ul><li>标记阶段：标记要回收或者要存活的对象</li><li>清除阶段：回收标记回收的对象，或者回收标记了存活对象之外未被标记的对象</li><li>缺点：执行效率不稳定，每次要回收的对象数量不确定。内存空间的碎片化问题</li></ul></li><li>标记-复制算法<ul><li>采用半区复制的算法。将内存空间分割成大小相等的俩部分，每次只使用其中一块，当某一块内存用完，将还存活的对象复制到另一块中，这一块的内存空间直接一次清理掉。</li><li>缺点：空间浪费严重</li></ul></li><li>标记-整理算法<ul><li>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</li><li>缺点：移动存活对象，如果是老年代这种，每次都有大量对象存活区域，则会是一个极为负重的操作。而且会导致“Stop The World”：对象移动操作必须全程暂停用户应用程序才能进行。</li></ul></li></ul></li><li><p>HoSpot算法细节实现</p><ul><li>根节点枚举  使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在<strong>特定的位置</strong>记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找（待验证）</li><li>安全点 上述的特殊的位置即为安全点，选取标准为“是否具有让程序长时间执行的特征”，用户程序必须在安全点才能够暂停，这样不需要每一条指令都生成对应的OopMap<ul><li>抢先式中断  （淘汰）垃圾收集发生时，中断所有用户线程，如果发现有用户线程中断的地方不在安全点，则恢复这条线程，一会再重新中断，直到跑到最近安全点上。</li><li>主动式中断  当垃圾收集需要中断线程时，仅仅简单的设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己再最近的安全点上主动中断挂起。轮询标志的地方和安全点重合，再加上所有创建对象和其他需要再java堆上分配内存的地方，这是为了检测是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li></ul></li></ul></li><li><p>安全区域  指能够确保在某一段代码片段之中，引用关系不会发生变化。因此，在这个区域中任意地方开始垃圾收集都是安全的（存在sleep或者blocked状态的线程，无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂机自己，虚拟机也不可能持续等待线程重新被激活分配处理器时间）   实际使用就是，线程执行进入安全区域时标识自己进入了安全区域。当线程要离开时，要检查虚拟机是否已经完成了类似于根节点枚举这样的暂停用户线程阶段，完成了继续执行，没有则等待完成信号。</p></li><li><p>记忆集与卡表</p><ul><li>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</li><li>卡表是记忆集的一种实现方式，HotSpot采用字节数组的方式，其中每一个元素对应着其标识的内存区域中一块特定大小的内存块，称之为卡页。一个卡页内通常包含不只一个对象。当存在跨代指针时，卡表的数组元素即卡页标识为1，称这个元素变脏，当垃圾收集发生时，就取出变脏的卡页，加入GC Roots中一并扫描。</li></ul></li><li><p>写屏障</p><ul><li>将卡表元素变脏的方式。用Aop通知的形式。</li><li>更新时的<strong>伪共享问题</strong>，参数-XX：+UseCondCardMark控制是否在更新卡表的时候，增加一个条件判断。如果当前要更新的缓存行已经被标记为变脏则不在去更新。</li></ul></li><li><p>并发的可达性分析</p><ul><li>采用三色标记，作为工具辅助推到，把遍历对象图过程中遇到的对象，按照“是否访问过”标记成三种颜色<ul><li>白色 表示对象尚未被垃圾收集器访问过。</li><li>黑色 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。</li><li>灰色 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li></ul></li><li>对象消失问题<ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；采用增量更新解决：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。采用原始快照解决:当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</li></ul></li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li><p>Serial收集器 新生代收集器   标记整理算法 单线程工作的收集器，HotSpot默认的新生代收集器</p><ul><li>进行垃圾收集时，必须暂停其他所有工作线程（stop the world）</li><li>优点：简单高效，额外内存消耗最小，对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</li></ul></li><li><p>ParNew收集器  新生代收集器 标记整理算法  支持多线程并行收集，其他与Serial收集器相比并没有太多创新之处。另外主要是因为除了Serial只有它能和CMS配合使用</p></li><li><p>Parallel Scavenge收集器  新生代收集器  基于标记-复制算法 ，该收集器的目标是达到一个可控制的吞吐量（运行用户代码时间/（运行用户代码时间+运行垃圾收集时间））</p><ul><li>-XX：MaxGCPauseMillis参数 控制最大垃圾收集停顿时间</li><li>-XX：GCTimeRatio参数 直接设置吞吐量大小</li><li>-XX：+UseAdaptiveSizePolicy  启动开关，启动后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</li></ul></li><li><p>Serial Old收集器   老年代收集器   标记整理算法   单线程   Serial的老年代版本</p></li><li><p>Parallel Old收集器   老年代收集器  标记复制算法  多线程  Parallel Scavenge老年代版本</p></li><li><p>CMS收集器  标记清除算法实现，老年代收集器   该收集器是一种以获取最短回收停顿时间为目标的收集器</p><ul><li>初始标记  标记GC Roots直接关联对象   stop the world</li><li>并发标记   初始标记的直接关联对象，开始遍历整个对象图的过程。    可以与用户线程并发运行  </li><li>重新标记   修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比初始标记稍长，远短于并发标记） stop the world</li><li>并发清除 清理删除掉标记阶段判断已经死亡对象   与用户线程同时并发。</li><li>缺点<ul><li>与用户并行时会占用一部分线程导致运行速度变慢</li><li>浮动垃圾：在并发标记和并发清除阶段产生的垃圾对象。所以，CMS需要再运行期间预留内存空间，而当预留的内存无法满足程序分配新对象的需要时，出现一次“并发失败”。这时候虚拟机采用备案，使用Serial Old收集器进行老年代的垃圾收集，stop the world</li><li>内存空间碎片 标记清除算法产生的内存空间碎片，在无法找到足够大的连续空间来分配当前对象时，触发full GC  stop the world</li><li>参数-XX：CMSInitiatingOccu-pancyFraction 可以设置CMS的触发百分比</li></ul></li></ul></li><li><p>Garbage First收集器</p><ul><li>面向整个堆内存任何部分来组成回收集（Mixed GC）</li><li>将堆内存划分为大小相等的独立区域Region。每个独立区域可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间，<strong>针对不同的Region采用不同的策略处理</strong></li><li>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。而对于超过了整个Region容量的超级大对象，采用N个连续的Humongous Region存储。</li><li>参数-XX：G1HeapRegionSize 设定Region大小</li><li>参数-XX：MaxGCPauseMillis（默认值200ms）设定允许的收集停顿时间</li><li>初始标记   标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值</li><li>并发标记  从GC Roots中开始对堆中对象进行可达性分析  可以用户程序并发执行。  重新处理SATB记录下的并发是有引用变动的对象</li><li>最终标记  stop the world 处理并发阶段结束后遗留下来的那些少量SATB记录</li><li>筛选回收  负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li><li>缺点<ul><li>G1的记忆集在存储结构的本质是一种哈希表。由于每一个Region都维护有自己的记忆集，内存占用更大（一般要到java堆容量的10%到20%）</li><li>G1通过原始快照算法（SATB）实现重新标记  程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围</li><li>G1收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。换句话说，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</li></ul></li></ul></li><li><p>Shenandoah收集器  G1的下一代升级版</p><ul><li>改进：<ul><li>支持并发整理</li><li>默认不使用分代收集</li><li>将G1中的记忆集更改为连接矩阵。Region N引用Region M则N行M列打上一个标记</li></ul></li><li>初始标记   标记与GC Roots直接关联的对象  会stop the world 但是停顿时间与堆大小无关，只与GC Roots数量有关</li><li>并发标记  与G1一样，遍历对象图，标记出全部可达的对象。与用户线程一起并发。时间长短取决于堆中存活数量以及对象图的结构复杂程度。  并发执行</li><li>最终标记  与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将其构成一组回收集。   短暂 stop the world</li><li>并发清理  清理那些整个区域连一个存活对象都没有找到的Region    并发执行</li><li>并发回收  Shenandoah回收器的核心差异点。这个阶段，回收集里面的存活对象先复制一份到其他未使用的Region之中，采用读屏障（存在新对象复制，旧对象写入，转发指针改变的并发问题，采用读屏障解决）和Brooks Pointers的转发指针（就是直接多了一步转发，对象都指向转发地址，只需要改转发地址就可以）来解决并发阶段的困难 时间长短取决于回收集的大小  并发执行 </li><li>初始引用更新   只是建立一个线程集合点确保上一个阶段对象移动任务已经完成   stop the world</li><li>并发引用更新  进行引用更新操作，只需要按照内存物理地址的顺序，线性地搜索出引用类型，将旧对象的引用地址修正到新对象引用地址。    时间长短取决于内存中涉及的引用数量的多少。 并发执行</li><li>最终引用更新  解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。  停顿时间与GC Roots数量有关    stop the world</li><li>并发清理  调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li></ul></li><li><p>ZGC收集器   基于Region内存布局的，（暂时）不设分代，使用读屏障、染色指针和内存多重映射等技术来实现的<strong>可并发标记-整理算法</strong>，以低延迟为首要目标的一款垃圾收集器。</p><ul><li>Region具有动态性：动态创建和销毁，以及动态的区域容量大小。<ul><li>小型Region    容量固定为2MB，用于放置小于256KB的小对象</li><li>中型Region   容量固定为32MB，用于放置大于等于256KB但小于4MB的对象</li><li>大型Region   容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。一个大型Region中只会存放一个大对象。所以可能大型的Region的容量小于中型Region</li></ul></li><li>染色指针  直接将少量额外信息存储在指针上   通过4个标志信息，可以看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能够通过finalize（）方法才能被访问<ul><li>一旦某个Region存活对象被移动走后，能够立即释放这个Region并重用（Shenandoah在极端情况下要1:1才行）</li><li>大幅度降低内存屏障的使用数量。</li><li>是一种可扩展的存储结构，可以记录更多与对象标记、重定位过程相关数据，以便日后进一步提高性能。</li></ul></li><li>初始标记   初始化GC Roots      stop the world</li><li>并发标记  遍历对象图做可达性分析（初始，并发，最终）初始和最终也会短暂停顿。不同的是，ZGC的标记在染色指针上更新Marked 0、Marked 1标志位</li><li>并发预备重分配   ZGC划分Region，但是其目的不是为了像G1那样做收益优先的增量回收。相反，ZGC每次会扫描所有的Region（用扫描成本省去G1中的记忆集维护成本）因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。此外，在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。</li><li>并发重分配   ZGC核心阶段：这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（ForwardTable），记录从旧对象到新对象的转向关系（指针自愈：得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象）因为指针自愈的关系，不需要像Shenandoah的Brooks转发指针每次都转，只有第一次访问旧对象才会。</li><li>并发重映射：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，不同于Shenandoah的迫切，因为自愈特性，ZGC将其放在了下一次垃圾回收的并发标记阶段去执行，省去了一次遍历对象图的开销。</li><li>缺点：对象产生速率太快的情况下，<strong>因为没有采用分代</strong>，导致浮动垃圾越来越多，堆中剩余可腾挪的空间就越来越小</li></ul></li><li><p>对象的分配</p><ul><li>对象优先在Eden区中分配，当Eden区没有足够空间进行分配时，进行一次minor GC  <ul><li>-XX：Survivor-Ratio=8  设置eden和一个survivor区容量对比</li><li>-Xms20M   java堆大小为20MB</li><li>-Xmx20M 20=20 所以是设置堆不可扩展</li><li>-Xmn10M 新生代10MB</li></ul></li><li>大对象直接进入老年代（最典型的大对象是很长的字符串，或者元素数量很庞大的数组）<ul><li>-XX：PretenureSizeThreshold=3M 可以设置多大算大对象，这里大于3M在老年代创建对象（只针对Serial和PerNew俩款新生代收集器有效）</li></ul></li><li>长期存活的对象将进入老年代（分代收集）<ul><li>虚拟机给每个对象定义一个对象年龄计数器 Age，存储在对象头中。当对象在Eden区中诞生，经历过一次Minor GC并存活，且能被Survivor容纳，则进入Survivor，age设置为1，每进来一次Minor GC年长一岁，经历过设置的晋升老年代的阈值（默认15），则进入老年代。</li><li>-XX：MaxTenuringThreshold 设置晋升阈值</li></ul></li><li>动态对象年龄判断<ul><li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代</li></ul></li><li>空间分配担保（JDK6 之后参数无效，一定会担保）<ul><li>发生Minor GC之前，虚拟机必须检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果条件成立，则执行，不成立则虚拟机检查XX：HandlePromotionFailure参数的设置值是否允许担保失败；如果允许，那会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象平均大小，大于则尝试进行一次Minor GC，小于，或者该参数设置不允许冒险，则改为进行一次Full GC</li></ul></li></ul></li></ul><h3 id="4、虚拟机辅助工具"><a href="#4、虚拟机辅助工具" class="headerlink" title="4、虚拟机辅助工具"></a>4、虚拟机辅助工具</h3><h4 id="Java虚拟机自带命令行工具（一些基本工具，其余使用过程中需要再学）"><a href="#Java虚拟机自带命令行工具（一些基本工具，其余使用过程中需要再学）" class="headerlink" title="Java虚拟机自带命令行工具（一些基本工具，其余使用过程中需要再学）"></a>Java虚拟机自带命令行工具（一些基本工具，其余使用过程中需要再学）</h4><ul><li><p>jps：虚拟机进程状况工具</p><ul><li><p>jps [options] [hostid] （windows需要到jps所在路径下执行）   列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。（使用哪个虚拟机进程的hostid说明在操作哪个虚拟机）</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出LVMID，省略主类的名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main（）函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果进程执行的是jar包，则输出jar路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时的JVM参数</td></tr></tbody></table></li></ul></li></ul><ul><li><p>jstat：虚拟机统计信息监视工具</p><ul><li><p>jstat  [option vmid [ interval [s|ms] [count] ] (示例  jstat -gc 2764 250 250 表示250ms查一次进程2764垃圾收集状况，一共查询20次)  (当时远程虚拟机进程时vmid格式应当是)    [protocol:] [//] lvmid [@hostname [:port] /servername]  </p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载，卸载数量，总空间以及类装载所耗费的时间</td></tr><tr><td>-gc</td><td>监视java堆状况，包括Eden区，2个Survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代垃圾收集状况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代垃圾收集状况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>-compiler</td><td>输出即时编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被即时编译的方法</td></tr></tbody></table></li></ul></li><li><p>jinfo：Java配置信息工具（有部分运行期参数修改数值的能力）</p><ul><li>实时查看和调整虚拟机各项参数。  jinfo [option]  pid  （jinfo -flag CMSInitiatingOccupancyFraction 1444）</li><li>java -XX：+PrintFlagsFinal 查看参数默认值</li></ul></li><li><p>jmap：Java内存映像工具</p><ul><li><p>该命令用于生成堆转储快照，它还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。（一般称为heapdump或dump文件）（如果不使用jmap命令，要想获取Java堆转储快照也还有一些比较“暴力”的手段：譬如在第2章中用过的-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。）</p></li><li><p>jmap [option] vmid  （示例：jmap -dump：format=b，file=eclipse.bin 3500）</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成Java堆转储快照。格式为-dump：[live,] format=b,file=<filename> ,其中live子参数说明是否只dump出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在f-queue中等待Finalizer线程执行finalize方法的对象，只在linux/Solaris平台下有效</td></tr><tr><td>-heap</td><td>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等，只在Linux/Solaris平台下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-permstat</td><td>以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台下有效</td></tr><tr><td>-F</td><td>当虚拟机进程对-dump选项没有响应事，可使用这个选项强制生成dump快照，只在Linux/Solaris平台有效</td></tr></tbody></table></li></ul></li><li><p>jhat：虚拟机堆转储快照分析工具（分析功能相对来说比较简陋，耗费性能所以一般要拷贝到另一台机器进行分析，既然复制了，用其他工具则更好。）</p></li><li><p>jstack ：Java堆栈跟踪工具</p><ul><li><p>用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因：如线程间死锁、死循环、请求外部资源导致的长时间停顿挂起等</p></li><li><p>从JDK 5起，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈</p></li><li><p>jstack [option] vmid</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用到本地方法的话，可以显示C/C++ 的堆栈</td></tr></tbody></table></li></ul></li></ul><h4 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h4><ul><li>JConsole：Java监视与管理控制台  JDk正式成员  免费</li><li>JHSDB：基于服务性代理的调试工具   JDK正式成员 免费</li><li>VisualVM：多合-故障处理工具  独立开源项目 免费</li><li>JMC：可持续在线的监控工具  OpenJDK组织管理开源   收费（需要与HotSpot内部的“飞行记录仪”-JFR配合工作，JFR收费）</li></ul><h4 id="HotSpot虚拟机插件"><a href="#HotSpot虚拟机插件" class="headerlink" title="HotSpot虚拟机插件"></a>HotSpot虚拟机插件</h4><ul><li>HSDIS:JIT生成代码反汇编  可以将即时编译器动态生成的本地代码还原为汇编代码输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题</li></ul><h3 id="5、调优案例分析与实战"><a href="#5、调优案例分析与实战" class="headerlink" title="5、调优案例分析与实战"></a>5、调优案例分析与实战</h3><ul><li><p>大内存硬件程序部署策略（一台大电脑）</p><ul><li>逻辑集群部署（在一台物理机器上启动多个应用服务器进程，为每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。使用无Session复制的亲合式集群是一个相当合适的选择。）</li><li>单独java虚拟机（控制Full GC频率，让其在深夜定时执行，避免GC时间过长影响用户使用）</li></ul></li><li><p>集群间同步导致的内存溢出</p><ul><li>全局缓存，在收到正确信息前，发送的信息一直存在内存中保留，在网络传输不满足时，重发数据累计</li></ul></li><li><p>堆外内存导致的溢出错误</p><ul><li>直接内存：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出OutOf-MemoryError或者OutOfMemoryError：Direct buffer memory</li><li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（如果线程请求的栈深度大于虚拟机所允许的深度）或者OutOfMemoryError（如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存）。</li><li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，可能会抛出IOException：Toomany open files异常。</li><li>JNI代码：如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中，而是占用Java虚拟机的本地方法栈和本地内存的。</li></ul></li><li><p>外部命令导致系统缓慢</p><ul><li>使用java调用外部shell脚本等会导致创建新的进程，抢占了系统的处理器资源。</li></ul></li><li><p>服务器虚拟机进程奔溃</p><ul><li>与别的系统接口对接，如果对方服务响应时间长，而这边采用同步/异步的方式，会建立大量的Socket连接，最终导致进程奔溃。解决方法：一个是对方系统加快响应，一个是本机系统用消息队列</li></ul></li><li><p>不恰当数据结构导致内存占用过大</p></li><li><p>由windows虚拟内存导致的长时间停顿</p><ul><li>程序最小化后，工作内存被自动交换到磁盘的页面文件之中，这样发生垃圾收集时，就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。</li></ul></li><li><p>由安全点导致长时间停顿（在循环中等待进入安全点）</p><ul><li>HotSpot虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用int类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环（CountedLoop），相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为不可数循环（Uncounted Loop），将会被放置安全点。</li></ul></li></ul><h2 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h2><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><ul><li><p>无符号数  基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p></li><li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯的以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质也可以视作一张表。</p></li><li><p>class文件(在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。使用javap工具的-verbose参数输出的TestClass.class文件字节码内容   javap -verbose TestClass)</p><ul><li><p>魔数（Magic Number）头4个字节，用于确定这个文件是否为一个能被虚拟机接受的class文件。（值为0xCAFEEBABE）</p></li><li><p>第5,6位字节是次版本号（Minor Version）第7,8位字节是主版本号（Major Version） Java的版本号从45开始，JDK1.1支持45.0<del>45.65535；JDK1.2支持45.0</del>46.65535；JDK13 45.0~57.65535（关于次版本号，曾经在现代Java（即Java 2）出现前被短暂使用过，JDK 1.0.2支持的版本45.0～45.3（包括45.0～45.3）。JDK 1.1支持版本45.0～45.65535，从JDK 1.2以后，直到JDK12之前次版本号均未使用，全部固定为零。而到了JDK 12时期，由于JDK提供的功能集已经非常庞大，有一些复杂的新特性需要以“公测”的形式放出，所以设计者重新启用了副版本号，将它用于标识“技术预览版”功能特性的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号标识为65535，以便Java虚拟机在加载类文件时能够区分出来。）</p></li><li><p>常量池：主次版本号之后为其入口。Class文件出现的第一个表类型数据项目，因为其数量不固定，入口放置一项u2类型数据代表常量池容量计数值（constant_pool_count) <strong>这个容量计数从1开始而不是0；比如0x0016对应十进制22，即容量为21</strong>   常量池主要内容是</p><ul><li>字面量（Literal） 字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等</li><li>符号引用（Symbolic References）<ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul></li></ul></li><li><p>访问标志（access_flags）：常量池结束之后，紧接着的2个字节。这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等</p></li><li><p>类索引、父类索引与接口索引集合</p><p>Class文件中由这三项数据来确定该类型的继承关系</p><ul><li>类索引（this_class） u2类型  类索引用于确定这个类的全限定名</li><li>父类索引（super_class） u2类型 父类索引用于确定这个类的父类的全限定名</li><li>接口索引集合（interfaces）一组u2类型 （入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量）  被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</li></ul></li><li><p>字段表集合  用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。   包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）</p></li><li><p>方法表集合 Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样。包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes） <strong><em>方法重载（Overload），除了要求和原方法具有相同的简单名称之外，还需要一个与原方法不同的特征签名</em></strong> java代码层面的特征签名只包括，方法名称、参数顺序及参数类型，而字节码还额外包括方法返回值以及受查异常表。</p></li><li><p>属性表集合（不需要严格的顺序，其他地方需要）</p><ul><li><p>code属性</p><ul><li>max_stack代表了操作数栈（Operand Stack）深度的最大值</li><li>max_locals代表了局部变量表所需的存储空间</li></ul><p><strong><em>在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。这个处理只对实例方法有效，如果代码清单6-1中的inc()方法被声明为static，那Args_size就不会等于1而是等于0了。</em></strong></p></li><li><p>Exceptions属性  Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。(try catch finally 属于异常表)</p></li><li><p>LineNumberTable属性    用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点</p></li><li><p>LocalVariableTable及LocalVariableTypeTable属性   用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值</p></li><li><p>SourceFile及SourceDebugExtension属性    用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p></li><li><p>ConstantValue属性   通知虚拟机自动为静态变量赋值 <a href="https://www.jianshu.com/p/8a14ed0ed1e9">简书init和clinit对比</a></p><p>对非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>()方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<clinit>()方法中或者使用ConstantValue属性。目前Oracle公司实现的Javac编译器的选择是，如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就将会生成ConstantValue属性来进行初始化；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<clinit>()方法中进行初始化。</p></li><li><p>InnerClasses属性  用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p></li><li><p>Deprecated及Synthetic属性</p><ul><li>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</li><li>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的</li></ul></li><li><p>StackMapTable属性   复杂的变长属性，位于code属性的属性表中    这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p></li><li><p>Signature属性  记录泛型签名信息</p></li><li><p>BootstrapMethods属性  它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符</p></li><li><p>MethodParameters属性   变长属性  记录方法的各个形参名称和信息</p></li><li><p>模块化相关属性</p></li><li><p>运行时注解相关属性</p></li></ul></li></ul></li></ul><h3 id="2、字节码指令简介"><a href="#2、字节码指令简介" class="headerlink" title="2、字节码指令简介"></a>2、字节码指令简介</h3><ul><li><p>加载和存储指令</p><ul><li>将一个局部变量加载到操作栈：iload、iload_&lt; n&gt;、lload、lload_&lt; n&gt;、fload、fload_&lt; n&gt;、dload、dload_&lt; n&gt;、aload、aload_&lt; n&gt;·</li><li><em>将一个数值从操作数栈存储到局部变量表：istore、istore</em>&lt; n&gt;、lstore、lstore_&lt; n&gt;、fstore、fstore_&lt; n&gt;、dstore、dstore_&lt; n&gt;、astore、astore_&lt; n&gt;</li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt; i&gt;、lconst_&lt; l&gt;、fconst_&lt; f&gt;、dconst_&lt; d&gt;</li><li>扩充局部变量表的访问索引的指令：wide</li></ul></li><li><p>运算指令</p><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor·按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul></li><li><p>类型转换指令</p></li><li><p>窄化类型转换 i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f</p></li><li><p>对象创建与访问指令</p><ul><li>创建类实例的指令：new</li><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li><li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul></li><li><p>操作数栈管理指令</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值互换：swap</li></ul></li><li><p>控制转移指令</p><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li><li>复合条件分支：tableswitch、lookupswitch</li><li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li></ul></li><li><p>方法调用和返回指令（方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的）</p><ul><li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li><li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li><li>invokestatic指令：用于调用类静态方法（static方法）。</li><li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><p>返回指令：</p><ul><li>ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn</li></ul></li><li><p>异常处理指令</p><ul><li>athrow：显示抛出异常的操作（throw语句）</li><li>一些虚拟机自己定义的异常状况：idiv或ldiv指令。抛出ArithmeticException异常</li></ul></li><li><p>同步指令（锁）</p><ul><li>方法级  方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</li><li>代码块  同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有<strong>monitorenter</strong>和<strong>monitorexit</strong>两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持</li></ul></li></ul><h3 id="3、类加载机制"><a href="#3、类加载机制" class="headerlink" title="3、类加载机制"></a>3、类加载机制</h3><p>Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的</p><h4 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h4><ul><li><p>加载（Loading）</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li><p>连接（Linking）（加载阶段优先于连接阶段，但是会有部分交叉在加载阶段进行执行）</p><ul><li><p>验证（Verification）</p><ul><li><p>文件格式验证  如之前的版本号，魔数开头，文件本身或各个部分是否有被删除或者附加其他信息；<strong>目的</strong>：保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p></li><li><p>元数据验证    这个类的父类是否继承了不允许被继承的类；如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。等等</p><p><strong>目的</strong>：对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</p></li><li><p>字节码验证  对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：保证任何跳转指令都不会跳转到方法体以外的字节码指令上</p><p><strong>目的</strong>：通过数据流分析和控制力分析，确定程序语义是合法的、符合逻辑的。</p></li><li><p>符合引用验证（这是验证第4阶段，一般在解析阶段进行）  通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。例如 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。对应java.lang.NoSuchFieldError、java.lang.NoSuchMethodError</p></li></ul></li></ul><p><strong>目的</strong>  符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验。</p><ul><li><p>准备（Preparation）为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。（这个时候的变量赋值为0，真正初始化在<clinit>方法；如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值例如：public static final int value=123）</p></li><li><p>解析（Resolution）</p><ul><li>符号引用 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li><li>直接引用  直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li><li>类解析<ul><li>假设在D类中加载C类，如果C不是一个数组类型，则将全限定名传给D之后进行各种验证</li><li>如果C是数组类型，如果是对象数组。重复步骤1，如果不是，由虚拟机生成一个代表该数组维度和元素的数组对象。</li><li>上述俩步没问题，则进行最后的权限验证。如果不具备访问权限，抛出java.lang.illegalAccessError异常（由于jdk1.9模块的引入导致public类也存在权限问题）</li></ul></li><li>字段解析<ul><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li><li>将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ul></li><li>方法解析<ul><li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li><li>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ul></li><li>接口解析<ul><li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li><li>在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常。</li></ul></li></ul></li></ul></li><li><p>初始化（Initialization）（有且只有下列6种情况）</p><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。（对应的java代码场景：使用new关键字实例化对象的时候、读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候、调用一个类型的静态方法的时候）</li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</li><li>当初始化类的时候，如果发现其父类还没有初始化，则需要先触发其父类的初始化（接口不需要，只有在真的用到父接口时初始化）</li><li>虚拟机启动时，用户指定的一个要执行的主类（main方法那个类），虚拟机会先初始化这个主类</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li><li><clinit>   （没有静态变量和语句块，没有该方法）<ul><li>编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的静态变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</li><li><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是Object类。所以这也意味着父类中定义的静态语句块优先于子类的变量赋值操作。</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</li><li>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞</li></ul></li></ul></li><li><p>使用（Using）</p></li><li><p>卸载（Unloading）</p></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><p>类加载器 （判断俩个对象是否是同一个，一定要用同一个类加载器）</p><ul><li>自定义类加载器</li><li>启动类加载器 类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中</li><li>扩展类加载器  这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>应用程序类加载器  这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li></ul></li><li><p>双亲委派模型  （为了使所有的类加载转接到同一个父类上，保证是同一个对象）</p><ul><li><p>原理  要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p></li><li><p>工作过程  果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p></li><li><p>双亲委派模型的突破</p><ul><li><p>为了向下兼容：如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p></li><li><p>自身缺陷：有基础类型又要调用回用户的代码 例如：JNDI服务（JDBC这种）   引入了一个不太优雅的设计：线程上下文类加载器（Thread ContextClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<strong>这是一种父类加载器去请求子类加载器完成类加载的行为</strong></p></li><li><p>用户对程序动态性的追求：代码热替换（Hot Swap）、模块热部署（HotDeployment）等   </p><p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><ul><li>将以java.*开头的类，委派给父类加载器加载</li><li>否则，将委派列表名单内的类，委派给父类加载器加载。</li><li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li><li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li><li>否则，类查找失败。</li></ul></li></ul></li></ul></li></ul><h4 id="java模块化"><a href="#java模块化" class="headerlink" title="java模块化"></a>java模块化</h4><ul><li>依赖其他模块的列表。</li><li>导出的包列表，即其他模块可以使用的列表。</li><li>开放的包列表，即其他模块可反射访问模块的列表。</li><li>使用的服务列表。</li><li>提供服务的实现列表。</li><li>模块兼容性<ul><li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（UnnamedModule）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li><li>模块在模块路径的访问规则：模块路径下的具名模块（NamedModule）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</li><li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li></ul></li><li>扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代</li><li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载</li></ul><h3 id="4、虚拟机字节码执行引擎"><a href="#4、虚拟机字节码执行引擎" class="headerlink" title="4、虚拟机字节码执行引擎"></a>4、虚拟机字节码执行引擎</h3><h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><ul><li><p>局部变量表   一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。其在Java程序被编译为Class文件时，就确定了最大容量（在方法的Code属性的max_locals数据项中确定了）</p><ul><li>变量槽为最小单位，一个变量槽可以存放32位以内的数据类型：boolean、byte、char、short、int、float、reference和returnAddress。俩个变量槽 存 long和double（虽然被分割成俩个变量槽了，但是jvm不允许任何操作其中某一个的变量槽，再加上线程私有所以也安全）</li><li>局部变量表的调用采用索引，32位n代表第n个变量槽，64位n代表n和n+1个，对于实例方法，空出来0索引作为本方法的对象实例（this），其他从1开始</li><li>变量槽可以重用，在方法体内的变量可能并不需要生存整个方法体，垃圾回收发生在方法未结束时，不显示置为null或者别的变量覆盖的情况下，会影响垃圾回收（局部变量表是GCroots的一部分）（<strong>不推荐使用，因为现在的编译优化了，而且实际虚拟机使用解释器时可能也有处理</strong>）这些情况可以看情况进行显示清空<strong>（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到即时编译器的编译条件）</strong></li></ul></li><li><p>操作数栈     也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。</p><ul><li>操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</li><li>方法刚开始时，操作数栈为空。方法执行过程中，各种字节码指令往操作数栈中写入和提取内容，也就是出入栈操作。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，iadd指令只能操作俩个int类型相加</li></ul></li><li><p>动态连接    个栈帧都包含一个指向运行时常量池[插图]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p><ul><li>我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为<strong>静态解析</strong>。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为<strong>动态连接</strong></li></ul></li><li><p>方法返回地址</p><ul><li>正常调用完成    执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定</li><li>异常调用完成    在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出</li></ul></li></ul><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><ul><li>解析  解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成<ul><li>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析<ul><li>invokestatic。用于调用静态方法</li><li>invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法</li><li>invokevirtual。用于调用所有的虚方法（重写的方法，因为只有调用的时候才知道是不是多态的，是不是往上找）  （就是被final修饰方法不是虚方法但是也是这个指令），Java对象里面的方法默认（即不使用final修饰）就是虚方法</li><li>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象</li><li>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的</li></ul></li></ul></li><li>分派<ul><li>静态分派 （解释了为什么调用的是父类的方法）（重载  Overload）<ul><li>“Human”称为变量的“静态类型”（Static Type），或者叫“外观类型”（Apparent Type），后面的“Man”则被称为变量的“实际类型”（Actual Type）或者叫“运行时类型”（Runtime Type）。</li><li>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么</li></ul></li><li>动态分派 （Override 重写）<ul><li>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</li><li>实例方法是使用 invokevirtual指令调用的<ul><li>找到操作数栈顶的第一个元素所指向的对象的<strong>实际类型</strong>，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ul></li><li>只存在虚方法不存在虚字段，要是类里面有同名字段，则子类字段会遮蔽父类的同名字段</li></ul></li><li>单分派与多分派<ul><li>静态分派属于多分派类型  实际类型和参数作为宗量</li><li>动态分派属于单分派类型 只有实际类型作为宗量</li></ul></li><li>虚拟机动态分派的实现<ul><li>一般建立一个虚方法表，存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址</li><li>在invokeinterface执行时也会用到接口方法表——InterfaceMethod Table，简称itable</li></ul></li></ul></li></ul><h4 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h4><ul><li><p>invokedynamic指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        MethodType mt=MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">        Field lookupImpl=MethodHandles.Lookuo.class.getDeclaredField(&quot;IMPL_LOOKUP&quot;);</span><br><span class="line">        lookupImpl.setAcceddible(<span class="keyword">true</span>);</span><br><span class="line">        MethodHandle mh=((MethodHandles.Lookup)lookupImpl.get(<span class="keyword">null</span>)).findSpecial(GrandFather.class,&quot;thinking&quot;,mt,GrandFather.class);</span><br><span class="line">        mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h4><ul><li>基于栈的指令集<ul><li>主要优点 是可移植，因为寄存器由硬件直接提供[插图]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束</li><li>主要缺点是理论上执行速度相对来说会稍慢一些，所有主流物理机的指令集都是寄存器架构也从侧面印证了这点</li></ul></li></ul><h4 id="类加载架构"><a href="#类加载架构" class="headerlink" title="类加载架构"></a>类加载架构</h4><ul><li>正统类加载结构<ul><li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离</li><li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享</li><li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响</li><li>支持JSP应用的Web服务器，十有八九都需要支持HotSwap（热替换）功能。</li><li>以tomcat为例实现上述功能：<ul><li>放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</li><li>放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</li><li>放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li><li>放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li><li>tomcat6以后简化了默认的目录结构；将/common,/server和/shared3个目录默认合并到了一起变成一个/lib目录，如果默认设置不满足，可以通过修改配置文件，指定server.loader和share.loader的方式重新启用原来完整的加载器架构</li></ul></li></ul></li><li>OSGi：灵活的类加载器架构 （有存在出现循环依赖的可能，jdk7之后，将锁粒度到了类级别，有一定缓解）<ul><li>Bundle    OSGi中的每个模块（称为Bundle）与普通的Java类库区别并不太大，两者一般都以JAR格式进行封装[插图]，并且内部存储的都是Java的Package和Class。但是一个Bundle可以声明它所依赖的Package（通过Import-Package描述），也可以声明它允许导出发布的Package（通过Export-Package描述）。在OSGi里面，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖，而且类库的可见性能得到非常精确的控制，一个模块里只有被Export过的Package才可能被外界访问，其他的Package和Class将会被隐藏起来。</li><li>加载方式<ul><li>以java.*开头的类，委派给父类加载器加载。</li><li>否则，委派列表名单内的类，委派给父类加载器加载</li><li>否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载</li><li>否则，查找当前Bundle的Classpath，使用自己的类加载器加载。</li><li>否则，查找是否在自己的Fragment Bundle中，如果是则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载</li><li>否则，类查找失败。</li></ul></li></ul></li></ul><h2 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h2><p>编译期</p><ul><li>前端编译期：把*.java文件转变成  *.class文件的过程   JDK的javac</li><li>即时编译期 运行期把字节码转变成本地机器码的过程  HotSpot的C1、C2编译器</li><li>提前编译期 直接把程序编译成与目标机器指令集相关的二进制代码的过程  JDK的Jaotc</li></ul><h4 id="JavaC编译器（前端编译）"><a href="#JavaC编译器（前端编译）" class="headerlink" title="JavaC编译器（前端编译）"></a>JavaC编译器（前端编译）</h4><ul><li><p>准备过程：初始化插入式注解处理器</p></li><li><p>解析与填充符号表过程</p><ul><li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树  <ul><li>词法分析   com.sun.tools.javac.parser.Scanner类实现  是将源代码的字符流转变为标记（Token）集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。    int a=b+2，包含6个标记   </li><li>语法分析是  com.sun.tools.javac.parser.Parser类实现   根据标记序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</li><li>这个阶段产出的抽象语法树是以com.sun.tools.javac.tree.JCTree类表示的</li></ul></li><li>填充符号表。产生符号地址和符号信息<ul><li>符号表（Symbol Table）填充符号表的过程由com.sun.tools.javac.comp.Enter类实现   是由一组符号地址和符号信息构成的数据结构，读者可以把它类比想象成哈希表中键值对的存储形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等各种形式）。</li></ul></li></ul></li><li><p>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段</p><ul><li>可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次（Round）</li><li>插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</li></ul></li><li><p>分析与字节码生成过程</p><ul><li>标注检查。对语法的静态信息进行检查  Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类<ul><li>注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等</li><li>常量折叠优化 int a=1+2 和 int a=3 是一个工作量</li></ul></li><li>数据流及控制流分析。对程序动态运行过程进行分析   com.sun.tools.javac.comp.Flow类来完成<ul><li>它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题   </li></ul></li><li>解语法糖。将简化代码编写的语法糖还原为原有形式  解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成</li><li>字节码生成。将前面各个步骤所生成的信息转化成字节码。  Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成<ul><li>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作 比如 <clinit>和没有申明<init> 方法时的空<init>方法</li></ul></li><li>com.sun.tools.javac.jvm.ClassWriter类 最终输出Class文件</li></ul></li><li><p>语法糖</p><ul><li><p>泛型：java是类型擦除式泛型  在运行期再实际</p><ul><li>“裸类型”（Raw Type）  该泛型的父类    该泛型可以使ArrayList<int>  ArrayList<String>等待</li><li>为了解决int和long之类的转换。  直接加入自动拆装箱</li></ul></li><li><p>自动拆装箱与遍历循环</p></li><li><p>条件编译  使用条件为常量的if语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;block 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h4><h5 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h5><p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器激进优化时后备的“逃生门”（如果情况允许，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行，因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作</p><ul><li><p>解释器：直接将代码解释为机器可以执行的</p></li><li><p>编译器：将代码编译成本地机器码。</p></li><li><p>分层编译（用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量）</p><ul><li>第0层。程序纯解释执行，并且解释器不开启性能监控功能</li><li>第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能</li><li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能</li><li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息</li><li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化</li></ul></li><li><p>热点代码</p><ul><li>被多次调用的方法  由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式</li><li>被多次执行的循环体  但编译器依然必须以整个方法作为编译对象，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）。这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为“栈上替换”（OnStack Replacement，OSR），即方法的栈帧还在栈上，方法就被替换了。</li></ul></li><li><p>热点代码识别方式</p><ul><li>基于采样的热点探测（Sample Based Hot Spot CodeDetection）。 采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li>基于计数器的热点探测（Counter Based Hot Spot CodeDetection）。<ul><li>-XX：CompileThreshold 设置方法计数器阈值   服务端默认10000次，客户端默认1500次</li><li>-XX：BackEdgeThreshold供用户设置，但是当前的HotSpot虚拟机实际上并未使用此参数，我们必须设置另外一个参数-XX：OnStackReplacePercentage来间接调整回边计数器的阈值<ul><li>虚拟机运行在客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以OSR比率（-XX：OnStackReplacePercentage）除以100。其中-XX：OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为13995</li><li>虚拟机运行在服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以（OSR比率（-XX：OnStackReplacePercentage）减去解释器监控比率（-XX：InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，-XX：InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为10700</li></ul></li><li>-XX：-UseCounterDecay来关闭热度衰减   当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半；这个时间周期被称为半衰周期。</li><li>-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒</li><li>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程</li><li>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值（这个阈值是<strong>方法计数器+回边计数器</strong>（即为栈上计数器，为循环体上的次数））就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li></ul></li><li>参数-XX：-BackgroundCompilation来禁止后台编译  <ul><li>在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行；  </li><li>后台编译被禁止后，当达到触发即时编译的条件时，执行线程向虚拟机提交编译请求以后将会一直阻塞等待，直到编译过程完成再开始执行编译器输出的本地代码。</li></ul></li></ul></li></ul><h5 id="提前编译器"><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h5><ul><li>提前编译器（JAVA 9引入Jaotc作为提前编译器，代码质量相对较好，可以极限榨取性能）<ul><li>静态提前编译   在程序运行之前把程序代码编译成机器码的静态翻译工作（可以采用很多重负载优化手段，如过程间分析）</li><li>动态提前编译  把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用。（本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题）（<strong>限制了使用的HotSpot虚拟机的参数，和运行的目标机器也有关</strong>）</li></ul></li><li>即时编译器编译的代码质量的部分优点<ul><li>性能分析制导优化    如果一个条件分支的某一条路径执行特别频繁，而其他路径鲜有问津，那就可以把热的代码集中放到一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它    <strong>比如热代码</strong></li><li>激进预测性优化  相对于提前编译来说，即时编译的策略就可以不必这样保守，如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果   <strong>比如虚方法调用（大部分方法都是直接调用虚方法，不对再回退）</strong></li><li>链接时优化 （LTO） java天生动态链接，但是C和C++不是</li></ul></li></ul><h5 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h5><ul><li>方法内联（最重要）<ul><li>Java虚拟机首先引入了一种名为类型继承关系分析（Class Hierarchy Analysis，CHA）的技术，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。<ul><li>如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的</li><li>如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为守护内联（GuardedInlining）不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。假如在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</li><li>假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用是真正发生了的，但是比起直接查虚方法表还是要快一些。内联缓存是一个建立在目标方法正常入口之前的缓存，它的工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种单态内联缓存（Monomorphic Inline Cache）。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。但如果真的出现方法接收者不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成超多态内联缓存（Megamorphic Inline Cache），其开销相当于真正查找虚方法表来进行方法分派。</li></ul></li></ul></li><li>逃逸分析（最前沿）<ul><li>基本原理：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</li><li>栈上分配（HotSpot目前不支持）：Java虚拟机中，Java堆上分配创建对象的内存空间几乎是Java程序员都知道的常识，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。</li><li>标量替换：若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java中的对象就是典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</li><li>同步消除（Synchronization Elimination）：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉</li><li>参数-XX：+DoEscapeAnalysis来手动开启逃逸分析</li><li>使用+XX：+EliminateLocks来开启同步消除</li><li>使用参数-XX：+PrintEliminateAllocations查看标量的替换情况</li></ul></li><li>公共子表达式消除（语言无关）<ul><li>如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E</li><li>如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common SubexpressionElimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global CommonSubexpression Elimination）</li><li>int d=（c * b）* 12+a+(b * c+a );  可以优化成  int d=E*12+a+(E+a)  有些编译器还可能采用代数化简 int d=E * 13+a+a;</li></ul></li><li>数组边界检查消除、自动装箱消除、安全点消除、消除反射（语言相关）</li><li>Graal编译器</li></ul><h2 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h2><h3 id="Java内存模型（并发）"><a href="#Java内存模型（并发）" class="headerlink" title="Java内存模型（并发）"></a>Java内存模型（并发）</h3><ul><li><p>java内存模型</p><ul><li>主内存（Main Memory）：所有变量存储的地方</li><li>工作内存  保存了被该线程使用的变量的主内存副本[插图]，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据[插图]。</li><li>线程   不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</li></ul></li><li><p>内存间交互操作</p><ul><li>lock  锁定  作用于主内存变量，把一个变量标识为一条线程独占的状态</li><li>unlock 解锁 作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read 读取 作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便load动作使用</li><li>load 载入 作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use 使用  作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</li><li>assign 赋值 作用于工作内存变量，把一个从执行引擎接受的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li>store 存储  作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后write操作使用</li><li>write 写入 作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul></li><li><p>执行上述8种基本操作时必须满足的规则</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</li></ul></li><li><p>volatile变量使用场景</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li><li>变量不需要与其他状态变量共同参与不变约束</li><li>禁止指令重排序优化<ul><li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现。                 <strong>这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改</strong></li><li>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现            <strong>这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改</strong></li><li>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q                                                           <strong>这条规则要求volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同</strong></li></ul></li></ul></li><li><p>原子性、可见性、有序性</p><ul><li>原子性（Atomicity） 锁之外的6个基本操作，保证了基本类型的访问、读写都是具备原子性的。lock和unlock保证了synchronized块之间的操作具备原子性</li><li>可见性（Visibility）指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改<ul><li>volatile变量：保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</li><li>synchronized 同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的</li><li>final关键字：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值</li></ul></li><li>有序性 <ul><li>volatile关键字本身就包含了禁止指令重排序的语义</li><li>而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul></li><li>先行发生原则（时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准）<ul><li>程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构</li><li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</li><li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li><li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li><li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。</li><li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul></li></ul></li></ul><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><ul><li><p>内核线程实现（1:1线程模型）</p><ul><li>定义：直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核（Multi-ThreadsKernel）</li><li>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（我们通常意义上所讲的线程）<ul><li>优点：每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作、</li><li>缺点：各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源</li></ul></li><li>一个系统支持的轻量级进程的数量有限；由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程</li></ul></li><li><p>用户线程（1：n线程模型（绿色线程））</p><ul><li>定义：<ul><li>广义上一个线程只要不是内核线程，都可以认为是用户线程（UserThread，UT）的一种(包括了轻量级进程)</li><li>狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的</li></ul></li><li>优点：不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理</li><li>缺点：线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的。因为使用用户线程实现的程序通常都比较复杂</li></ul></li><li><p>混合实现（m:n线程模型）</p><ul><li>定义：在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险</li></ul></li><li><p>java线程</p><ul><li>java虚拟机在主流平台上采用1：1的线程模型</li><li>采用抢占式线程调度<ul><li>协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。（线程阻塞导致不稳定）</li><li>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定</li></ul></li><li>java存在线程优先级（但只是参考不准）（setPriority()方法 1~10  10个值 10最大，一般默认5）</li></ul></li><li><p>java线程状态  在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换</p><ul><li>新建（New）   创建后尚未启动的线程处于这种状态</li></ul></li><li><p>运行（Runnable） 包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间</p><ul><li><p>无限期等待（Waiting） 处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：</p><ul><li>没有设置Timeout参数的Object::wait()方法</li></ul></li></ul></li><li><p>没有设置Timeout参数的Thread::join()方法 （thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。）</p><ul><li>LockSupport::park()方法（LockSupport类是Java6(JSR166-JUC)引入的一个类，提供了基本的线程同步原语类似于wait和notify）</li></ul></li><li><p>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p><ul><li>Thread::sleep()方法<ul><li>设置了Timeout参数的Object::wait()方法；</li></ul></li><li>设置了Timeout参数的Thread::join()方法；</li><li>LockSupport::parkNanos()方法；</li><li>LockSupport::parkUntil()方法。<ul><li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   ThreadTest threadTest=<span class="keyword">new</span> ThreadTest(sb,stringBuilder,<span class="number">1</span>);</span><br><span class="line">LockSupport.park(threadTest);<span class="comment">//wait</span></span><br><span class="line">   LockSupport.unpark(threadTest);<span class="comment">//notify</span></span><br></pre></td></tr></table></figure><h4 id="java与协程"><a href="#java与协程" class="headerlink" title="java与协程"></a>java与协程</h4><ul><li>纤程（Fiber）  java的有栈携程 还在开发中（Loom项目，2018开始）</li></ul><h3 id="线程安全与锁优化（高效）"><a href="#线程安全与锁优化（高效）" class="headerlink" title="线程安全与锁优化（高效）"></a>线程安全与锁优化（高效）</h3><h4 id="线程安全分类"><a href="#线程安全分类" class="headerlink" title="线程安全分类"></a>线程安全分类</h4><ul><li>不可变<ul><li>如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的</li><li>如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。（最简单的一种就是把对象里面带有状态的变量都声明为final；String就是）</li></ul></li><li>绝对线程安全  线程安全的类（即各个方法都加上了synchronized），任然需要再实际调用方法中增加锁</li><li>相对线程安全  我们通常意义上所讲的线程安全。它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</li><li>线程兼容 指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。</li><li>线程对立 指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码<ul><li>suspend()和resume()方法</li><li>System.setIn()、Sytem.setOut()和System.runFinalizersOnExit()</li></ul></li></ul><h4 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h4><ul><li>互斥同步（Mutual Exclusion &amp;Synchronization）<ul><li>定义：是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用</li><li>互斥手段：临界区（CriticalSection）、互斥量（Mutex）和信号量（Semaphore）</li><li>synchronized  <ul><li>转化成monitorenter和monitorexit进行块锁定  这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</li><li>被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况</li><li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出</li></ul></li><li>ReentrantLock（重入锁）<ul><li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助</li><li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<strong>synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。</strong></li><li>锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可</li></ul></li><li>synchronized与ReentrantLock<ul><li>synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized</li><li>Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放</li><li>尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li></ul></li></ul></li><li>非阻塞同步  基于冲突检测的乐观并发策略<ul><li>硬件指令集CAS发展产生无锁编程</li><li>CAS比较并交换（Compare-and-Swap）<ul><li>CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</li><li>ABA问题：可以用版本号解决</li></ul></li></ul></li><li>无同步方案<ul><li>定义    要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系。同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的</li><li>可重入代码（简单判断原则：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的）<ul><li>不依赖全局变量</li><li>存储在堆上的数据和公用的系统资源</li><li>用到的状态量都由参数中传入</li><li>不调用非可重入的方法</li></ul></li><li>线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。典型引用：web交互模型：一个请求对应一个服务器线程。</li><li>如果一个变量只要被某个线程独享。可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</li></ul></li></ul><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul><li>自旋锁与自适应自旋<ul><li>自旋锁定义：现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁</li><li>优点：锁占用时间短，可以避免线程切换的开销</li><li>缺点：一直自旋，会拜拜消耗处理器时间。</li><li>自适应自旋：如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。</li></ul></li><li>锁消除<ul><li>对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除（主要依据逃逸分析的数据支持）</li></ul></li><li>锁粗化<ul><li>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。比如循环方法</li></ul></li><li>轻量级锁（在无竞争的情况下使用CAS操作去消除同步使用的互斥量）<ul><li>能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。</li><li>加锁是首先通过CAS操作，CAS操作成功则避免使用互斥量的开销。不成功，则轻量级锁也会膨胀成重量级锁，再加上CAS操作，反而会更慢。</li></ul></li><li>偏向锁（在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了）<ul><li>参数-XX：-UseBiasedLocking来禁止偏向锁优化</li><li>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作则一直不需要同步操作（加锁、解锁及对Mark更新等）</li><li>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;Jvm篇根据《深入理解Java虚拟机:JVM高级特性与最佳实践（第三版）》，加上笔者自己的验证理解所做。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://zhhw137.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://zhhw137.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="https://zhhw137.github.io/2020/09/10/mysql%E7%AF%87/"/>
    <id>https://zhhw137.github.io/2020/09/10/mysql%E7%AF%87/</id>
    <published>2020-09-10T05:30:00.000Z</published>
    <updated>2020-10-15T02:43:32.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Mysql的深入点了解，主要建立在《MySQL技术内幕：Innodb存储引擎（第二版）》的基础上，记录的知识点和一些自己验证后发现的自己的个人感觉书里表述不清的地方，当然，笔者是java后端的开发，一些比较偏DBA的地方有进行略过。</p><a id="more"></a><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>数据库：物理操作系统文件或其他形式文件类型的集合(数据的仓库)</p><p>实例：Mysql数据库由后台线程以及一个共享内存区组成(进程，也是我们实际以为的数据库)</p><p>范式：<a href="https://zhuanlan.zhihu.com/p/20028672">知乎</a></p><p>存储引擎 到表级别  show ENGINEs 查看    InnoDB，MyISAM       其他</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>innoDB 缓冲池  大小默认1G 个数默认1个（可扩展增加性能）</p><p>内存缓冲池管理技术 ： LRU list: lru和unzip_LRU   Free List     Flush list</p><p>​            脏页刷新回磁盘 CheckPoint  ( 类比redis缓存失效)   </p><ul><li>master thread 定时刷新  </li><li>flush_lru_list  不能保证100个空闲页供使用     LRU列表尾端淘汰的页</li><li>Async/Sync Flush Checkpoint  重做日志文件不可用   flush list 腾出空间来</li><li>Dirty Page too much 为了保持缓冲池中有足够的页</li></ul><p>InnoDB 关键特性</p><ul><li>插入缓冲</li><li>俩次写（doublewrite）<ul><li>partial page write ： InnoDB 的Page Size一般是16KB，其数据校验也是针对这16KB来计算的，将数据写入到磁盘是以Page为单位进行操作的。而计算机硬件和操作系统，在极端情况下（比如断电）往往并不能保证这一操作的原子性，16K的数据，写入4K 时，发生了系统断电/os crash ，只有一部分写是成功的，这种情况下就是 partial page write 问题。<br>很多DBA 会想到系统恢复后，MySQL 可以根据redolog 进行恢复，而mysql在恢复的过程中是检查page的checksum，checksum就是pgae的最后事务号，发生partial page write 问题时，page已经损坏，找不到该page中的事务号，就无法恢复。</li><li>为了解决 partial page write 问题 ，当mysql将脏数据flush到data file的时候, 先使用memcopy 将脏数据复制到内存中的double write buffer ，之后通过double write buffer再分2次，每次写入1MB到共享表空间，然后马上调用fsync函数，同步到磁盘上，避免缓冲带来的问题，在这个过程中，doublewrite是顺序写，开销并不大，在完成doublewrite写入后，在将double write buffer写入各表空间文件，这时是离散写入。<br>如果发生了极端情况（断电），InnoDB再次启动后，发现了一个Page数据已经损坏，那么此时就可以从doublewrite buffer中进行数据恢复了。</li></ul></li><li>自适应哈希索引</li><li>异步IO</li><li>刷新邻接页</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>参数文件   正常mysql的参数配置文件(可以没有，mysql有自己默认的一套)</li><li>socket文件    UNIX域套接字方式连接时候的文件</li><li>pid文件   mysql实例的进程id文件</li><li>mysql表结构文件   用来存放mysql表结构定义文件</li><li>存储引擎文件<ul><li>表空间文件</li><li>重做日志文件（redo log）</li></ul></li><li>日志文件<ul><li>错误日志文件   记录错误信息和警告</li><li>二进制文件  记录对数据库有更改的无所谓是否成功的操作(即不包括show和select)，主要用于恢复、复制、审计作用（通过信息，判断是否有注入攻击）</li><li>慢查询日志文件   根据参数long_query_time默认10s  记录执行慢的查询语句，即一个语句如果执行之间超过这个参数记录下来。  log_queries_not_using_indexes 记录没有使用索引的语句 。 slow_query_type  表示启用慢查询日志的方式：0 不记录，1记录超时的，2记录逻辑io次数超的，3都记录</li><li>查询日志文件 记录所有执行的sql语句，包括未能执行的。具体其他和慢查询一样</li></ul></li></ul><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul><li><p>索引组织表：根据主键顺序组织存放的表(因此数据即索引，索引即数据)</p></li><li><p>InnoDB逻辑存储结构</p><ul><li><p>表空间</p></li><li><p>段     索引段(非叶子节点)、数据段（叶子节点）、回滚段</p></li><li><p>区   由连续页组成，大小一定为1MB</p></li><li><p>页  管理最小单元    数据页、undo页、系统页、事务数据页、插入缓冲位图也、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页</p></li><li><p>行  存储格式:redundant(不推荐使用了)  compact(存储溢出数据的前768字节)/dynamic(8以后的默认格式，存储溢出数据的前20个字节)  针对text，blob大类型数据一旦溢出就拆分多个页存储     compressed 压缩格式，对数据索引都压缩其物理存储层面，读取到内存中要转换，影响性能  </p><p>多字节字符（utf-8，gbk）情况下 char和varchar没有区别，会自己填充</p></li></ul></li><li><p>页详细结构    </p><ul><li>File Header 文件头 38字节</li><li>Page Header 页头 56字节</li><li>Infimun和Supremum Records 限定边界</li><li>User Records 行记录</li><li>Free Space 空闲空间</li><li>Page Directory 页目录  B+树索引只能找到对应的页位置，时间数据是页加载到内存中，再进行二叉查找</li><li>File Trailer  文件结尾信息  8字节</li></ul></li><li><p>约束机制保证数据完整性</p><p>约束方式</p><ul><li>Primary Key 主键约束</li><li>Unique key 唯一索引约束</li><li>Foreign key 外键约束</li><li>Default 默认值</li><li>NOT NULL 不为空</li></ul><p>添加方式</p><ul><li>表建立时进行约束定义</li><li>利用Alter Table 命令进行创建</li><li>Unique Key 可以通过 create unique index建立</li><li>enum（男，女） set(1,2,’1,2’)建立约束</li></ul><p>约束和索引的区别：约束是逻辑概念，用来保证数据完整性，索引是物理和逻辑概念是一个数据结构，也代表着物理存储方式 详细解释 ：<a href="https://www.cnblogs.com/zjfjava/p/6922494.html">博客</a></p><p>不符合约束条件的错误数据：mysql底层转换成正确数据，发出警告（可通过sql_mode参数进行提示调整和报错）</p></li><li><p>触发器</p><ul><li><p>一个表最多建6个触发器：(update delete insert) * (before after)</p><p>基本语法 create trigger name  before|after   update|insert|delete   on  table  for each row (rtigger_stmt   此处为按照语法写的处理逻辑)</p></li></ul></li><li><p>外键约束</p><ul><li>MyISAM 不支持外键，其只是一种类似的注释作用</li><li>alter table stumarks add foreign key (stuno) references stuinfo(id) on delete set null on update cascade;   通过on delete和on update定义父表执行该操作时，子表的处理逻辑。<ul><li>cascade 同步</li><li>set null 子表中的数据更新为null 子表允许的情况下</li><li>no action 抛出错误不允许操作</li><li>restrict  抛出错误不允许操作，也是不指定外键类型的时候的默认值</li></ul></li></ul></li><li><p>视图</p><ul><li>由sql查询语句定义的虚表，没有实际物理存储</li><li>语法  create( or replace)  View name (column_list) as (select_stmt sql查询语句)   with  cascaded|local check option       cascaded 满足所有相关视图和表的条件，local 满足自身条件<ul><li>delete 操作，只能操作视图中存在的数据，有无 with check option相同</li><li>update 有时，必须update之后的数据符合视图条件</li><li>insert 有符合视图条件</li></ul></li></ul></li><li><p>物化视图（oralce自带，mysql通过触发器实现）</p><p>​    该视图转成真的基表实际存在的实表，加快在复杂sql语句生成的视图是查询效率慢的问题。</p><p>​    查询重写：查询基表时判断是否能够从其对应的物化视图中读取数据，可以就直接从视图中读取</p><ul><li>俩种创建方式<ul><li>build immediate 创建物化视图的时候就进行数据的生成</li><li>build deferred 创建视图时候不生成数据，后期再说</li></ul></li><li>刷新模式<ul><li>on demand 用户根据需要的时候再刷新数据</li><li>on commit 基本DML操作提交后直接刷新数据</li></ul></li><li>刷新方式<ul><li>fast 增量刷新</li><li>complete 全量刷新</li><li>force 数据库判断用fast还是complete</li><li>never 物化视图不进行刷新</li></ul></li></ul></li><li><p>分区表(分区字段一定要是主键或者是联合主键中的一个)</p><p>mysql只支持分平分和局部分区索引，即一个分区既存放了数据又存放了索引。而全局分区是所有数据索引单独存放爱一个对象中，只有数据存放在各个分区中</p><ul><li>RANGE分区 分区值连续,但是也需要指定一个大于或者小于的范围数据在哪个分区，多用来做时间的分隔，如按年分区，一年一区，想查某一年数据则只会查一个分区，想删除某一年数据直接删除分区  alter table 表名 drop partoion 分区名</li><li>LIST分区  分区离散 指定固定的值分布在哪个分区</li><li>HASH分区  通过自定的hash函数，将数据分布在哪个分区，在给定的数不是离散的情况下，可以较好的做到均匀分布 还有一种 LINEAR HASH 分区 <strong><em>优点</em></strong>：增加、删除、合并和拆分分区更快捷适合处理含有大量数据的表。**<em>缺点**</em>：相比较于hash分区，分布可能不太均匀</li><li>KEY分区 通过mysql自带的哈希函数进行分区  LINEAR就是其中一种</li><li>COLUMNS 分区   可以使用<strong>任一列作为分区，而不是像之前四种只能用整型(key支持使用除了text和blob之外的类型)，可以使用多个列进行分区</strong>，具有RANGE和LIST有RANGE COLUMNS和LIST COLUMNS俩种</li><li>子分区 在分区的基础上再进行分区，也就是复合分区即range和list上面进行hash和key分区</li></ul><p>对null值的处理，mysql会把null视为比任何值都小的值，所以range放在最左边分区，list需要显示指定null分区，hash和key会将其计算为0</p></li></ul><h3 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h3><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul><li>普通索引：create index index_name on tab_name (col_name); 仅加速查询</li><li>唯一索引: create unique index index_name on tab_name (col_name); 加速查询+列值唯一，但值允许为null</li><li>主键索引: primary key  加速查询+列值唯一+表中只能有一个，且值不能为null</li><li>联合索引 create [unique] index index_name on tbl_name (col_name,col_name)  多列值组成一个索引，专门用于组合搜索，效率大于索引合并（对多个索引分别按照条件扫描，将结果进行合并)。最左匹配原则，且对第二个键进行了排序。**(a,b,c)给a,b,c三列建联合索引则a,b同时使用时c有进行排序，(a,b)给a,b建立的索引有给b建立索引**<ul><li>select .. from tbl where a=xxx order by b   和    where a=xxx and b=xx order by c   (a,b,c) 可以使用到索引</li><li>select … from tbl where a=xxx  order by c  (a,b,c)不使用索引 (a,c)使用索引</li></ul></li><li>全文索引：对文本内容进行分词，进行搜索</li><li>覆盖索引: (或称索引覆盖)应该算一种辅助索引命中场景，即从辅助索引中就可以得到查询的记录,而不需要根据存储的信息查找聚集索引中的记录。(其叶子节点存着数据primary key1 和primary key2,key1,key2,执行类似select primary key1,key2 from tbl where key1=xx)。另外<strong>执行统计</strong>的时候，因为辅助索引数量远小于聚集索引,选择辅助索引可以减少IO操作。</li></ul><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ul><li><p>B+树是平衡查找树但不是二叉树 B 指代的是balance 根据键值对快速查找到数据所在的页，再将页读取到内存中进行 <strong>二分查找</strong>  (详情见数据结构篇)   。<strong>支持like ‘xxx%’这种索引方式</strong></p><ul><li>聚集索引  按照每张表的主键构造的一棵B+树,每个表唯一,叶子节点中存放的即为整张表的行记录数据，即数据页，每个数据页通过一个双向链表来进行链接,页中的数据也通过双向链表链接。因为双向链表的数据顺序性，适合范围查询和排序查找。<ul><li>聚集索引是逻辑上连续而物理存储上并不一定连续(符合链表的存储结构且消耗相对小)</li></ul></li><li>辅助索引(也称为非聚集索引)   叶子节点并不包含所有的行记录数据。叶子节点除了包含键值对以外，还包括一个书签(bookmark)，用来告诉innodb在哪里可以找到索引对应的数据记录(其就是对应行记录的聚集索引键)。辅助索引指向的是最高的那层树即辅助索引高度3 聚集索引高度3 查找数据要io访问6次</li></ul></li><li><p>索引管理</p><ul><li><p>增加 create [unique] index index_name [index_type] on tbl_name (index_col_name)   删除 drop index index_name on tbl_name</p></li><li><p>show index from tbl_name 展示索引的具体属性</p><ul><li>table 表名</li><li>non_unique  0代表是唯一的索引，1代表非唯一索引</li><li>seq_in_index 该列在索引中的位置，组合索引因为有最左匹配原则</li><li>collation 列以什么方式存储再索引中，A或null  B+树索引是排序的所以是A，hash索引则是null</li><li>Cardinality  索引中唯一值的数目的估计值，（3行记录，则没有重复显示3行,有一行重复显示2行,尽可能与行记录数一值,该值<strong>不是实时更新</strong> 可以通过<strong>analyze table company</strong>进行强制更新），非常小，则应该考虑删除索引</li><li>sub_part  是否是列的部分被索引，显示100则为前100字符进行索引</li><li>NULl 代表索引中是否允许含有null值</li></ul></li><li><p>索引创建机制    </p><ul><li><p>针对辅助索引：Fast Index Creation 快速索引创建FIC，给表增加S锁，表只读</p></li><li><p>针对主键索引：</p><ul><li>创建一张临时表(和原表一样的结构),</li><li>导入原表数据</li><li>删除原表</li><li>将临时表命名为原来的表</li></ul></li><li><p>Online Schema change</p></li><li><p>Online DDL   在线数据定义,是将DML操作日志写入缓存中,索引创建完毕再执行达到一致性。缓存大小默认128MB由innodb_online_alter_log_max_size控制。</p><p>  语法，在正常语句(alter table tbl_name add index index_name (col_name))后面+（,ALGORITHM=DEFAULT|INPLACE|COPY）(,LOCK=DEFAULT|NONE|SHARED|EXCLUSIVE)</p><ul><li>ALGORITHM 指定创建删除索引的算法 copy创建临时表形式，inplace不创建临时表,根据参数old_alter_table判断OFF(默认)inplace       on则为 copy</li><li>lock则是加锁情况(<strong><em>其他语句也可以用</em></strong>)   none,不加锁  share 加S锁只读    exclusive x锁排他,阻塞所有线程     default从none开始判读是否可用直到exclusive</li></ul></li></ul></li><li><p>Cardinality  索引中不重复记录数量的预估值。cardinality/n_rows_in_table 应该尽可能接近1。越接近1代表着索引是高选择性的，即这列的每个值越不相同。</p><ul><li>更新策略：采样方法  cardinality=(8个叶子节点记录数)*B+树索引叶子节点数量/8  因此每次的值可能不同,且值并不准确。innodb_stats_method判断如何对待索引中出现的null值记录,<ul><li>nulls_equal    null视为同一条记录即100个null也是一条</li><li>nulls_unequal  null视为不同记录100个也是100条</li><li>nulls_ignored  null不视为一条记录</li></ul></li><li>更新节点：1、表中1/16的数据已发生过变化；2、stat_modified_counter&gt;2000 000 000 inndb存储引擎内部有这么个计数器，用来记录发生变化的次数</li></ul></li></ul></li><li><p>索引的特殊场景</p><ul><li>优化器不使用索引   范围查找数据(就算辅助索引查到了之后是离散的数据，需要主键索引再差消耗io更大。而主键索引是顺序读的远快于离散读)且需要的是整行数据(辅助索引只存了主键), 可使用 force index 强制使用某个索引</li><li>Multi-Range Read优化（重点是排序后顺序查找）     MRR优化目的是为了减少磁盘的随机访问，将它转化为较为顺序的数据访问。就是将通过辅助索引查询到的结果，按照<strong>主键进行排序</strong>，在按照排序顺序进行书签查找，这可以减少缓冲池中页被替换的次数以及批量处理对键值的查询操作。(处理键值对的时候会进行拆分，这样可以在拆分过程中,直接过滤一些不符合查询条件的数据 select * from t where a&gt;1000 and a&lt;2000 and b=100,可以在取出来符合a的范围数据后，通过b进行过滤，性能巨大提升)<ul><li>mrr 表示是否启用mrr优化  on/off   set @@optimizer_switch=’mrr=on’</li><li>mrr_cost_based 表示是否通过cost based 方式选择启动mrr，就是说是否基于mrr的成本考虑mrr是否值得  set @@optimizer_switch=’mrr_cost_based=on’</li><li>read_rnd_buffer_size 控制键值的缓冲区大小 默认256K</li></ul></li><li>Index Condition Pushdown（重点是过滤）   ICP  mysql取出索引的同时，判断是否进行where条件的过滤，也就是将where的部分过滤操作放到存储引擎层。在某些查询下，可以大大减少上层sql层对记录的索取，从而提高数据库整体性能。（类似 select * from tbl where a=’1’  and b like ‘%xx’ 按照a索引取的数据，通过b先过滤再取出）</li></ul></li></ul><h4 id="全文索引-Full-Text-Search"><a href="#全文索引-Full-Text-Search" class="headerlink" title="全文索引(Full-Text Search)"></a>全文索引(Full-Text Search)</h4><ul><li><p>倒排索引：一种索引结构，在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射</p><ul><li>inverted file index  表现形式 【单词，单词所在文档id】  （some,2） some这个单词所在记录id为2</li><li>full inverted index 表现形式 【单词，（单词所在文档id，在具体文档中的位置）】（some,(2:3,6)）some这个单词所在记录id为2 ，在单词中3和6都出现了</li></ul></li><li><p>全文索引的构成</p><ul><li>Auxiliary Table 持久的辅助表存放于磁盘上</li><li>FTS Index Cache 全文检索索引缓存，红黑树结构，根据（word，list）（上面的一个2:3(documentid,position)即为list中的一个）排序</li><li>全文检索查询时才将缓存写入辅助表(类似于插入缓存的机制比如缓存满了立即同步到辅助表等)</li><li>FTS Document ID 。innodb中为了有一列与word进行映射支持全文检索，定义了一列FTS_DOC_ID 其类型必须是BIGINT UNSIGNED NOT NULL并且存储引擎会在其上加上名为FTS_DOC_ID_INDEX的Unique Index.可以自己添加也可以由存储引擎加</li><li>删除操作中,辅助表中被删除的记录，会记录其FTS Document ID,并将其保存在delete auxiliaty table中，只能用户手工将记录彻底删除，optimize table</li><li>stopword list 记录word不需要进行索引分词操作的单词，例如 the。可用户自己维护</li><li>全文检索限制：<ul><li>每张表只能有一个全文检索的索引</li><li>由多列组合而成的全文检索的索引必须使用相同的字符集和排序规则</li><li>不支持没有单词界定符的语言，如：中日韩</li></ul></li><li>全文索引具体使用语法：感觉限制了中文，这种全文检索应该被es代替了，不用过多关注</li></ul></li></ul><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>  innodb不支持人为设置hash索引，其具有自适应哈希索引,innodb会监控对表上二级索引的查找，如果发现某二级索引被频繁访问(最近连续被访问三次的数据),二级索引称为热数据，建立哈希索引。且innodb的哈希索引只支持where a=’xx’这种情况</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访（）。innodb支持行锁级</p><ul><li><p>latch  闩锁，轻量级,对象是线程，用于保护内存数据结构，存在于每个数据结构的对象中，持续时间为临界资源，用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制，仅通过应用程序加锁的顺序保证无死锁的情况，要求其锁定时间必须非常短，时间长则应用性能非常差。其有俩种分类</p><ul><li>mutex  互斥量(互斥锁)</li><li>rwlock 读写锁</li></ul></li><li><p>lock  对象是事务，用来保护数据库内容，如表、页、行，持续在整个事务过程中，具有waits-for gtaph、time out等机制进行死锁检测与处理，存在于lock manager的哈希表中</p><ul><li>行锁</li><li>表锁</li><li>意向锁（Intention lock）</li></ul></li></ul><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>一个事务已经获得了行r的共享锁，允许其他事务获得该行的s锁,(锁兼容) 不允许其他事务获得排他锁，只能等上面的共享锁和排他锁都释放了(锁不兼容)</p><ul><li>共享锁 (S Lock) 允许事务读一行数据   允许</li><li>排他锁 (X Lock) 允许事务删除或更新一行数据</li></ul><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>innodb支持多粒度锁定，导致允许事务执行过程中行锁和表锁同时存在。为了支持再不同粒度加锁，诞生了意向锁（intention lock），其不会阻塞除全表扫以外的任何请求。</p><ul><li>意向共享锁（IS Lock）,事务想要获得一张表<strong>某几行</strong>的共享锁</li><li>意向排他锁（IX Lock），事务想要获得一张表中<strong>某几行</strong>的排他锁</li></ul><table><thead><tr><th></th><th>IS</th><th>IX</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>IS</td><td>兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IX</td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><ul><li><p>锁相关表</p><ul><li>select * from information_schema.INNODB_TRX  查看事务的相关信息</li><li>select * from Performance_Schema.data_locks  查看锁相关信息（8以前 information_schema.INNODB_LOCKS） 其中一列lock_data事务锁定的记录的主键值，表锁为null，但是这个值行锁是也并不可信（范围值只锁第一行主键，锁住的页从缓冲池中被刷出，则也会显示null）</li><li>select * from Performance_Schema.data_lock_waits  查看当前等待的事务以及对应的锁（8以前 information_schema.INNODB_LOCK_WAITS）</li></ul></li><li><p>一致性非锁定读</p><p>指innodb通过多版本控制的方法来读取当前执行时间数据库中行的数据。如果读取的行正在执行delete和update操作，不会去等待锁的释放，而是读取undo中该行**<em>上一个版本(事务隔离级别为REPEATALBE REDA(mysql 默认)如果是READ COMMITTED 则不是上一个版本，而是数据最初版本)**</em>的快照数据。（一行数据可能不只一个快照数据，称之为多版本并发控制Multi Version Concurrency Control ，MVCC）</p></li><li><p>一致性锁定读</p><p> 这俩个select 锁定语句必须在事务中进行，所以一定要加上begin，start transaction或者set autocommit=0</p><ul><li>select_stamt for update    末尾加for update 显示的申明给该行加上x锁（不允许其他事务加锁，但是可以读，因为可以一致性非锁定读，读别的快照数据）</li><li>select_stamt lock in share mode  末尾加，显示的申明给该行加上s锁</li></ul></li><li><p>自增长与锁</p><table><thead><tr><th>插入类型</th><th>说明</th></tr></thead><tbody><tr><td>insert-like</td><td>指所有的插入语句如insert、insert …select、repalce、load data等</td></tr><tr><td>simple inserts</td><td>插入时确定了插入的行数如insert</td></tr><tr><td>bulk inserts</td><td>插入时不能确定插入行数 如 insert …select ,replace…select</td></tr><tr><td>mixed-mode inserts</td><td>一部分数据是自增长的一部分数据是确定的，如insert 心痛（‘5’，col）</td></tr></tbody></table></li></ul><table><thead><tr><th>innodb_autoinc_lock_mode</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>只采用表锁AUTO-INC-LOCKING方式实现自增长。</td></tr><tr><td>1</td><td>simple inserts采用互斥量的方式，bulk insert采用表锁。</td></tr><tr><td>2</td><td>只采用互斥量的方式</td></tr></tbody></table><ul><li><p>外键和锁</p><p>为了避免父表数据被更改或者删除，而字表插入数据，之后数据不一致。对字表数据插入时，查询父表的操作不采用一致性非锁定读的方式。</p></li></ul><h4 id="锁定算法"><a href="#锁定算法" class="headerlink" title="锁定算法"></a>锁定算法</h4><ul><li><p>Record Lock 记录锁 单个行记录上的锁</p></li><li><p>Gap Lock 间隙锁，锁定一个范围，但不包含记录本身</p></li><li><p>Next-Key Lock 临键锁：Gap Lock+Record Lock 锁定一个范围，并且锁定记录本身</p><ul><li>Next-Key Locking    左开右闭   （10,100] (<strong>主流</strong>)</li><li>previous-key locking    左闭右开  [10,100)</li></ul></li><li><p>对于唯一索引的锁定，next-key lock会降级成record lock，多列索引只用一个也不会降级。而普通索引则会加上next-key lock，同时给下一个辅助索引范围加上gap lock。**<em>没有索引的列或者索引失效，则进行表锁**</em></p><ul><li>比如 select * from tbl where b=3 for update  数据（b：1,3,6,8）俩列，a为主键，b有辅助索引</li><li>这时给（1,3] 加next-key lock 给（3，6）加gap lock</li></ul></li><li><p>俩种方式关闭</p><ul><li>事务隔离级别设置为READ Committed</li><li>将参数innodb_locks_unsafe_for_binlog 设置为1</li></ul></li><li><p>Phantom Problem指在同一事务下，连续执行俩次同样的sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行。可以用上面的间隙锁进行避免</p></li></ul><h4 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h4><ul><li>脏读  不同事务下，当前事务可以读到另外事务未提交的数据。事务隔离级别是 read uncommitted时才会发生。</li><li>不可重复读    指在一个事务内多次读取同一个数据集合，在这个事务还没结束时，另一个事务进行DML操作，导致第一个事务第二次读数据可能不一样。(锁读完释放了)（脏读读的是未提交的数据，不可重复读读的是提交了的别的事务的值） 事务级别在reda committed以下发生（mysql通过上面的next-key lock算法避免了这样的情况，所以mysql默认的隔离级别是 read repeatable）</li><li>幻读   类似于不可重复读，但是特指插入删除数据，而不可重复读特指修改数据。没有间隙锁前，只对数据加了行锁所以导致可能发生幻读，现在mysql引入间隙锁了，就不会发生了。</li><li>丢失更新   主要是应用层面的，应用a和应用b都已经查出来数据为100，应用a通过事务a提交更新为50，应用b通过事务b更新为90，则最后为90，理论应该为40.解决方式，在其上面用for update加排他锁</li></ul><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源。</p><ul><li>参数  innodb_lock_wait_timeout 默认50秒  阻塞等待时间 ，动态，可以在mysql运行时调整<ul><li>set @@innodb_lock_wait_timeout=60;</li></ul></li><li>参数  innodb_rollback_on_timeout  设定是否在等待超时时对进行中的事务进行回滚操作（默认off，不回滚），静态，不可以在mysql运行时调整<ul><li>set @@innodb_rollback_on_timeout=on;</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>指俩个或俩个以上的事务再执行过程中，因争夺锁资源而造成的一种互相等待的现象。</p><ul><li><p>回滚，将任何等待的事务都直接回滚重新执行</p></li><li><p>超时，设置等待阈值，如上面的innodb_lock_wait_timeout</p></li><li><p>wait-for graph（等待图），采用深度优先的算法主动检测死锁，根据保存的信息生成图，如果图中存在回路，则存在死锁，选择undo量最小的事务进行回滚。需要数据库保存以下俩种信息</p><ul><li>锁的信息链表    就是哪些事务要给该行记录增加锁的列表</li><li>事务等待链表   就是按顺序加入的事务列表</li></ul></li><li><p>锁升级  sql server存储锁按行来时，存储后所占资源内存超过激活内存的40%或者一个对象上持有的锁数量超过阈值时（5000默认）,将行锁向上审计为粗颗粒度的页锁、表锁等。 而mysql不存在这个问题，因为mysql是根据页加锁，一般资源开销不会太大。</p></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>是数据库区别于文件系统的重要特性之一。事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。</p><p>innodb存储引擎中事务完全符合ACID的特性，（也就是说因为某些原因有不符合的比如NDB Cluster不满足D）</p><ul><li>原子性 （atomicity）事务是不可分割的工作单位，要么成功要么不成功</li><li>一致性（consistency）指事务将数据库从一种状态转变为下一种一致的状态。数据库的层面特指的是一致性状态，即在事务前后数据库的完整性约束没有被破坏，例如对于姓名加了个唯一约束，一个事务对姓名进行了修改，但是事务提交或回滚，发现姓名出现重复，则数据库会撤销事务，返回最初状态。**<em>（在业务端则通常认为执行前后，数据保持一致才是一致性，例如转账者和收款人的总额应该保持不变）**</em></li><li>隔离性（isolation）要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常用锁来实现</li><li>持久性（durability）事务一旦提交，其结果就是永久性的。但是事务的持久性针对的是系统的<strong>高可靠性</strong>，数据库本身如RAID卡损坏等本身故障，应该利用其它系统共同配合进行高可用性的实现</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>扁平事务（Flat Transactions）事务类型中最简单也是使用最频繁的的一种，从事务begin到commit/rollback 要么都执行要么都不执行，不存在回滚部分的能力。</li><li>带有保存点的扁平事务（Flat Transactions with Savepoints）（<strong>事务+暂存</strong>）在扁平事务的基础上添加保存点（通过savepoint my2申明记录当前状态，rollback to SAVEPOINT my 则可以回退到那里，可以记录多个保存点），记录事务执行过程中的一个处理状态，以便当之后发生错误时，事务能回到保存点当时的状态。</li><li>链事务（Chained Transacations）（<strong>事务+链表</strong>）保存点模式的一种变种，在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，将提交事务和开启下一个事务操作合并为了一个原子操作。（将一个大的事务拆成各个小的事务，然后链式结构构建成链事务）区别于保存点模式，其只针对当前事务进行回滚（将链式事务当成一个大事务来看，就是只能恢复到最近的一个保存点）</li><li>嵌套事务（Nested Transacations）（innodb不支持，可以通过保存点事务模拟串行的嵌套事务，但是并行的则无能为力）（<strong>事务+树</strong>）是一个层次框架，由一个顶层事务控制各个层次事务。顶层事务嵌套下的事务称为子事务。<ul><li>子事务可以再嵌套事务也可以就是扁平事务</li><li>事务的前驱称为父事务，下一层称为子事务</li><li>子事务可以提交或者回滚，但是他的操作不会马上生效，除非父事务已经提交。</li><li>树中的任意一事务回滚，会引起它的所有子事务一同回滚，所以子事务不具有D的特性。</li><li>父事务具有的锁可以向子事务传递锁。子事务需要父事务不具有的锁，则需要通过反向继承，让父事务持有之后再传递过来</li></ul></li><li>分布式事务（Distributed Transacations）通常是一个分布式环境下运行的扁平事务。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><p>redo</p><ul><li><p>重做日志用来实现事务的原子性和持久性，其包括俩部分：一是内存中的重做日志缓冲（redo log buffer），二是重做日志文件（redo log file）其通过Force Log at Commit机制实现事务持久性，即事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才算完成。（fsync操作：同步内存中所有已修改的文件数据到储存设备。这里就是将重做日志缓存先写入重做日志文件，再写入磁盘）</p><p>参数innodb_flush_log_at+trx_commit用来控制重做日志刷新磁盘的策略</p><ul><li>0 事务提交时不进行写入重做日志操作，这个操作仅再maste thread中完成。master thread中每1秒回进行一次重做日志文件的fsync操作</li><li>1 默认值 每次提交执行一次</li><li>2 事务提交先将重做日志缓存写入重做日志文件的文件缓存中，不进行fsync操作</li></ul></li><li><p>log block  日志块，重做日志文件和日志缓存以512个字节进行存储，即以块的方式。因为日志块的大小和磁盘扇区大小一样，都是512字节，所以可以保证写入的原子性，不需要doublewrite技术，其写入redo log file虽然都是最后部分进行写入，但是不是顺序写入</p></li><li><p>log group 重做日志组  逻辑概念，实际只有一个，由多个重做日志文件组成。</p></li><li><p>重做日志格式：redo_log_type 重做日志的类型；space 表空间的id；page_no 页的偏移量</p></li><li><p>LSN   Log Sequence Number 代表日志序列号</p></li><li><p>恢复   重做日志是物理日志，记录物理修改才做，比如 insert into t select 1,2   其记录的是page(2,3),offset 32 ,value 1,2  可以很快进行恢复</p></li></ul></li><li><p>undo</p><ul><li><p>存储在数据库内部的一个特殊段（segment）中，称为undo段，位于共享表空间内，用于数据库事务的回滚操作，其不是将数据库物理的恢复到某一个状态，而是对之前执行的DML语句进行反向操作。除了回滚，其另一个功能是实现innodb的MVCC(某行记录被事务锁定，通过undo获得之前的行版本信息，实现非锁定读)。同时，undo log的产生伴随着redo log ，因为undo log也需要持久化</p></li><li><p>undo页可以复用。当事务提交时，首先将undo log放入链表，判断undo页的使用空间是否小于3/4，若是则表示可以复用，将记录放在其后面。因此，执行purge操作时，需要涉及到磁盘的离散读操作了。</p></li><li><p><strong>undo log</strong>格式</p><ul><li>insert undo log  因为insert操作的记录，只对事务本身可见，对其他事务不可见，所以undo log提交后直接删除</li><li>update undo log  因为delete和update操作产生的undo log，因为mvcc的需要。事务提交后放入undo log链表，等待purge操作删除</li></ul></li><li><p>purge  delete和update操作可能并不直接删除原有数据，而是在主键列上的记录delete flag设为1，（update也是这么处理原逻辑），而并没有删除，任然在b+树上，有purge最终真正完成删除操作。因为要支持MVCC,不能再事务提交时立即进行处理。</p></li><li><p>group commit   一次fsync可以刷新确保多个事务日志写入文件。</p></li></ul></li><li><p>显示事务控制语句</p><ul><li>显示的开启一个事务：start  transaction |  begin    显示的开启一个事务（在存储过程中，begin会被识别成begin … end所以只能用前者）</li><li>commit | commit work   提交事务 （completion_type值为0时，俩者相同，为1时，后者等同于commit and chain 表示是链式事务，马上自动开启一个相同隔离级别的事务，为2时，commit work等同于commit and release，在事务提交后会自动断开与服务器的连接）</li><li>rollback | rollback work 回滚事务</li><li>savepoint    name  在事务中创建一个保存点</li><li>release savepoint   name  删除一个事务的保存点</li><li>rollback to  savepoint_name  将事务回滚到标记点（只是回滚到保存点，但是不是真正的回滚了事务，还需要显式的执行commit或rollback命令）</li><li>set transaction 设置事务的隔离级别</li></ul></li><li><p>隐式提交的sql语句</p><ul><li>DDL语句：ALTER DATABASE…UPGRADE DATADIRECTORY NAME，ALTER EVENT，ALTERPROCEDURE，ALTER TABLE，ALTER VIEW，CREATEDATABASE，CREATE EVENT，CREATE INDEX，CREATE PROCEDURE，CREATE TABLE，CREATETRIGGER，CREATE VIEW，DROP DATABASE，DROPEVENT，DROP INDEX，DROP PROCEDURE，DROPTABLE，DROP TRIGGER，DROP VIEW，RENAMETABLE，TRUNCATE TABLE。</li><li>用来隐式地修改MySQL架构的操作：CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SETPASSWORD。</li><li>管理语句：ANALYZE TABLE、CACHE INDEX、CHECKTABLE、LOAD INDEX INTO CACHE、OPTIMIZETABLE、REPAIR TABLE。</li></ul></li><li><p>对于事务操作的统计</p><p>显示控制事务的提交和回滚，可以通过com_commit和com_rollback进行统计</p></li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul><li><p>Read UnCommitted</p></li><li><p>Read Committed</p></li><li><p>Repeatable Read</p></li><li><p>Serializable(再innodb中因为间隙锁的存在，主要用于分布式事务)</p><p>查看当前会话的事务隔离级别:select @@tx_isolation</p></li></ul><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul><li><p>XA事务：由一个或多个资源管理器、一个事务管理器以及一个应用程序组成</p><ul><li>资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器</li><li>事务管理器：协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信</li><li>应用程序：定义事务的边界，指定全局事务中的操作</li></ul></li><li><p>分布式事务使用俩段式提交（two-phase commit）</p><ol><li>所有参与全局事务的节点都开始准备，告诉事务管理器他们准备好提交了</li><li>事务管理器告诉资源管理器执行提交或回滚</li><li>任何一个节点显示不能提交，则所有节点被告知回滚</li></ol></li><li><p>内部XA事务</p><ul><li>binlog和innodb存储引擎之间。如果二进制日志写入而redo log没有写入。则slave可能接受到master的二进制日志执行，而master本身没有，造成主从不一致</li><li>MySQL数据库在binlog与InnoDB存储引擎之间采用XA事务。当事务提交时，InnoDB存储引擎会先做一个PREPARE操作，将事务的xid写入，接着进行二进制日志的写入，如果在InnoDB存储引擎提交前，MySQL数据库宕机了，那么MySQL数据库在重启后会先检查准备的UXID事务是否已经提交，若没有，则在存储引擎层再进行一次提交操作。</li></ul></li></ul><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><h4 id="备份的分类"><a href="#备份的分类" class="headerlink" title="备份的分类"></a>备份的分类</h4><ol><li>按照备份方法不同分类<ul><li>热备 Hot BackUp 数据库运行中直接备份。官方称之为Online Backup 在线备份</li><li>冷备 Cold BackUp 数据库停止的情况下备份，一般只需要复制相关数据库物理文件即可。官方称其为Offline Backup 离线备份（只需要备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件（*.ibd），重做日志文件。另外建议定期备份MySQL数据库的配置文件my.cnf，这样有利于恢复的操作。）</li><li>温备 Warm BackUp 在数据库运行中进行，但是会对当前数据库的操作有影响，如加一个全局读锁一保证备份数据额一致性</li></ul></li><li>按照备份后文件内容分类<ul><li>逻辑备份 指备份出的文件可读。内容由一条条sql语句，或者表实际数据组成。优点是可以观察导出文件的内容，适用于数据库迁移升级工作。缺点是恢复所需要的时间往往很长</li><li>裸文件备份 指复制数据库的物理文件，既可以是在数据库运行中的复制，也可以是在数据库停止运行时直接的数据文件复制。这类备份，往往恢复时间较逻辑备份短很多</li></ul></li><li>按照备份数据库的内容来分<ul><li>完全备份 指对数据库进行一个完整的备份。</li><li>增量备份 在上次完全备份的基础上，对更改的数据进行备份。</li><li>日志备份 指Mysql数据库二进制日志的备份，通过对一个完全备份进行二进制日志的重做来完成数据库的point-in-time的恢复工作。MySQL数据库复制（replication）的原理就是异步实时地将二进制日志重做传送并应用到从（slave/standby）数据库。</li></ul></li></ol><ul><li><p>快照备份   主要是利用文件的快照，备份数据库文件。</p></li><li><p>复制 （replication） 其实就是一个完全备份加上二进制日志备份的还原，主要用来建立高可用架构的主从复制（复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时）</p><ul><li>主服务器  把数据更改记录到二进制日志中</li><li>从服务器  把主服务器的二进制日志复制到自己的中继日志中</li><li>从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。</li></ul></li><li><p>复制的主要功能</p><ul><li>数据分布：由于MySQL数据库提供的复制并不需要很大的带宽要求，因此可以在不同的数据中心之间实现数据的复制。</li><li>读取的负载平衡：通过建立多个从服务器，可将读取平均地分布到这些从服务器中，并且减少了主服务器的压力。一般通过DNS的Round-Robin和Linux的LVS功能都可以实现负载平衡。</li><li>数据库备份：复制对备份很有帮助，但是从服务器不是备份，不能完全代替备份。</li><li>高可用性和故障转移:通过复制建立的从服务器有助于故障转移，减少故障的停机时间和恢复时间。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;Mysql的深入点了解，主要建立在《MySQL技术内幕：Innodb存储引擎（第二版）》的基础上，记录的知识点和一些自己验证后发现的自己的个人感觉书里表述不清的地方，当然，笔者是java后端的开发，一些比较偏DBA的地方有进行略过。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://zhhw137.github.io/categories/Mysql/"/>
    
    
    <category term="mysql" scheme="https://zhhw137.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>流水线</title>
    <link href="https://zhhw137.github.io/2020/08/26/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>https://zhhw137.github.io/2020/08/26/%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2020-09-08T01:03:21.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>对，你没看错，这篇的主要内容是流水线，IT工人也是工人，流水线加快速度自然是一个更加方便资本主义压榨的好方法了。<img src="/images/%E6%90%9E%E7%AC%91%E7%8B%97%E5%A4%B4%E8%84%B8.jpg" alt="git"></p><a id="more"></a><p>上篇文章，说了一堆关于rancher和k8s的基本概念和知识，其实小编自己也没有弄懂。成本有限的情况下，蹭了一台别人的机器上的虚拟机(配置还是很高的,双核,64G,1T)尝试着搭建了下k8s，照着命令倒是把master和node搭建在这一台机器上成功了，但是rancher成功之后，因为不可抗力最后没有看到实际效果。暂时就放弃了<img src="/images/%E6%8D%82%E8%84%B8%E7%AC%91.jpg" alt="git"></p><p>言归正传。</p><p>所谓流水线，指的是rancher上的流水线，即自动从gitlab上读取代码，打包，构建镜像，部署、启动程序一气呵成的流水线。下面让我们来看下具体流程</p><p>1、harbor镜像仓库安装</p><p>rancher的资源镜像库中添加</p><p>2、流水线配置</p><p>rancher的可视化平台上，工具上进行流水线配置。这里会绑定代码库等配置</p><p>3、实际项目文件书写</p><p>上面俩步，公司的大佬完成后我因为权限不足，也就是结合着其他博客等知识大概看了看，没有实际上手经验就不多说了<img src="/images/%E8%AF%B4%E4%B8%8D%E5%87%BA%E8%AF%9D.jpg" alt="git"></p><p>但是，说道给项目编写配置文件触发流水线<img src="/images/%E4%B8%8D%E5%9B%B0%E4%BA%86.jpg" alt="git"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="rancher-pipeline-yml"><a href="#rancher-pipeline-yml" class="headerlink" title=".rancher-pipeline.yml"></a>.rancher-pipeline.yml</h4><p>​    该配置文件即为流水线的主要配置文件，也是正常看到的流水线clone、build、publish、deploy四步的原因<img src="/images/%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%97%A5%E5%BF%97.png" alt="git"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">runScriptConfig:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">maven:3.6.0-jdk-8-alpine</span></span><br><span class="line">      <span class="attr">shellScript:</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="string">package</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">push-image</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">publishImageConfig:</span></span><br><span class="line">      <span class="attr">dockerfilePath:</span> <span class="string">./Dockerfile</span></span><br><span class="line">      <span class="attr">buildContext:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">tag:</span> <span class="string">scc/hyperloop-baseapi:$&#123;CICD_EXECUTION_SEQUENCE&#125;</span></span><br><span class="line">      <span class="attr">pushRemote:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">registry:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">applyYamlConfig:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">./deployment.yaml</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><ul><li>该配置文件一定要写在项目的根目录下</li><li>clone 根据上面配置的代码库和流水线配置直接去拉取代码，无须写</li><li>bulid mavn命令进行代码打包</li><li>publish  <ul><li>根据dockerfilepath中对应的dockerfile文件读取对应的docker命令发布镜像</li><li>tag本次镜像仓库的地址 scc/hyperloop-baseapi 这里应该为你的镜像仓库地址</li></ul></li><li>deploy  path对应的是部署镜像的文件地址</li></ul><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM    xx&#x2F;system&#x2F;openjdk:8-jdk-alpine</span><br><span class="line">ADD        xx.jar  &#x2F;app.jar</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><ul><li>FROM  指定基础镜像路径</li><li>ADD  生成的jar包名称和打包项目路径</li><li>ENTRYPOINT 运行项目 -D 是新增参数，参数的名字叫 java.security.egd ，参数的值叫 file:/dev/./urandom，是为了解决随机数生成的问题(看解释是因为jdk的一个bug导致,指定随机数生成可以优化性能，在一定程度上加快程序启动)<img src="/images/%E6%90%9E%E7%AC%91%E7%8B%97%E5%A4%B4%E8%84%B8.jpg" alt="git">)</li></ul><h4 id="deployment-yaml"><a href="#deployment-yaml" class="headerlink" title="deployment.yaml"></a>deployment.yaml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  <span class="comment"># 指定api版本，此值必须在kubectl api-versions中  </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  <span class="comment"># 指定创建资源的角色/类型   </span></span><br><span class="line"><span class="attr">metadata:</span>  <span class="comment"># 资源的元数据/属性 </span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo</span>  <span class="comment"># 资源的名字，在同一个namespace中必须唯一</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 部署在哪个namespace中</span></span><br><span class="line">  <span class="attr">labels:</span>  <span class="comment"># 设定资源的标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 资源规范字段</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 声明副本数目</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 匹配标签</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 示在更新过程中能够进入不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模版</span></span><br><span class="line">    <span class="attr">metadata:</span> <span class="comment"># 资源的元数据/属性 </span></span><br><span class="line">      <span class="attr">annotations:</span> <span class="comment"># 自定义注解列表</span></span><br><span class="line">        <span class="attr">sidecar.istio.io/inject:</span> <span class="string">&quot;false&quot;</span> <span class="comment"># 自定义注解名字</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># 设定资源的标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line">    <span class="attr">spec:</span> <span class="comment"># 资源规范字段</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span> <span class="comment"># 容器的名字   </span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">demo:v1</span> <span class="comment"># 容器使用的镜像地址   </span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 每次Pod启动拉取镜像策略，三个选择 Always、Never、IfNotPresent</span></span><br><span class="line">                                      <span class="comment"># Always，每次都检查；Never，每次都不检查（不管本地是否有）；IfNotPresent，如果本地有就不检查，如果没有就拉取 </span></span><br><span class="line">        <span class="attr">resources:</span> <span class="comment"># 资源管理</span></span><br><span class="line">          <span class="attr">limits:</span> <span class="comment"># 最大使用</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">300m</span> <span class="comment"># CPU，1核心 = 1000m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">500Mi</span> <span class="comment"># 内存，1G = 1000Mi</span></span><br><span class="line">          <span class="attr">requests:</span>  <span class="comment"># 容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">livenessProbe:</span> <span class="comment"># pod 内部健康检查的设置</span></span><br><span class="line">          <span class="attr">httpGet:</span> <span class="comment"># 通过httpget检查健康，返回200-399之间，则认为容器正常</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/healthCheck</span> <span class="comment"># URI地址</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment"># 协议</span></span><br><span class="line">            <span class="comment"># host: 127.0.0.1 # 主机地址</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span> <span class="comment"># 表明第一次检测在容器启动后多长时间后开始</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span> <span class="comment"># 检测的超时时间</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">30</span> <span class="comment"># 检查间隔时间</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span> <span class="comment"># 成功门槛</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span> <span class="comment"># 失败门槛，连接失败5次，pod杀掉，重启一个新的pod</span></span><br><span class="line">        <span class="attr">readinessProbe:</span> <span class="comment"># Pod 准备服务健康检查设置</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/healthCheck</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment">#也可以用这种方法   </span></span><br><span class="line">        <span class="comment">#exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常   </span></span><br><span class="line">        <span class="comment">#  command:   </span></span><br><span class="line">        <span class="comment">#    - cat   </span></span><br><span class="line">        <span class="comment">#    - /tmp/health   </span></span><br><span class="line">        <span class="comment">#也可以用这种方法   </span></span><br><span class="line">        <span class="comment">#tcpSocket: # 通过tcpSocket检查健康  </span></span><br><span class="line">        <span class="comment">#  port: number </span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 名称</span></span><br><span class="line">            <span class="attr">containerPort:</span> <span class="number">8080</span> <span class="comment"># 容器开发对外的端口 </span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 协议</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span> <span class="comment"># 镜像仓库拉取密钥</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">harbor-certification</span></span><br><span class="line">      <span class="attr">affinity:</span> <span class="comment"># 亲和性调试</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span> <span class="comment"># 节点亲和力</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># pod 必须部署到满足条件的节点上</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span> <span class="comment"># 节点满足任何一个条件就可以</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">matchExpressions:</span> <span class="comment"># 有多个选项，则只有同时满足这些逻辑选项的节点才能运行 pod</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">beta.kubernetes.io/arch</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">amd64</span></span><br></pre></td></tr></table></figure><p>参考链接</p><ul><li>[k8s官方英文] (<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/%EF%BC%89">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/）</a></li><li>[中文介绍] (<a href="https://feisky.gitbooks.io/kubernetes/content/concepts/deployment.html%EF%BC%89">https://feisky.gitbooks.io/kubernetes/content/concepts/deployment.html）</a></li><li>[博客] (<a href="https://draveness.me/kubernetes-deployment/%EF%BC%89">https://draveness.me/kubernetes-deployment/）</a></li></ul><p>以上就是我目前对流水线的初步认识了，后续了解加深会再补充一篇文章。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;流水线&quot;&gt;&lt;a href=&quot;#流水线&quot; class=&quot;headerlink&quot; title=&quot;流水线&quot;&gt;&lt;/a&gt;流水线&lt;/h2&gt;&lt;p&gt;对，你没看错，这篇的主要内容是流水线，IT工人也是工人，流水线加快速度自然是一个更加方便资本主义压榨的好方法了。&lt;img src=&quot;/images/%E6%90%9E%E7%AC%91%E7%8B%97%E5%A4%B4%E8%84%B8.jpg&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="容器" scheme="https://zhhw137.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="rancher" scheme="https://zhhw137.github.io/tags/rancher/"/>
    
    <category term="k8s" scheme="https://zhhw137.github.io/tags/k8s/"/>
    
    <category term="流水线" scheme="https://zhhw137.github.io/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Rancher+k8s初识</title>
    <link href="https://zhhw137.github.io/2020/08/25/Rancher+k8s%E5%88%9D%E5%A7%8B/"/>
    <id>https://zhhw137.github.io/2020/08/25/Rancher+k8s%E5%88%9D%E5%A7%8B/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-09-08T01:03:07.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rancher-k8s初识"><a href="#Rancher-k8s初识" class="headerlink" title="Rancher+k8s初识"></a>Rancher+k8s初识</h2><p>8月13号，Docker公司的最新服务条款中明确指出：禁止美国“实体清单”上的实体使用(其中包括华为、奇虎360、科大讯飞等中国IT公司)。让这一时下最流行的容器管理技术，又实实在在的火了一波。所以，今天让我们来看看它的替代品之二：rancher+k8s。(主要笔者还不会docker)<img src="/images/%E6%8D%82%E8%84%B8%E7%AC%91.jpg" alt="git"></p><a id="more"></a><h3 id="存在即合理"><a href="#存在即合理" class="headerlink" title="存在即合理"></a>存在即合理</h3><p>1、容器技术的兴起：虚拟机是在容器技术大行其道之前，开发和运维成员的主流技术。但是其高昂的移植成本、启动慢和占用空间大等问题，为以docker为代表的容器管理技术的兴起埋下伏笔。所谓容器化，就是放弃虚拟机虚拟整个操作系统，而是只虚拟一个小规模的环境即可。</p><p>2、微服务：为了满足业务发展而导致的用户量增多，系统数量增多和互相之间调用的依赖关系的赋值，确保系统的高可用、高并发要求，系统的架构慢慢从单机时代迁移到服务SOA时代。应运而生的就是大量的系统和容器使用。于是，一个管理所有容器的技术架构或者说工具迫在眉睫。而k8s的问世，就是提出的一套全新的基于容器技术的分布式架构领先方案。</p><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>k8s全称kubernetes，为了应对微服务而兴起的分布式架构，既然是分布式，则必然有着集群的部署条件。</p><p>k8s集群由master节点和Node节点组成，</p><p><strong>Master节点</strong></p><p>master节点是集群的控制节点，管理和控制整个集群，它负责具体的执行过程，其上运行着：</p><ol><li>Kubernetes Controller Manager（kube-controller-manager）：k8s中所有资源对象的自动化控制中心，维护管理集群的状态，比如故障检测，自动扩展，滚动更新等。</li><li>Kubernetes Scheduler（kube-scheduler）： 负责资源调度，按照预定的调度策略将Pod调度到相应的机器上。</li><li>etcd：保存整个集群的状态。</li></ol><p><strong>Node节点</strong></p><p>除了master以外的节点被称为Node或者Worker节点，可以在master中使用命令 <code>kubectl get nodes</code>查看集群中的node节点。每个Node都会被Master分配一些工作负载（Docker容器），当某个Node宕机时，该节点上的工作负载就会被Master自动转移到其它节点上。在Node上主要运行着：</p><ol><li>kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，实现集群管理的基本功能</li><li>kube-proxy：实现service的通信与负载均衡</li><li>docker（Docker Engine）：Docker引擎，负责本机的容器创建和管理</li></ol><h3 id="rancher"><a href="#rancher" class="headerlink" title="rancher"></a>rancher</h3><p>技术领域，从来不会形成一家独大的情况，一项技术总会有其优缺点，也总会出现某些地方更具有优势的其他技术进行替代。所以早期的rancher的V1版本作为开源的企业级容器管理工具，其上有多种容器编排模式，例如cattle ,swarm,kubernetes。但随着，k8s势不可挡的逐渐成为主流，rancher应运而生的v2版本，则只保留了k8s的部分。</p><p>rancher，本质上可以看成是k8s更上层的管理框架，除了更加友好的界面和操作，同时，也在k8s的基础上，扩展了一些其不具有的功能如权限管理，日志收集。(详细可以看[知乎]（<a href="https://www.zhihu.com/question/309076492/answer/1150097420">https://www.zhihu.com/question/309076492/answer/1150097420</a>))</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Rancher-k8s初识&quot;&gt;&lt;a href=&quot;#Rancher-k8s初识&quot; class=&quot;headerlink&quot; title=&quot;Rancher+k8s初识&quot;&gt;&lt;/a&gt;Rancher+k8s初识&lt;/h2&gt;&lt;p&gt;8月13号，Docker公司的最新服务条款中明确指出：禁止美国“实体清单”上的实体使用(其中包括华为、奇虎360、科大讯飞等中国IT公司)。让这一时下最流行的容器管理技术，又实实在在的火了一波。所以，今天让我们来看看它的替代品之二：rancher+k8s。(主要笔者还不会docker)&lt;img src=&quot;/images/%E6%8D%82%E8%84%B8%E7%AC%91.jpg&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="容器" scheme="https://zhhw137.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="rancher" scheme="https://zhhw137.github.io/tags/rancher/"/>
    
    <category term="k8s" scheme="https://zhhw137.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>git常用指令总结</title>
    <link href="https://zhhw137.github.io/2020/08/23/git%E6%8C%87%E4%BB%A4/"/>
    <id>https://zhhw137.github.io/2020/08/23/git%E6%8C%87%E4%BB%A4/</id>
    <published>2020-08-23T11:09:39.507Z</published>
    <updated>2020-09-08T01:04:55.569Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/git.png" alt="git"></p><p>在这里记录一些常用的<code>git</code>指令，以及使用时碰到的一些问题及相应的解决办法。</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git init [local repository]</span><br></pre></td></tr></table></figure><h2 id="克隆到本地"><a href="#克隆到本地" class="headerlink" title="克隆到本地"></a>克隆到本地</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure><h2 id="添加变化至暂存区-index"><a href="#添加变化至暂存区-index" class="headerlink" title="添加变化至暂存区(index)"></a>添加变化至暂存区(index)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add *</span><br><span class="line">git commit -m &quot;&lt;commit message&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送到指定的远程分支</span></span><br><span class="line">git push oringin &lt;master&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定远程分支并推送</span></span><br><span class="line">git romete add origin &lt;master&gt;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="分支-branch-相关"><a href="#分支-branch-相关" class="headerlink" title="分支(branch)相关"></a>分支(branch)相关</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git branch # 查看本地分支</span><br><span class="line">git branch -r # 查看远程分支</span><br><span class="line">git branch -a # 查看所有分支</span><br><span class="line"></span><br><span class="line">git checkout -b &lt;dev&gt; # 创建本地分支</span><br><span class="line">git checkout &lt;dev&gt; # 切换到本地分支（没有会根据远程分支创建本地分支）</span><br><span class="line"></span><br><span class="line">git branch -d &lt;dev&gt; # 删除本地分支</span><br><span class="line">git push origin -d &lt;remote_dev&gt; # 删除远程分支</span><br><span class="line"></span><br><span class="line">git push origin &lt;dev&gt; # 推送到远程分支，没有会自动创建</span><br><span class="line"></span><br><span class="line">git checkout [branch name] # 切换分支</span><br></pre></td></tr></table></figure><h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git fetch [origin]</span><br></pre></td></tr></table></figure><h2 id="缓存-stash-相关"><a href="#缓存-stash-相关" class="headerlink" title="缓存(stash)相关"></a>缓存(stash)相关</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br><span class="line">git stash save &#x27;&lt;stash name&gt;&#x27;</span><br><span class="line">git stash show</span><br><span class="line">git stash show -p</span><br><span class="line">git stash apply [@&#123;num&#125;]</span><br><span class="line">git stash pop [@&#123;num&#125;]</span><br><span class="line">git stash drop</span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h2 id="状态-status"><a href="#状态-status" class="headerlink" title="状态(status)"></a>状态(status)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/git.png&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这里记录一些常用的&lt;code&gt;git&lt;/code&gt;指令，以及使用时碰到的一些问题及相应的解决办法。&lt;/p&gt;</summary>
    
    
    
    <category term="杂" scheme="https://zhhw137.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="git" scheme="https://zhhw137.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用规则</title>
    <link href="https://zhhw137.github.io/2020/08/21/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/"/>
    <id>https://zhhw137.github.io/2020/08/21/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/</id>
    <published>2020-08-20T16:00:00.000Z</published>
    <updated>2020-08-22T05:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo使用说明。</p><blockquote><p>更多说明请参考：<a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></p></blockquote><a id="more"></a><h2 id="开启本地服务器"><a href="#开启本地服务器" class="headerlink" title="开启本地服务器"></a>开启本地服务器</h2><p>如果想在本地预览效果，在文件根目录使用<code>git</code>指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s #默认端口4000</span><br><span class="line">hexo s -p 8080 #修改端口号为8080(比如端口被占用的时候)</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:4000/">http://localhost:4000/</a>。</p><p>关闭服务器：<code>Ctrl + C</code>.</p><h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><p>如果你的文段没有正常显示，说明没有解析为静态文件（<code>html</code>），这个时候需要手动解析：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #解析静态文件</span><br><span class="line">hexo generate --deploy #解析并自动部署</span><br><span class="line">hexo g --d #简写形式1</span><br><span class="line">hexo d --g #简写形式2</span><br></pre></td></tr></table></figure><h2 id="一件部署"><a href="#一件部署" class="headerlink" title="一件部署"></a>一件部署</h2><p>在执行部署(提交到<code>github</code>或其他站点)指令前，需要设置根目录配置文件<code>_config.yml</code>：找到<code>deploy</code>字段，修改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/fongzhizhi/fongzhizhi.github.io</span> <span class="comment">#改为你的github仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment">#该仓库的默认分支</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">hexo一键部署</span> <span class="comment">#提交信息</span></span><br></pre></td></tr></table></figure><p>然后执行一件部署指令：<strong>可以选择一下指令之一</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy #清除一些缓存并部署到远程</span><br><span class="line">hexo g --d #解析并部署</span><br></pre></td></tr></table></figure><p>然后过几秒钟，刷新你的站点就能看到效果啦！</p><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>文章都放在<code>source\</code>目录的其他下（根据不同类型放置）。写完记得静态解析，然后再部署。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo使用说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更多说明请参考：&lt;a href=&quot;https://hexo.io/zh-cn/docs&quot;&gt;https://hexo.io/zh-cn/docs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂" scheme="https://zhhw137.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="Hexo" scheme="https://zhhw137.github.io/tags/Hexo/"/>
    
    <category term="说明" scheme="https://zhhw137.github.io/tags/%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
</feed>
