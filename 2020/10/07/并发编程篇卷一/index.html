<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhhw137.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="说明编程本书基于《java并发编程之美》,持续更新中…源码太枯燥了">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程卷一">
<meta property="og:url" content="https://zhhw137.github.io/2020/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87%E5%8D%B7%E4%B8%80/index.html">
<meta property="og:site_name" content="zhhw的Blog">
<meta property="og:description" content="说明编程本书基于《java并发编程之美》,持续更新中…源码太枯燥了">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-07T13:30:00.000Z">
<meta property="article:modified_time" content="2020-11-02T01:34:11.942Z">
<meta property="article:author" content="zhhw">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhhw137.github.io/2020/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87%E5%8D%B7%E4%B8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>并发编程卷一 | zhhw的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="zhhw的Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhhw的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录java学习成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhhw137.github.io/2020/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87%E5%8D%B7%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhhw">
      <meta itemprop="description" content="欢迎联系">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhhw的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并发编程卷一
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-07 21:30:00" itemprop="dateCreated datePublished" datetime="2020-10-07T21:30:00+08:00">2020-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-02 09:34:11" itemprop="dateModified" datetime="2020-11-02T09:34:11+08:00">2020-11-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
            <span id="/2020/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87%E5%8D%B7%E4%B8%80/" class="post-meta-item leancloud_visitors" data-flag-title="并发编程卷一" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87%E5%8D%B7%E4%B8%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87%E5%8D%B7%E4%B8%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>编程本书基于《java并发编程之美》,持续更新中…源码太枯燥了</p>
<a id="more"></a>

<h2 id="并发编程之美"><a href="#并发编程之美" class="headerlink" title="并发编程之美"></a>并发编程之美</h2><h3 id="并发编程线程基础"><a href="#并发编程线程基础" class="headerlink" title="并发编程线程基础"></a>并发编程线程基础</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li><p>线程的创建方式</p>
<ul>
<li>实现Runnable接口的run方法<ul>
<li>优点：接口不占用继承名额</li>
<li>缺点：使用参数不方便，只能使用主线程里面被声明为final的变量</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am a thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    RunableTask task=<span class="keyword">new</span> RunableTask();</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>继承Thread类并重写run方法</p>
<ul>
<li>优点 传参方便，可以自己添加成员变量，通过set或者是构造函数的方法传递参数</li>
<li>缺点  java不支持多继承，占用了继承名额</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am a thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread thread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用FutureTask即Callable接口（这种的有返回值）</p>
<ul>
<li>优点   有返回值</li>
<li>缺点   使用不便</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw InterruptedException</span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallTask());</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        String result=futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>线程通知和等待（Object类方法；线程和共享变量都可以）</p>
<ul>
<li><p>wait()函数</p>
<ul>
<li>使用该共享对象的notify（）或者notifyAll（）方法唤醒。</li>
<li>其他线程调用该线程的interrupt（）方法，该线程抛出InterruptedException异常返回</li>
<li>虚假唤醒：一个线程可以从挂起状态变为可以运行状态（也就是被唤醒），即使该线程没有被其他线程调用notify（）、notifyAll（）方法进行通知，或者被中断，或者等待超时（可以循环验证）；</li>
<li>如果调用wait（）方法的线程没有事先获取该对象的监视器锁，则调用wait（）方法时调用线程会抛出IllegalMonitorStateException异常</li>
<li>调用共享对象的wait方法是，只会释放当前共享对象的锁，不会释放线程持有的其他对象的锁</li>
<li>wait(long timeout)，没有被上述方式唤醒或者中断，则到时间自动返回。wait(0)==wait()</li>
</ul>
</li>
<li><p>notify()</p>
<ul>
<li>随机唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。</li>
<li>被唤醒的线程还需要和其他线程竞争共享变量的监视器锁，只有竞争到了才会继续执行，否则等待</li>
<li>只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify（）方法，否则会抛出IllegalMonitorStateException异常</li>
</ul>
</li>
<li><p>notifyAll()</p>
<ul>
<li>唤醒所有的调用wait（）方法而放入阻塞集合的线程。</li>
</ul>
</li>
</ul>
</li>
<li><p>等待线程执行终止的join方法（Thread类的方法）</p>
<ul>
<li>join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。</li>
<li>join（long timeout）到时间线程开始并行执行。  join()==join(0)</li>
<li>线程A调用线程B的join方法后会被阻塞，当其他线程调用了线程A的interrupt（）方法中断了线程A时，线程A会抛出InterruptedException异常而返回(但是实际线程并没有终止)，这里是在调用那句话的地方抛出异常不执行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread threadOne=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadOne begin&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread mainThread=Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        Thread threadTwo=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                mainThread.interrupt();</span><br><span class="line">                System.out.println(<span class="string">&quot;threadTwo run&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadOne.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main thread:&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>让线程睡眠的sleep方法（Thread类中的静态方法）</p>
<ul>
<li>调用该方法的线程暂时让出指定时间的执行权，也就是在<strong>这段时间不参与CPU调度</strong>，但是该线程所拥有的监视器资源比如锁，不会让出。指定时间到了后函数正常返回，线程处于就绪状态。</li>
<li>在睡眠期间其他线程调用了该线程的interrupt（）方法中断了该线程，则该线程会在调用sleep方法的地方抛出InterruptedException异常而返回。</li>
</ul>
</li>
<li><p>让出CPU执行权的yield方法（Thread类中的静态方法）</p>
</li>
<li><p>调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，<strong>线程调度器下一次调度时就有可能调度到当前线程执行</strong>。</p>
</li>
<li><p>线程中断</p>
<ul>
<li><p>void interrupt()方法:中断线程  </p>
<p>当线程A运行时，线程B可以调用线程A的interrupt（）方法来设置线程A的中断标志为true并立即返回。设置标志仅仅是设置标志，线程A实际并没有被中断，它会继续往下执行。如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起，这时候若线程B调用线程A的interrupt（）方法，线程A会在调用这些方法的地方抛出InterruptedException异常而返回。</p>
</li>
<li><p>boolean isInterrupted（）方法：检测当前线程是否被中断，如果是返回true，否则返回false</p>
</li>
<li><p>boolean interrupted() 方法：检测当前线程是否被中断，如果是返回true，否则返回false。与isInterrupted不同的是，该方法如果发现<strong>当前线程被中断，则会清除中断标志</strong>，并且该方法是static方法，可以通过Thread类直接调用。如下图代码，所以这个方法总是判断的<strong>当前线程</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程上下文切换（CPU采用时间片轮转策略）</p>
<ul>
<li>当前线程的CPU时间片使用完</li>
<li>当前线程被其他线程打断时</li>
</ul>
</li>
<li><p>死锁(一般用资源的有序性破坏死锁)</p>
<ul>
<li>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去</li>
<li>操作系统层面的4个条件<ul>
<li>互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源</li>
<li>请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源</li>
<li>不可剥夺条件:指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源</li>
<li>环路等待条件:指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0, T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源</li>
</ul>
</li>
</ul>
</li>
<li><p>守护线程与用户线程</p>
<ul>
<li><p>JVM会自动启动一个叫作DestroyJavaVM的线程，该线程会等待所有用户线程结束后终止JVM进程</p>
</li>
<li><p>子线程的生命周期不受父线程的影响。（因此设置子线程是守护线程还是用户线程能控制，程序执行完成后这个子线程是否还要继续执行）</p>
</li>
<li><p>daemon线程（守护线程）</p>
<ul>
<li><p>不管当前是否有守护线程，当最后一个非守护线程结束时，JVM正常退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread daemonThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>user线程（用户线程）</li>
</ul>
<ul>
<li>ThreadLocal<ul>
<li>Thread类中有threadLocals和inheritableThreadLocals，他们都是ThreadLocalMap类型的变量（定制化的Hashmap）<ul>
<li>void set（T value）  设置值到map中，key为当前线程</li>
<li>T get（） 获取当前线程作为key对应的值</li>
<li>void remove（） 清除ThreadLocal的本地变量</li>
</ul>
</li>
<li>InheritableThreadLocal类解决ThreadLocal类不支持继承的问题</li>
</ul>
</li>
</ul>
<h4 id="Java程序"><a href="#Java程序" class="headerlink" title="Java程序"></a>Java程序</h4><ul>
<li>共享变量内存可见性     线程有自己的工作内存，互相之间不可见，可能导致数据的异常，和主内存间数据不一致<ul>
<li>synchronized  可以解决，但是会造成线程上下文切换开销   锁方法进而锁对象</li>
<li>volatile   给变量加保证变量可见性</li>
</ul>
</li>
<li>原子性<ul>
<li>synchronized  可以解决原子性，但是降低并发性</li>
<li>CAS   compareAndSwap   比较并交换   存在ABA问题   JDK中用AtomicStampedReference类给每个变量的状态值配备一个时间戳，避免ABA问题。<ul>
<li>对象内存位置</li>
<li>对象中的变量的偏移量</li>
<li>变量预期值</li>
<li>新的值</li>
</ul>
</li>
</ul>
</li>
<li>Unsafe类 提供的都是native方法，直接操作内存的<ul>
<li>boolean compareAndSwapLong（Object obj, long offset, longexpect, long update）方法：比较对象obj中偏移量为offset的变量的值是否与expect相等，相等则使用update值更新，然后返回true，否则返回false。</li>
</ul>
</li>
<li>指令重排序</li>
<li>伪共享<ul>
<li>出现伪共享的原因：因为从主内存读入二级缓存时会一次性读取一个缓存行大小数据。比如读入1，可能后面带上2,3,4,5。</li>
<li>造成现象：变量x和y同时被放到了CPU的一级和二级缓存，当线程1使用CPU1对变量x进行更新时，首先会修改CPU1的一级缓存变量x所在的缓存行，这时候在缓存一致性协议下，CPU2中变量x对应的缓存行失效。那么线程2在写入变量x时就只能去二级缓存里查找，这就破坏了一级缓存。而一级缓存比二级缓存更快，这也说明了多个线程不可能同时去修改自己所使用的CPU中相同缓存行里面的变量。更坏的情况是，如果CPU只有一级缓存，则会导致频繁地访问主内存</li>
<li>sun.misc.Contended<strong>注解修饰类和变量</strong>  @Contended注解只用于Java核心类，比如rt包下的类。如果用户类路径下的类需要使用这个注解，则需要添加JVM参数：-XX:-RestrictContended。填充的宽度默认为128，要自定义宽度则可以设置-XX:ContendedPaddingWidth参数。</li>
</ul>
</li>
<li>锁<ul>
<li>加锁时机<ul>
<li>乐观锁：它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测</li>
<li>悲观锁：对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁</li>
</ul>
</li>
<li>获取锁抢占机制<ul>
<li>公平锁：公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁</li>
<li>非公平锁：而非公平锁则在运行时闯入，也就是先来不一定先得。</li>
</ul>
</li>
<li>持有锁线程个数<ul>
<li>独占锁：保证任何时候都只有一个线程能得到锁（悲观锁，读取也是一个时间只能有一个线程）</li>
<li>共享锁：可以同时由多个线程持有（读的时候可以多个线程）</li>
</ul>
</li>
<li>一个线程是否可以反复获得锁：<ul>
<li>可重入锁：即为锁是否有线程标识，有的可以重入，每次获得锁 就是标识+1，到0释放锁，线程标识置为null。</li>
<li>不可重入锁：自己再次获取线程阻塞</li>
</ul>
</li>
<li>自旋锁<ul>
<li>线程的挂起和唤醒都要由用户态切换到内核态，状态切换浪费时间影响效率。（java线程与cpu线程是一一对应的导致的）</li>
<li>当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取（默认次数是10，可以使用-XX:PreBlockSpinsh参数设置该值）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="并发编程高级"><a href="#并发编程高级" class="headerlink" title="并发编程高级"></a>并发编程高级</h3><h4 id="并发编程中的常用类"><a href="#并发编程中的常用类" class="headerlink" title="并发编程中的常用类"></a>并发编程中的常用类</h4><ul>
<li><p>ThreadLocalRandom</p>
<ul>
<li>原因：java.util.Random是通过使用上一个种子重新按照固定规则计算下一个种子返回。为了防止多线程取到同一个旧种子而产生同一个新随机数，使用CAS自旋</li>
<li>类原理：针对原因，用threadlocal的原理解决，即将种子保存在线程的本地变量中，即threadLocalRandomSeed</li>
</ul>
</li>
<li><p>Atomic类 原子操作类，使用unsafe自旋保证原子性</p>
<ul>
<li><p>LongAdder类（AtomicLong类的改进），只能new一个默认为0的值，用add等方法赋值</p>
</li>
<li><p>里面 有base；Cells[]；cellsBusy；</p>
<ul>
<li>base  并发量不大的情况下就是value，等同于AtomicLong 的用法</li>
<li>高并发下，采用cells数组，各个线程获得一个cell变量（初始化，扩容等等），一个cell自增，最终的值是所有的cell+value</li>
<li>cellsBusy用来做自旋锁，状态值只有0和1，当创建Cell元素，扩容Cell数组或者初始化Cell数组时，使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。</li>
</ul>
</li>
<li><p>LongAdder类是LongAccumulator的特列，LongAccumulator可以从非0开始，同时可以指定累加规则（LongAdder只能默认为初始0，相加进行累加）</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, ExecutionException, InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LongAdder longAdder=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LongAdder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        longAdder.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        longAdder.add(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LongBinaryOperator addStr = (n1, n2) -&amp;gt; n1 * n2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LongAccumulator longAccumulator=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LongAccumulator(addStr,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        longAccumulator.accumulate(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(longAdder+&lt;span class=&quot;string&quot;&gt;&amp;quot;......&amp;quot;&lt;/span&gt;+longAccumulator);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>CopyOnWriteArrayList</p>
<ul>
<li>初始化  <ul>
<li>无参构造函数   创造大小为0的Object数组</li>
<li>有参构造函数   集合或者数组，复制生成一个array存</li>
</ul>
</li>
<li>添加元素<ul>
<li>先获取独占锁    保证原子性</li>
<li>添加元素时，是进行复制快照后，处理快照，而不是在原来的数组上进行</li>
</ul>
</li>
<li>获取元素<ul>
<li>方法没有进行加锁</li>
<li>所有更新数组的操作会加锁，然后复制快照操作快照，再更换数组指向。多线程时，因为获取元素线程之前的引用导致指向之前的引用计数为1，不会删除，仍然指向之前的数组。所以仍然能获得数。（写时复制策略产生的弱一致性问题）</li>
</ul>
</li>
<li>修改元素<ul>
<li>首先获取了独占锁，从而阻止其他线程对array数组进行修改，然后获取当前数组，并调用get方法获取指定位置的元素，如果指定位置的元素值与新值不一致则创建新数组并复制元素，然后在新数组上修改指定位置的元素值并设置新数组到array。如果指定位置的元素值与新值一样，则为了保证volatile语义，还是需要重新设置array，虽然array的内容并没有改变。</li>
</ul>
</li>
<li>删除元素<ul>
<li>首先获取独占锁以保证删除数据期间其他线程不能对array进行修改，然后获取数组中要被删除的元素，并把剩余的元素复制到新数组，之后使用新数组替换原来的数组，最后在返回前释放锁</li>
</ul>
</li>
<li>迭代弱一致性<ul>
<li>迭代的时候指向旧数组，这样其他操作数组的都是复制了快照，然后将数组引用指向新数组，所以使用迭代器元素时，其他线程对该list进行的增删改不可见。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="并发包中的锁"><a href="#并发包中的锁" class="headerlink" title="并发包中的锁"></a>并发包中的锁</h4><ul>
<li>LockSupport工具类 （每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport类的方法的线程是不持有许可证的）<ul>
<li>void park()<ul>
<li>如果调用该方法的线程已经获得了LockSupport的许可证（LockSupport.unpark(Thread.currentThread()) 比如调用这个方法就会获得该有的许可证），则直接返回</li>
<li>没有许可证，线程阻塞挂起</li>
<li>其他线程调用unpark（Thread thread）方法并将当前线程作为参数可以让阻塞线程返回</li>
<li>如果其他线程调用了阻塞线程的interrupt（）方法，设置了中断标志或者线程被虚假唤醒，则阻塞线程也会返回</li>
<li>因调用park（）方法而被阻塞的线程被其他线程中断而返回时并不会抛出InterruptedException异常。</li>
</ul>
</li>
<li>void unpark(Thread thread)<ul>
<li>如果传入的线程没有阻塞挂起，让参数传入的线程获得许可</li>
<li>如果传入的线程阻塞挂起了，唤醒该线程</li>
</ul>
</li>
<li>void parkNanos（long nanos）类似于park，只是多了时间参数，到达时间后自动唤醒</li>
<li>void park（Object blocker）当线程在没有持有许可证的情况下调用park方法而被阻塞挂起时，这个blocker对象会被记录到该线程内部。诊断工具是通过调用getBlocker（Thread）方法来获取blocker对象的</li>
<li>void parkUntil(Object blocker, long  deadline)方法   记录阻塞原因，再加上到哪个时间点，这个时间点相较于1970年计算的。可以让线程具体到某个时间而不是相对时间了</li>
<li>void parkNanos(Object blocker, long  nanos)方法  记录阻塞原因，再加上阻塞时间长短</li>
</ul>
</li>
</ul>
<h4 id="抽象同步队列"><a href="#抽象同步队列" class="headerlink" title="抽象同步队列"></a>抽象同步队列</h4><ul>
<li><p>AQS   （AbstractQueuedSynchronizer）</p>
<ul>
<li><p>是一个FIFO双向队列：通过节点head 和tail记录队首和队尾（Node类型）</p>
</li>
<li><p>state 单一状态信息state，实现类根据不同功能使用</p>
</li>
<li><p>Node（静态内部类）</p>
<ul>
<li>prev记录当前节点的前驱节点</li>
<li>next记录当前节点的后继节点</li>
<li>thread变量   存放进入AQS队列的线程</li>
<li>shared变量   用来标记该线程是获取共享资源时被阻塞挂起后放入AQS队列的</li>
<li>exclusive变量  用来标记线程是获取独占资源被挂起后放入AQS队列的</li>
<li>waitStatus变量  记录当前线程等待状态，可以为可以为<ul>
<li>CANCELLED（线程被取消了）</li>
<li>SIGNAL（线程需要被唤醒）</li>
<li>CONDITION（线程在条件队列里面等待）</li>
<li>PROPAGATE（释放共享资源时需要通知其他节点）</li>
</ul>
</li>
</ul>
</li>
<li><p>ConditionObject(内部类)   每个条件变量对应一个条件队列（单向链表队列），其用来存放调用条件变量的await方法（AQS中的方法）后被阻塞的线程，其内部方法包括加入该队列和唤醒线程删除队列，该队列的头尾分别为firstWaiter和lastWaiter</p>
</li>
<li><p>线程同步的关键是对状态值state进行的操作（具体的tryAcquire和tryRelease方法，需要由具体的子类实现）</p>
<ul>
<li>独占方式下     根据state是否属于一个线程（调用方法中给获得资源的线程标记）<ol>
<li>void acquire(int arg)<ul>
<li>会首先使用tryAcquire方法尝试获取资源，具体是设置状态变量state的值，成功则直接返回</li>
<li>失败则将当前线程封装为类型为Node.EXCLUSIVE的Node节点后插入到AQS阻塞队列的尾部，并调用LockSupport.park（this）方法挂起自己</li>
</ul>
</li>
<li>void acquireInterruptibly(int arg)<ul>
<li>同上面步骤，区别在会对其他线程的中断反应，抛出InterruptedExcepiton异常而返回</li>
</ul>
</li>
<li>boolean release(int arg)<ul>
<li>尝试使用tryRelease操作释放资源，这里是设置状态变量state的值，然后调用LockSupport.unpark（thread）方法激活AQS队列里面被阻塞的一个线程（thread）。</li>
<li>被激活的线程则使用tryAcquire尝试，看当前状态变量state的值是否能满足自己的需要，满足则该线程被激活，然后继续向下运行</li>
<li>否则还是会被放入AQS队列并被挂起</li>
</ul>
</li>
</ol>
</li>
<li>共享方式下（与具体线程不相关，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用CAS方式进行获取即可。比如Semaphore信号量，当一个线程通过acquire（）方法获取信号量时，会首先看当前信号量个数是否满足需要，不满足则把当前线程放入阻塞队列，如果满足则通过自旋CAS获取信号量）<ol>
<li>void acquireShared(int arg)<ul>
<li>会首先使用tryAcquireShared尝试获取资源，具体是设置状态变量state的值，成功则直接返回</li>
<li>失败则将当前线程封装为类型为Node.SHARED的Node节点后插入到AQS阻塞队列的尾部，并使用LockSupport.park（this）方法挂起自己。</li>
</ul>
</li>
<li>void acquireSharedInterruptibly(int arg)<ul>
<li>同上面步骤，区别在会对其他线程的中断反应，抛出InterruptedExcepiton异常而返回</li>
</ul>
</li>
<li>boolean releaseShared(int arg)<ul>
<li>会尝试使用tryReleaseShared操作释放资源，这里是设置状态变量state的值，然后使用LockSupport.unpark（thread）激活AQS队列里面被阻塞的一个线程（thread）。</li>
<li>被激活的线程则使用tryReleaseShared查看当前状态变量state的值是否能满足自己的需要，满足则该线程被激活，然后继续向下运行</li>
<li>否则还是会被放入AQS队列并被挂起</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>入队操作：当一个线程获取锁失败后该线程会被转换为Node节点，然后就会使用enq（final Node node）方法将该节点插入到AQS的阻塞队列</p>
</li>
<li><p>条件变量（感觉上没有实际含义，就是个序号一样）</p>
<p>下代码可以看出，一个锁对应一个AQS阻塞队列，对应多个条件变量，每个条件变量有自己的一个条件队列。（就是根据await和signal从阻塞队列和对应条件队列里切换，而不是让其一直CAS自旋竞争锁浪费时间）</p>
<ul>
<li>当多个线程同时调用lock.lock（）方法获取锁时，只有一个线程获取到了锁，其他线程会被转换为Node节点插入到lock锁对应的<strong>AQS阻塞队列</strong>里面，并做自旋CAS尝试获取锁</li>
<li>取到锁的线程又调用了对应的条件变量的await（）方法，则该线程会释放获取到的锁，并被转换为Node节点插入到<strong>条件变量对应的条件队列</strong>里面</li>
<li>因为调用lock.lock（）方法被阻塞到AQS队列里面的一个线程会获取到被释放的锁，如果该线程也调用了条件变量的await（）方法则该线程也会被放入条件变量的条件队列里面</li>
<li>另外一个线程调用条件变量的signal（）或者signalAll（）方法时，会把条件队列里面的一个或者全部Node节点移动到AQS的阻塞队列里面，等待时机获取锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition=lock.newCondition();</span><br><span class="line">    Condition condition2=lock.newCondition();</span><br><span class="line">    Thread thread2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始唤醒&quot;</span>);</span><br><span class="line">                condition2.signal();</span><br><span class="line">                System.out.println(<span class="string">&quot;唤醒结束&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread.start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>独占锁ReentrantLock原理</p>
<ul>
<li><p>非公平锁（NonfairSync子类实现）</p>
<ul>
<li>这里因为没有顺序的处理，存在别的线程调用lock（）执行代码,锁还未释放，别的调用lock（）方法时锁释放了的时间差</li>
<li>当前锁没有被其他线程持有,标记当前线程持有，state从0设置成1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>可重入锁实现:识别到是同一个线程，则状态值加1，然后返回true，这里需要注意，nextc&lt;0说明可重入次数溢出了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(current == getExclusiveOwnerThread())&#123;</span><br><span class="line">    <span class="keyword">int</span> nextc=getState()+acquires;</span><br><span class="line">    <span class="keyword">if</span>(nextc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>公平锁（FairSync子类实现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Node t=tail;</span><br><span class="line">       Node h=head;</span><br><span class="line">       Node s;</span><br><span class="line">       <span class="keyword">return</span> h!=t &amp;&amp; ((s = h.next)==<span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些方法</p>
<ul>
<li>boolean tryLock() 方法 尝试获取锁</li>
<li>boolean tryLock(long timeout, TimeUnitunit) 方法 尝试获取锁，与tryLock（）的不同之处在于，它设置了超时时间，如果超时时间到没有获取到该锁则返回false。</li>
</ul>
</li>
</ul>
</li>
<li><p>读写锁ReentrantReadWriteLock原理</p>
<ul>
<li>依赖Sync同样实现公平锁和非公平锁</li>
<li>巧妙地使用state的高16位表示读状态，也就是获取到读锁的次数；使用低16位表示获取到写锁的线程的可重入次数</li>
<li>写锁WriteLock这个静态内部类实现是独占锁和可重入锁（读锁也会影响写锁）总的来说类似于ReentrantReadWriteLock</li>
<li>读锁ReadLock这个静态内部类实现是共享锁（但是会受到写锁影响）。<ul>
<li>如果当前锁没有线程获得，返回true获得锁、</li>
<li>如果有线程获得了写锁，本线程持有的写锁，也可以获取锁，但是释放的时候记得俩个锁都释放；不是本线程持有的写锁，返回false</li>
<li>没有线程持有写锁，获取读锁的个数</li>
<li>如果队列里面存在一个元素，则判断第一个元素是不是正在尝试获取写锁，如果不是，则当前线程判断当前获取读锁的线程是否达到了最大值</li>
<li>记录第一个获取读锁的线程并统计该线程获取读锁的可重入数</li>
<li>记录最后一个获取到读锁的线程和该线程获取读锁的可重入数，readHolds记录了当前线程获取读锁的可重入数</li>
</ul>
</li>
</ul>
</li>
<li><p>StampedLock（不可重入锁；不是直接实现Lock或ReadWriteLock接口，在内部自己维护了一个双向阻塞队列；非公平锁）（获取乐观读锁时只是检测状态，不需要CAS提升了效率）</p>
<ul>
<li>写锁writeLock：是一个排它锁或者独占锁，某时只有一个线程可以获取该锁，当一个线程获取该锁后，其他请求读锁和写锁的线程必须等待，这类似于ReentrantReadWriteLock的写锁（不同的是这里的写锁是不可重入锁）；当目前没有线程持有读锁或者写锁时才可以获取到该锁。请求该锁成功后会返回一个stamp变量用来表示该锁的版本，当释放该锁时需要调用unlockWrite方法并传递获取锁时的stamp参数。并且它提供了非阻塞的tryWriteLock方法。</li>
<li>悲观读锁readLock：是一个共享锁，在没有线程获取独占写锁的情况下，多个线程可以同时获取该锁。如果已经有线程持有写锁，则其他线程请求获取该读锁会被阻塞，这类似于ReentrantReadWriteLock的读锁（不同的是这里的读锁是不可重入锁）。这里说的悲观是指在具体操作数据前其会悲观地认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在读少写多的情况下的一种考虑。请求该锁成功后会返回一个stamp变量用来表示该锁的版本，当释放该锁时需要调用unlockRead方法并传递stamp参数。并且它提供了非阻塞的tryReadLock方法。</li>
<li>乐观读锁tryOptimisticRead：它是相对于悲观锁来说的，在操作数据前并没有通过CAS设置锁的状态，仅仅通过位运算测试。如果当前没有线程持有写锁，则简单地返回一个非0的stamp版本信息。获取该stamp后在具体操作数据前还需要调用validate方法验证该stamp是否已经不可用，也就是看当调用tryOptimisticRead返回stamp后到当前时间期间是否有其他线程持有了写锁，如果是则validate会返回0，否则就可以使用该stamp版本的锁对数据进行操作。由于tryOptimisticRead并没有使用CAS设置锁状态，所以不需要显式地释放该锁。该锁的一个特点是适用于读多写少的场景，因为获取读锁只是使用位操作进行检验，不涉及CAS操作，所以效率会高很多，但是同时由于没有使用真正的锁，在保证数据一致性上需要复制一份要操作的变量到方法栈，并且在操作数据时可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。</li>
<li>StampedLock还支持这三种锁在一定条件下进行相互转换。例如long tryConvertToWriteLock（long stamp）期望把stamp标示的锁升级为写锁，这个函数会在下面几种情况下返回一个有效的stamp（也就是晋升写锁成功）：<ul>
<li>当前锁已经是写锁模式了。 </li>
<li>当前锁处于读锁模式，并且没有其他线程是读锁模式</li>
<li>当前处于乐观读模式，并且当前写锁可用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="并发队列原理"><a href="#并发队列原理" class="headerlink" title="并发队列原理"></a>并发队列原理</h4><ul>
<li><p>offer、poll、take、put等方法源码</p>
</li>
<li><p>ConcurrentLinkedQueue   </p>
<ul>
<li>线程安全的无界非阻塞队列</li>
<li>单向链表实现；出入队使用CAS实现原子性</li>
<li>volatile修饰tail、head节点保证可见性</li>
<li>size和contains，remove等方法不准，因为当时获得10，可能CAS过程中别的线程有删除</li>
</ul>
</li>
<li><p>LinkedBlockingQueue</p>
<ul>
<li>独占锁实现的有界阻塞队列</li>
<li>单链表实现：head、last表示首尾节点。初始值为0的count变量记录元素个数</li>
<li>使用takeLock和putLock俩个独占锁（ReentrantLock实例），控制元素入队和出队的原子性</li>
<li>notEmpty和notFull是条件变量，内部有一个条件队列用来存放进队和出队时被阻塞的线程</li>
<li>构造方法俩种，无参的默认队列容量Integer.MAX_VALUE，有参的只有一个int参数，为自定义的队列容量。</li>
<li>俩个锁分别控制入队和出队，所以可以并行，内部逻辑中都有count变量的++或者–，但是同类操作同时只能一个，保证了类似于count&gt;0这样的操作不会因为别的线程调用了poll、take、remove等而导致刚过来校验又不符合了。</li>
</ul>
</li>
<li><p>ArrayBlockingQueue</p>
<ul>
<li>独占锁实现的有界阻塞队列</li>
<li>有界数组方式实现：数组item存放队列，putindex表示入队元素下标，takeIndex表示出队下标，count统计队列元素个数。</li>
<li>有个独占锁lock用来保证出、入队操作的原子性</li>
<li>notEmpty和notFull是条件变量，内部有一个条件队列用来存放进队和出队时被阻塞的线程</li>
<li>构造方法必须传入int 类型capacity，同时只有一个独占锁，另一个构造函数支持boolean类型参数，决定使用公平锁还是非公平锁，默认false非公平锁</li>
</ul>
</li>
<li><p>PriorityBlockingQueue</p>
<ul>
<li>带优先级（根据compareTo排序）的无界阻塞队列</li>
<li>数组queue存放队列元素，size存放队列元素个数。</li>
<li>allocationSpinLock是个自旋锁，其使用CAS操作来保证同时只有一个线程可以扩容队列，状态为0或者1，其中0表示当前没有进行扩容，1表示当前正在扩容</li>
<li>由于这是一个优先级队列，所以有一个比较器comparator用来比较元素大小</li>
<li>有个独占锁lock用来保证出、入队操作的原子性</li>
<li>notEmpty条件变量用来实现take方法阻塞模式</li>
</ul>
</li>
<li><p>DelayQueue</p>
<ul>
<li>无界阻塞延迟队列</li>
<li>DelayQueue内部使用PriorityQueue存放数据，使用ReentrantLock实现线程同步。另外，队列里面的元素要实现Delayed接口，由于每个元素都有一个过期时间，所以要实现获知当前元素还剩下多少时间就过期了的接口，由于内部使用优先级队列来实现，所以要实现元素之间相互比较的接口；available条件队列存储阻塞等待的队列</li>
</ul>
</li>
</ul>
<h4 id="并发包中线程池ThreadPoolExecutor"><a href="#并发包中线程池ThreadPoolExecutor" class="headerlink" title="并发包中线程池ThreadPoolExecutor"></a>并发包中线程池ThreadPoolExecutor</h4>
    </div>

    
    
    
        <div class="reward-container">
  <div>谢谢你请我吃糖!</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="zhhw 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhhw 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 多线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/14/JVM%E7%AF%87/" rel="prev" title="JVM">
      <i class="fa fa-chevron-left"></i> JVM
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/15/redis%E7%AF%87/" rel="next" title="Redis">
      Redis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E"><span class="nav-number">2.</span> <span class="nav-text">并发编程之美</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">并发编程线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">Java程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7"><span class="nav-number">2.2.</span> <span class="nav-text">并发编程高级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">并发编程中的常用类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E9%94%81"><span class="nav-number">2.2.2.</span> <span class="nav-text">并发包中的锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">抽象同步队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.4.</span> <span class="nav-text">并发队列原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor"><span class="nav-number">2.2.5.</span> <span class="nav-text">并发包中线程池ThreadPoolExecutor</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhhw</p>
  <div class="site-description" itemprop="description">欢迎联系</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhhw137" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhhw137" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:13717737201@163.com" title="Mail → mailto:13717737201@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020/8 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhhw</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">182k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:45</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'KgdHuT3kltgIrgNT6o76hovl-gzGzoHsz',
      appKey     : '6phircWV4C7FajDWFXruKbr9',
      placeholder: "不说点啥？",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
