<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhhw137.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="说明本章节根据《Redis设计与实现》和笔者自身理解所写">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://zhhw137.github.io/2020/10/15/redis%E7%AF%87/index.html">
<meta property="og:site_name" content="zhhw的Blog">
<meta property="og:description" content="说明本章节根据《Redis设计与实现》和笔者自身理解所写">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-15T13:30:00.000Z">
<meta property="article:modified_time" content="2020-11-02T01:17:26.351Z">
<meta property="article:author" content="zhhw">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhhw137.github.io/2020/10/15/redis%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis | zhhw的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="zhhw的Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhhw的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录java学习成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhhw137.github.io/2020/10/15/redis%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhhw">
      <meta itemprop="description" content="欢迎联系">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhhw的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-15 21:30:00" itemprop="dateCreated datePublished" datetime="2020-10-15T21:30:00+08:00">2020-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-02 09:17:26" itemprop="dateModified" datetime="2020-11-02T09:17:26+08:00">2020-11-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <span id="/2020/10/15/redis%E7%AF%87/" class="post-meta-item leancloud_visitors" data-flag-title="Redis" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/15/redis%E7%AF%87/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/15/redis%E7%AF%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本章节根据《Redis设计与实现》和笔者自身理解所写</p>
<a id="more"></a>

<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li>定义：SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;<span class="comment">//记录buf数组中已使用的字节的数量，也就是sds所保存的字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;<span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">char</span> buf[];<span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>redis的字符串也就是sds的特殊<ul>
<li>O(1)复杂度获得长度</li>
<li>杜绝缓冲区溢出（因为知道长度，可以先检测下，不够扩容）</li>
<li>空间预分配：扩展SDS空间前，判断free空间是否足够，足够会直接使用而无须执行内存重分配<ul>
<li>处理后SDS大小大于1MB，则预分配1MB到free（未使用空间）</li>
<li>处理后SDS大小不大于1MB，则预分配同样大小到free空间。</li>
</ul>
</li>
<li>惰性空间释放<ul>
<li>执行SDS缩短操作时不会释放空间，而是转到free空间记录。等待下次使用。避免了缩短字符串的所需的内存重分配</li>
<li>提供API释放SDS的未使用空间，避免内存浪费</li>
</ul>
</li>
<li>二进制安全：使用len来判断字符串是否结束，避免了像C语言那样，因为空字符而提前结束。所以redis可以保存任意格式的二进制数据</li>
<li>兼容部分C语言函数：因为SDS也以空字符作为结尾，所以可以兼容</li>
</ul>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p>定义</p>
<ul>
<li><p>链表节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span><span class="comment">//前置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span><span class="comment">//后置节点</span></span><br><span class="line"><span class="keyword">void</span> *value;<span class="comment">//节点的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    listNode *head;<span class="comment">//表头节点</span></span><br><span class="line">    listNode *tail;<span class="comment">//表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;<span class="comment">//链表包含的节点数量</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);<span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);<span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);<span class="comment">//节点值对比函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>特性</p>
<ul>
<li>双端：链表节点有next和pre指针，获取某个节点的前置节点和后置节点时间复杂度O(1)</li>
<li>无环：表头节点的pre指针和表尾节点的next指针都指向null，对链表的访问以null为终点</li>
<li>带表头指针和表尾指针：通过list结构的head和tail指针，获取表头节点和表尾节点的时间复杂度O(1)</li>
<li>带链表长度计数器：程序使用len属性，对list结构持有的链表节点数进行计数</li>
<li>多态：链表节点使用void*指针保存节点值，并且可以通过list结构的dup，free，match三个属性为节点值设置类型特定函数（根据不同类型都有一套方法实现），所以链表可以用于保存各种不同类型的值。</li>
</ul>
</li>
</ul>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ul>
<li><p>定义：字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。</p>
<ul>
<li><p>哈希表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    dictEntry **table;<span class="comment">//哈希表数组</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;<span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">//哈希表大小掩码，用于计算索引值 总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>哈希表节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;   <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v; <span class="comment">//值，3选一，可以是对象，或者uint64_t整数，或者int64_t整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//指向下个哈希表节点，形成链表。类似于map，用以解决键冲突问题。</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type; <span class="comment">//类型特定函数：保存一簇用于操作特定类型键值对的函数，针对不同类型的键值对，为创建多态字典而设置。为不同的字典设置不同的类型特定函数。</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">//私有数据：保存需要传给那些类型特定函数的可选参数</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">//哈希表：一般使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">//rehash索引，当rehash不在进行时，值为-1；记录rehash目前的进度.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型特定函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictype</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2) <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDestructor)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDestructor)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);<span class="comment">//销毁值的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>哈希算法：先计算哈希值，再计算索引值，再放在指定索引上面</p>
</li>
<li><p>键冲突：头插法的链地址法解决冲突</p>
</li>
<li><p>rehash（重新散列）（理论）</p>
<ul>
<li>ht[1]哈希表分配空间：<ul>
<li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n（2的n次方幂）</li>
<li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n（2的n次方幂</li>
</ul>
</li>
<li>将ht[0]中的所有键值对rehash到ht[1]上面（即重新计算键的哈希值和索引值，然后放到ht[1]的指定位置上）</li>
<li>释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]上新创建一个空白哈希表（没有分配空间），为下一次rehash做准备。</li>
<li>负载因子计算公式：load_factor=ht[0].used/ht[0].size    负载因子=哈希表已保存节点数/哈希表大小</li>
<li>哈希表自动扩展触发条件：<ul>
<li>服务器没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1.</li>
<li>服务器正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5.</li>
</ul>
</li>
<li>哈希表自动收缩触发条件：负载因子小于0.1</li>
</ul>
</li>
<li><p>渐进式rehash（实际）（避免了集中rehash带来的庞大计算量）（这一时期的删查改在俩个哈希表中进行，但是增加只在ht[1]中）</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]俩个哈希表。</li>
<li>在字典中维持一个索引计数器变量，rehashidx,并设置为0，标识rehash工作正式开始</li>
<li>在rehash进行期间，每次对字典执行增删改查时，程序除了执行指定操作以外，还会顺带将rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li>
<li>随着字典操作不断执行，最终某个节点，ht[0]所有键值对都rehash到ht[1]上了，这时将rehashidx设置为-1。标识rehash完成。</li>
</ol>
</li>
</ul>
<h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><ul>
<li><p>定义：是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的，时间复杂度O（logN）。只在redis里俩个地方运用:一个是实现有序集合键(如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现)，另一个是在集群节点中用作内部数据结构</p>
<ul>
<li>跳跃表节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">//前进指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;<span class="comment">//跨度：用于记录俩个节点之间的距离，跨度越大相距越远，指向null的前进指针跨度为0.</span></span><br><span class="line">    &#125;<span class="comment">//层（类似于抽取关键词，方便快速查找）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> *<span class="title">backward</span>;</span><span class="comment">//后退指针</span></span><br><span class="line">    <span class="keyword">double</span> score;<span class="comment">//分值是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序（分值相同时，按照对象排序，小的在前）</span></span><br><span class="line">    robj *obj;<span class="comment">//成员对象是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值（唯一）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>跳跃表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    structz skiplistNode *header,*tail;<span class="comment">//表头和表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;<span class="comment">//表中节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> level;<span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><ul>
<li><p>定义：是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;<span class="comment">//编码方式：INTSET_ENC_INT16，INTSET_ENC_INT32，INTSET_ENC_INT64</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;<span class="comment">//元素数量</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];<span class="comment">//不重复的整数集合，数值按从小到大有序排列，实际值类型，按照encoding设定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>升级（每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade）就是进行编码方式的升级，从而导致整个整数集合升级）</p>
<ul>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
</li>
<li><p>升级的好处</p>
<ul>
<li>提升灵活性：不用担心存放数据的类型</li>
<li>节约内存:只有必要的时候才进行升级，使用打的编码表示小的数。（在保持灵活性的情况下，不然的话数据结构会比较复杂）</li>
</ul>
</li>
</ul>
<h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><ul>
<li><p>定义：<strong>列表键和哈希键的底层实现之一</strong>，压缩列表是Redis<strong>为了节约内存而开发的</strong>，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>
<ul>
<li>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</li>
<li>当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</li>
</ul>
</li>
<li><p>构成</p>
<ul>
<li><p>压缩列表</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录整个压缩列表占用的内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址字节数，这个偏移量，定位表尾节点地址</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2字节</td>
<td>记录压缩列表包含的节点数量，这个值小于UINT6_MAX(65535)时其值即为节点数量，等于时，需要遍历整个压缩列表计算</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1字节</td>
<td>特殊值0xFF(255),用于标记压缩列表的末端</td>
</tr>
</tbody></table>
</li>
<li><p>压缩列表节点</p>
<ul>
<li>previous_entry_length（因为存的是前一个字节的长度，如果我们有一个指向当前节点起始地址的指针c，那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针p，从表尾向表头遍历操作使用这一原理实现的）<ul>
<li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面</li>
<li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面</li>
</ul>
</li>
<li>encoding：记录了节点的content属性所保存数据的类型以及长度<ul>
<li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录</li>
<li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录</li>
</ul>
</li>
<li>content：负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定</li>
</ul>
</li>
<li><p>连锁更新</p>
<ul>
<li>表头添加个长度大于等于254字节的节点，导致后面本来previous_entry_length为1字节的节点，变为4字节，需要对压缩列表执行空间重分配操作，以此类推，程序不断地执行空间重分配操作。此为连锁更新（删除节点同理也可以导致连锁更新）</li>
<li>尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：<ul>
<li>❑首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li>
<li>❑其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li><p>定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;<span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;<span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">int</span> refcount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;<span class="comment">//对象最后一次被命令程序访问的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>type类型(键总是一个字符串对象，值才是type的各种对象)</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
</tr>
</tbody></table>
</li>
<li><p>encoding记录对象所使用的编码，也就是决定数据结构的底层实现</p>
<p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_ENCODING_INT</td>
<td>long类型的整数</td>
<td>字符串可用</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串</td>
<td>字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
<td>字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
<td>哈希、集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
<td>列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
<td>列表、哈希、有序集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
<td>集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
<td>有序集合</td>
</tr>
</tbody></table>
</li>
<li><p>ptr内容，用具体的数据结构实现</p>
</li>
<li><p>字符串对象是唯一一种会被其他四种类型对象嵌套的对象</p>
</li>
</ul>
</li>
<li><p>字符串对象 （编码：int，embstr，raw）</p>
<ul>
<li>3种结构的区别<ul>
<li>如果一个字符串对象保存的是<strong>整数值</strong>，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int</li>
<li>可以用long double类型表示的<strong>浮点数</strong>在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值</li>
<li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw</li>
<li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li>
<li>embstr编码是专门用于保存短字符串的一种优化编码方式，相较于raw，内存分配、释放从俩次降低为一次，embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以更好地利用缓存带来的优势。</li>
</ul>
</li>
<li>编码的转换<ul>
<li>对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw（不论是编程字符串还是浮点数）</li>
<li>embstr编码的字符串对象实际上是只读的：redis没有为这个编码的字符串对象编写修改程序；所以一旦embstr编码的字符串对象执行了修改命令，就会变为一个raw编码的字符串对象</li>
</ul>
</li>
</ul>
</li>
<li><p>列表对象（编码：ziplist，linkedlist）</p>
<ul>
<li>编码转换：满足以下俩个条件时，才可以使用（这两个条件的上限值是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明）<ul>
<li>列表对象保存的所有字符串元素的长度都64字节</li>
<li>列表对象保存的元素数量小于512个</li>
</ul>
</li>
</ul>
</li>
<li><p>哈希对象（编码ziplist或者hashtable）</p>
<ul>
<li>俩种结构区别：<ul>
<li>ziplist会按照加入列表顺序，同时键值对紧挨着类似：name,tom,age,23这样</li>
<li>使用hashtable则会将内容变成字典键值，类似于age：25；name：tom这样</li>
</ul>
</li>
<li>编码转换：当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码（这两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明）<ul>
<li>哈希对象保存的所有键值对的<strong>键和值</strong>的字符串长度都小于64字节；</li>
<li>哈希对象保存的键值对数量小于512个；</li>
</ul>
</li>
</ul>
</li>
<li><p>集合对象（编码intset和hashtable）</p>
<ul>
<li>俩种结构的区别<ul>
<li>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</li>
<li>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</li>
</ul>
</li>
<li>编码的转换：当集合对象可以同时满足以下两个条件时，对象使用intset编码；第二个条件的上限值是可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明<ul>
<li>集合对象保存的所有元素都是整数值</li>
<li>集合对象保存的元素数量不超过512个</li>
</ul>
</li>
</ul>
</li>
<li><p>有序集合对象（编码ziplist和skiplist）</p>
<ul>
<li><p>每个元素的成员是一个字符串对象，分值是一个double类型的浮点数</p>
</li>
<li><p>俩种结构的区别</p>
<ul>
<li><p>压缩列表：每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）；集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向</p>
</li>
<li><p>zset结构作为底层实现（字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何内存）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist *zsl;<span class="comment">//跳跃表</span></span><br><span class="line">    dict *dict;<span class="comment">//字典</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的</li>
<li>zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O（1）复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性</li>
</ul>
</li>
</ul>
</li>
<li><p>编码的转换：当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码；两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明</p>
<ul>
<li>有序集合保存的元素数量小于128个</li>
<li>有序集合保存的所有元素成员的长度都小于64字节</li>
</ul>
</li>
</ul>
</li>
<li><p>命令</p>
<ul>
<li>可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等（基于类型的多态）</li>
<li>另一种命令只能对特定类型的键执行（也即为根据redisObject的type属性决定）<ul>
<li>SET、GET、APPEND、STRLEN等命令只能对字符串键执行</li>
<li>HDEL、HSET、HGET、HLEN等命令只能对哈希键执行</li>
<li>RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行</li>
<li>SADD、SPOP、SINTER、SCARD等命令只能对集合键执行</li>
<li>ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行</li>
</ul>
</li>
<li>多态命令：Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令（如列表对象，ziplist和linkedlist俩种编码，则分别用压缩列表API和双端链表API来实现）（基于编码的多态）</li>
</ul>
</li>
<li><p>内存回收</p>
<ul>
<li>引用计数技术实现内存回收机制。</li>
<li>使用redisObject的refcount属性记录<ul>
<li>创建新对象，引用计数的值初始化为1</li>
<li>对象被新程序使用时，引用计数值加1</li>
<li>对象不再被一个程序使用时，引用计数值减1</li>
<li>对象的引用计数值变为0时，对象所占用内存会被释放</li>
</ul>
</li>
</ul>
</li>
<li><p>对象共享</p>
<ul>
<li>redis初始化服务器时，创建一万个字符串对象，这些对象包含0到9999的所有整数值。这些对象的使用可以进行对象共享而不是重新创建</li>
<li>创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改。</li>
<li>Redis只共享整数值的字符串对象，其他对象越复杂时间复杂度会越高，消耗CPU时间会越高（如字符串值的字符串对象O(N),而整数只有O(1)）</li>
</ul>
</li>
<li><p>对象的空转时长</p>
<ul>
<li>OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的</li>
<li>OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性</li>
<li>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</li>
</ul>
</li>
</ul>
<h2 id="单机数据库的实现"><a href="#单机数据库的实现" class="headerlink" title="单机数据库的实现"></a>单机数据库的实现</h2><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul>
<li><p>结构（服务器结构）</p>
<ul>
<li>所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中</li>
<li>db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库</li>
<li>int dbnum（redisServer中的结构）属性决定创建多少数据库，服务器配置的database选项决定，默认16</li>
</ul>
</li>
<li><p>切换</p>
<ul>
<li>客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针</li>
<li>默认0号数据库；命令select 2切换为2号数据库</li>
</ul>
</li>
<li><p>数据库结构</p>
<ul>
<li>服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）</li>
<li>键空间的键也就是数据库的键一定是字符串对象；键空间的值也就是数据库的值，是5种对象中任意一种redis对象</li>
<li>键空间操作：添加、删除、更新、取值等操作</li>
<li>其他键空间操作：用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的；另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的</li>
<li>读写键空间的额外操作<ul>
<li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看</li>
<li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间</li>
<li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作</li>
<li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改</li>
<li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="过期键"><a href="#过期键" class="headerlink" title="过期键"></a>过期键</h4><ul>
<li><p>过期时间</p>
<ul>
<li>设置过期时间(4种命令的底层都是PEXPIREAT命令)<ul>
<li>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒</li>
<li>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒</li>
<li>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳</li>
<li>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳</li>
</ul>
</li>
<li>保存过期时间（expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典）<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳</li>
</ul>
</li>
<li>移除过期时间<ul>
<li>PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。（示例PERSIST book）</li>
</ul>
</li>
<li>计算并返回剩余生存时间<ul>
<li>TTL命令以秒为单位返回键的剩余生存时间</li>
<li>而PTTL命令则以毫秒为单位返回键的剩余生存时间</li>
</ul>
</li>
<li>过期键判断<ul>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</li>
<li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期</li>
<li>实现过期键判定的另一种方法是使用TTL命令或者PTTL命令，比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。在实际中，Redis检查键是否过期的方法和is_expired函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些</li>
</ul>
</li>
</ul>
</li>
<li><p>过期键删除策略</p>
<ul>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作<ul>
<li>优点：及时释放内存</li>
<li>缺点：占用CPU时间，同时，redis定时器是用时间事件实现，底层为无序链表，查找一个事件时间复杂度为O(N)，所以不能高效的处理。因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实</li>
</ul>
</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键<ul>
<li>优点：CPU时间占用上友好，删除过期键只会在非做不可时进行。</li>
<li>缺点，对内存释放不利，甚至极端情况下可以理解为内存泄漏</li>
</ul>
</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定<ul>
<li>前俩者的折中处理：每隔一段时间执行一次删除过期键的操作。并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。（这里没有保存惰性删除策略）</li>
<li>所以CPU时间和频率决定了定期删除策略会不会退化成惰性或者定时</li>
</ul>
</li>
</ul>
</li>
<li><p>Redis的过期键删除策略</p>
<ul>
<li>惰性删除策略的实现：db.c/expireIfNeeded函数（所有Redis命令执行前都会调用）<ul>
<li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除</li>
<li>如果输入键未过期，那么expireIfNeeded函数不做动作</li>
</ul>
</li>
<li>定期删除策略的实现: redis.c/activeExpireCycle函数实现,该函数周期性执行，同时周期性调用activeExpireCycle函数<ul>
<li>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键</li>
<li>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键</li>
<li>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作</li>
</ul>
</li>
</ul>
</li>
<li><p>AOF、RDB和复制功能对过期键的处理</p>
<ul>
<li>生成RDB文件：在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中</li>
<li>载入RDB文件<ul>
<li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响</li>
<li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响</li>
</ul>
</li>
<li>AOF文件写入：如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响；当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除</li>
<li>AOF文件重写：在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中</li>
<li>复制：从服务器的过期键删除动作由主服务器控制；只有主服务器向从服务器发送了DEL命令，从服务器才会删除过期键，其他时候从服务器当这个过期键没有过期继续使用（数据一致性）</li>
</ul>
</li>
<li><p>数据库通知</p>
<ul>
<li><p>键空间通知（key-space notification）：以键为主体的，关注某个键执行了什么命令的通知</p>
</li>
<li><p>键事件通知（key-event notification）：以事件为主体的，关注某个命令被什么键执行了</p>
</li>
<li><p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型</p>
<ul>
<li>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE</li>
<li>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK</li>
<li>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE</li>
<li>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$</li>
<li>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El</li>
</ul>
</li>
<li><p>发送通知</p>
<ul>
<li>由notify.c/notifyKeyspaceEvent函数实现的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeySpaceEvent</span><span class="params">(<span class="keyword">int</span> type,<span class="comment">//当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">char</span> *event,<span class="comment">//事件的名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        robj *key,<span class="comment">//产生事件的键</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> dbid<span class="comment">//产生事件的数据库号码)</span></span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><ul>
<li><p>数据库状态：将服务器中的非空数据库以及它们的键值对统称数据库状态</p>
</li>
<li><p>RDB文件的创建（rdbSave）</p>
<ul>
<li>SAVE命令：阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，所有客户端发送的命令请求都会被拒绝</li>
<li>BGSAVE：派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求（父进程继续处理命令请求，并通过轮询等待子进程信号）；但是其中：SAVE命令和BGSAVE命令都会被拒绝，防止产生竞争条件。BGREWRITEAOF命令会被延迟到BGSAVE命令执行完。（反过来，如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝）（这里是性能方面考虑）</li>
</ul>
</li>
<li><p>RDB文件的载入（服务器处于阻塞状态，直到载入工作完成）</p>
<ul>
<li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态</li>
</ul>
</li>
<li><p>自动间隔性保存</p>
<ul>
<li><p>定义：根据用户通过设置服务器配置的save选项，让服务器 每隔一段时间自动执行一次BGSAVE命令</p>
</li>
<li><p>自动更新条件类似（下面为默认情况）</p>
<ul>
<li>服务器在900秒之内，对数据库进行了至少1次修改</li>
<li>服务器在300秒之内，对数据库进行了至少10次修改</li>
<li>服务器在60秒之内，对数据库进行了至少10000次修改</li>
</ul>
</li>
<li><p>实现原理</p>
<ul>
<li><p>用户可以通过制定配置文件或者传入启动参数的方式设置save选项（不设置默认上面的条件）</p>
</li>
<li><p>服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性（是一个元素为saveparam的数组）</p>
</li>
<li><p>每个saveparam结构都保存了一个save选项设置的保存条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;<span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">int</span> changes;<span class="comment">//修改数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器状态维持俩个参数，（执行完BGSAVE之后，会重置dirty计数器为0，lastsave属性更新为当前时间戳）</p>
<ol>
<li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）（当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少（例如：给集合键加三个新元素，计3次））</li>
<li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间（1378270800（2013年9月4日零时））</li>
</ol>
</li>
<li><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>RDB结构</p>
<ul>
<li>开头长度5字节，保存“REDIS“5个字符，方便快速检查载入的文件是不是RDB文件</li>
<li>db_version，长度为4字节，表示一个字符串表示的整数，这个整数记录RDB文件版本号。比如”0006”就代表RDB文件的版本为第六版</li>
<li>databases部分，包含着零个或任意多个数据库，以及各个数据库中的键值对数据：<ul>
<li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li>
<li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同（每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分）。<ol>
<li>SELECTDB常量的长度为1字节（<strong>固定值376</strong>），当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码</li>
<li>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中</li>
<li>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同<ul>
<li>不带过期时间的key_value_pairs分为：type常量，1字节，代表了一种对象类型或者底层编码；key键对象；value值对象</li>
<li>带过期时间的key_value_pairs分为：type，key，value，EXpiretime_MS：告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间和ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>EOF常量，长度1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了</li>
<li>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现</li>
<li>我们使用od命令来分析Redis服务器产生的RDB文件，该命令可以用给定的格式转存（dump）并打印输入文件。比如说，给定-c参数可以以ASCII编码的方式打印输入文件，给定-x参数可以以十六进制的方式打印输入文件，使用-cx参数调用od命令，同时以ASCII编码和十六进制格式打印RDB文件，诸如此类，具体的信息可以参考od命令的文档。</li>
</ul>
</li>
</ul>
<h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><ul>
<li><p>定义：AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态；被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式，所以我们可以直接打开一个AOF文件，观察里面的内容</p>
</li>
<li><p>AOF持久化实现（先缓冲，再文件持久化）</p>
<ul>
<li>命令追加（append）：当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</li>
<li>文件写入和文件同步（sync）<ul>
<li>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数</li>
<li>服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</li>
<li>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定(默认everysec)<ol>
<li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li>
<li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li>
<li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AOF文件的载入与数据还原</p>
<ul>
<li>AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态</li>
</ul>
<ol>
<li>创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</li>
<li>从AOF文件中分析并读取出一条写命令。</li>
<li>使用伪客户端执行被读出的写命令。</li>
<li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li>
</ol>
</li>
<li><p>AOF重写</p>
<ul>
<li>AOF重写功能的实现原理：通过读取服务器当前的数据库状态，生成一条命令，代替之前执行的多条命令，减少AOF文件中命令数量，生成新的AOF文件，替换旧的AOF文件。</li>
<li>AOF重写实际实现时，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值（这个常量当前版本为64），那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令；但是每条命令设置的项数量也为64个</li>
<li>AOF后台重写（BGREWRITEAOF命令实现原理）（只有信号处理函数执行时会对服务器进程（父进程）造成阻塞）<ul>
<li>为了避免AOF重写时，服务器无法处理客户端发来的命令请求。使用子进程执行，同时子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性</li>
<li>为了解决子线程执行期间，父进程接受到客户端命令造成数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给<strong>AOF缓冲区</strong>和<strong>AOF重写缓冲区</strong><ol>
<li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行</li>
<li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面</li>
</ol>
</li>
<li>子进程完成AOF重写后，向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：<ol>
<li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li>
<li>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul>
<li><p>文本事件</p>
<ul>
<li>定义：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作</li>
<li>文件事件处理器：基于Reactor模式开发<ul>
<li>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
</li>
<li>构成组件部分<ul>
<li>套接字：文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现</li>
<li>I/O多路复用程序：负责监听多个套接字，尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个套接字</li>
<li>文件事件分派器：接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器</li>
<li>事件处理器：一个个函数，它们定义了某个事件发生时，服务器应该执行的动作；执行不同任务的套接字关联不同的事件处理器</li>
</ul>
</li>
<li>事件类型 （细节略）<ul>
<li>AE_READABLE事件（读事件）</li>
<li>AE_WRITABLE事件（写事件）两类</li>
</ul>
</li>
<li>API 略</li>
</ul>
</li>
<li><p>时间事件</p>
<ul>
<li>定义：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象</li>
<li>分类（取决于时间事件处理器的返回值）(目前只使用周期性事件，而没有使用定时事件)：<ul>
<li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次；事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li>
<li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次；事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去</li>
</ul>
</li>
<li>构成<ul>
<li>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li>
<li>when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间</li>
<li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件</li>
</ul>
</li>
<li>实现：服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。（正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。）</li>
<li>API<ul>
<li>ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc</li>
<li>ae.c/aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。</li>
<li>ae.c/aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。</li>
<li>ae.c/processTimeEvents函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。</li>
</ul>
</li>
<li>时间事件应用实例：serverCron函数、<ul>
<li>定期操作由redis.c/serverCron函数执行(Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次;从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明)<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭和清理连接失效的客户端。</li>
<li>尝试进行AOF或RDB持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>事件的调度与执行</p>
<ul>
<li>由ae.c/aeProcessEvents函数负责；将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数</li>
<li>事件的调度和执行规则<ol>
<li>aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</li>
<li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了</li>
<li>对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li>
<li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul>
<li><p>客户端属性</p>
<ul>
<li><p>通用属性</p>
<ol>
<li><p>套接字描述符：客户端状态的fd属性记录了客户端正在使用的套接字描述符；</p>
<ul>
<li><p>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令</p>
</li>
<li><p>普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1，所以普通客户端的套接字描述符的值必然是大于-1的整数</p>
</li>
</ul>
</li>
<li><p>名字：默认情况下是没有名字的，使用CLIENT setname命令可以为客户端设置一个名字，让客户端的身份变得更清晰</p>
</li>
<li><p>标志：客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态。flags属性的值可以是单个标志 flags=<value>或者多个标志的二进制或flags=<flag1>|<flag2>|…<strong>每个标志使用一个常量表示，一部分标志记录了客户端的角色，而另外一部分标志则记录了客户端目前所处的状态</strong>     所有标志都定义在redis.h文件里面。</p>
<ul>
<li>通常Redis只会将那些对数据库进行了修改的命令写入到AOF文件，但PUBSUB命令和SCRIPT LOAD命令是其中的例外，通过REDIS_FORCE_AOF标志，强制将这个俩个命令写入AOF文件。因为PUBSUB命令会让接受到消息的所有客户端的状态改变，SCRIPT LOAD命令会修改服务器状态，另外，为了让主服务器和从服务器都可以正确地载入SCRIPTLOAD命令指定的脚本。</li>
</ul>
</li>
<li><p>输入缓冲区：用于保存客户端发送的命令请求，<strong>输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端</strong>。</p>
</li>
<li><p>命令与命令参数：在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性</p>
<ul>
<li><p>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数</p>
</li>
<li><p>argc属性则负责记录argv数组的长度。</p>
</li>
</ul>
</li>
<li><p>命令的实现：当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表（字典）中查找命令所对应的命令实现函数，之后，服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令</p>
</li>
<li><p>输出缓冲区：执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的</p>
<ul>
<li><p>固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。   由buf和bufpos两个属性组成，buf是一个大小为REDIS_REPLY_CHUNK_BYTES字节的字节数组，*<em>而bufpos属性则记录了buf数组目前已使用的字节数量。REDIS_REPLY_CHUNK_BYTES常量目前的默认值为16</em>1024，也即是说，buf数组的默认大小为16KB**</p>
</li>
<li><p>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等       <strong>可变大小缓冲区由reply链表和一个或多个字符串对象组成，当buf数组的空间已经用完，或者回复因为太大而没办法放进buf数组里面时，服务器就会开始使用可变大小缓冲区。通过使用链表来连接多个字符串对象，服务器可以为客户端保存一个非常长的命令回复，而不必受到固定大小缓冲区16KB大小的限制</strong></p>
</li>
</ul>
</li>
<li><p>身份:客户端状态的authenticated属性用于记录客户端是否通过了身份验证;<strong>在服务器启用了身份验证功能时使用</strong></p>
<ul>
<li>如果authenticated的值为0，那么表示客户端未通过身份验证；如果authenticated的值为1，那么表示客户端已经通过了身份验证,未通过身份验证时，除了AUTH命令之外，客户端发送的所有其他命令都会被服务器拒绝执行</li>
</ul>
</li>
<li><p>时间属性</p>
<ul>
<li>ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒，CLIENT list命令的age域记录了这个秒数</li>
<li>lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间，这里的互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复，CLIENT list命令的idle域记录了这个秒数（可以用来计算客户端的空转时间）</li>
<li>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>特定功能相关属性</p>
<ul>
<li>创建：<ul>
<li>通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器（在第12章有介绍），为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾</li>
<li>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中，lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</li>
<li>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端</li>
</ul>
</li>
<li>关闭：主要包括reids针对，命令，输入缓冲区，输出缓冲区等等的限制</li>
</ul>
</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul>
<li><p>客户端服务器命令沟通流程</p>
<ol>
<li>当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器</li>
<li>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。3）调用命令执行器，执行客户端指定的命令<ul>
<li>服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了</li>
<li>进行预备操作（校验）：如是否已经通过了身份验证，参数个数对不对，cmd为空则拒绝等</li>
<li>调用命令实现函数</li>
<li>后续工作：如AOF缓冲区写入，慢查询日志，主服务器给从服务器传播刚刚执行的命令，根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</li>
</ul>
</li>
<li>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端</li>
<li>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看</li>
</ol>
</li>
<li><p>serverCron函数</p>
<p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转</p>
<ol>
<li>更新服务器时间缓存：因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性（服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存）（<strong>对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间</strong>）</li>
<li>更新LRU时钟（<strong>服务器状态中的lruclock属性保存了服务器的LRU时钟</strong>）：类似于上面，也是服务器缓存时间的一种，每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间,当服务器要计算一个数据库键的空转时间（也即是数据库键对应的值对象的空转时间），程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间</li>
<li>更新服务器每秒执行命令次数:serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量</li>
<li>更新服务器内存峰值记录:服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小,每次会查看当前内存数量，于该值对比，留下较大的数</li>
<li>处理SIGTERM信号：每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器（值为1关闭服务器，为0不做动作），<strong>服务器在关闭自身之前会进行RDB持久化操作，这也是服务器拦截SIGTERM信号的原因，如果服务器一接到SIGTERM信号就立即关闭，那么它就没办法执行持久化操作了</strong></li>
<li>管理客户端资源：<ul>
<li>如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端</li>
<li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存</li>
</ul>
</li>
<li>管理数据库资源：serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作</li>
<li>执行被延迟的BGREWRITEAOF:每次serverCron函数执行时，函数都会检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行，如果这两个命令都没在执行，并且<strong>aof_rewrite_scheduled属性</strong>的值为1，那么服务器就会执行之前被推延的BGREWRITEAOF命令。</li>
<li>检查持久化操作的运行状态:rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID<ul>
<li>其中一个属性的值不为-1：如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件；；如果没有信号到达，那么表示持久化操作未完成，程序不做动作</li>
<li>都为-1表示没有进行持久化操作：（按照下面顺序判断进行，都会判断一遍，所以每次要判断是否有其他持久化操作）<ul>
<li>查看是否有BGREWRITEAOF被延迟了；</li>
<li>检查服务器的自动保存条件是否已经被满足，如果条件满足，<strong>并且服务器没有在执行其他持久化操作</strong>，那么服务器开始一次新的BGSAVE操作；</li>
<li>检查服务器设置的AOF重写条件是否满足，如果条件满足，<strong>并且服务器没有在执行其他持久化操作</strong>，那么服务器将开始一次新的BGREWRITEAOF操作</li>
</ul>
</li>
</ul>
</li>
<li>将AOF缓冲区中的内容写入AOF文件</li>
<li>关闭异步客户端：服务器会关闭那些输出缓冲区大小超出限制的客户端</li>
<li>增加cronloops计数器的值：服务器状态的cronloops属性记录了serverCron函数执行的次数，每次调用serverCron函数，本值加1；cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能，（例如执行10000次，重启）</li>
</ol>
</li>
<li><p>初始化服务器</p>
<ul>
<li>创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值，由<strong>initServerConfig函数</strong>完成<ul>
<li>设置服务器的运行ID。</li>
<li>设置服务器的默认运行频率。</li>
<li>设置服务器的默认配置文件路径。</li>
<li>设置服务器的运行架构。</li>
<li>设置服务器的默认端口号。</li>
<li>设置服务器的默认RDB持久化条件和AOF持久化条件。</li>
<li>初始化服务器的LRU时钟。</li>
<li>创建命令表。</li>
</ul>
</li>
<li>载入配置选项：用户可以通过给定配置参数或者指定配置文件（redis.conf文件）来修改服务器的默认配置</li>
<li>初始化服务器数据结构 <strong>initServer函数完成</strong><ul>
<li>server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</li>
<li>server.db数组，数组中包含了服务器的所有数据库。</li>
<li>用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</li>
<li>用于执行Lua脚本的Lua环境server.lua。</li>
<li>用于保存慢查询日志的server.slowlog属性</li>
<li>为服务器设置进程信号处理器</li>
<li>创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象</li>
<li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接</li>
<li>为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数</li>
<li>如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备</li>
<li>初始化服务器的后台I/O模块（bio），为将来的I/O操作做好准备</li>
</ul>
</li>
<li>还原数据库状态<ul>
<li>如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态</li>
<li>相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态</li>
</ul>
</li>
<li>执行事件循环：开始执行服务器的事件循环（loop）</li>
</ul>
</li>
</ul>
<h2 id="多机数据库"><a href="#多机数据库" class="headerlink" title="多机数据库"></a>多机数据库</h2><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul>
<li>用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）（示例slaveof  ip port）</li>
<li>旧版复制功能（俩个阶段）<ul>
<li>同步（sync）:只有同步可以显示的用slaveof开启，用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态(整体同步)<ul>
<li>从服务器向主服务器发送SYNC命令</li>
<li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li>
</ul>
</li>
<li>命令传播（command propagate）:用于在主服务器的数据库状态被修改（例如写命令，删除一个键），导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态（个别命令同步）</li>
<li>缺陷：<ul>
<li>场景：断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li>
<li>原因：可能只有断开很短的时间，只需要复制小部分键的数据，而旧版功能需要同步，让主服务器生成一个RDB文件包含所有键，进行同步。<ol>
<li>主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源</li>
<li>主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响</li>
<li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>新版复制功能<ul>
<li>PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式<ul>
<li>完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li>
<li>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li>
</ul>
</li>
<li>部分重同步的实现<ul>
<li>主服务器的复制偏移量和从服务器的复制偏移量：主从服务器都维护一个复制偏移量，保持相等，主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N；从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。<strong>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的，不相等则不是</strong></li>
<li>主服务器的复制积压缓冲区：数据结构：<strong>固定长度先进先出队列</strong>，默认大小1MB。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，所以复制积压缓冲区保留最近传播的写命令。断线后，<strong>通过偏移量计算差的数据</strong>在不在里面，在则启动部分重同步模式，否则启动完整重同步。<ul>
<li>复制积压缓冲区的最小大小可以根据公式second（从服务器断线后重新连接上主服务器所需的平均时间（以秒计算））* write_size_per_second（服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和））  <strong>为了安全起见，可以将复制积压缓冲区的大小设为2 * second * write_size_per_second</strong>   repl-backlog-size选项修改复制积压缓冲区大小</li>
</ul>
</li>
<li>服务器的运行ID：每个redis服务器无论主从，都会在启动时生成运行id，由40个随机的十六进制字符组成 例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。 <strong>初次复制时，主服务器将自己的运行id传送给从服务器，从服务器保存运行id</strong>，断线重连后，从服务器发送这个运行id与当前服务器比对，相同则启动部分重同步操作，不同则完整重同步操作</li>
</ul>
</li>
<li>PSYNC命令的实现<ul>
<li>从服务器<ol>
<li>如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）</li>
<li>相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ＜runid＞ ＜offset＞命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。</li>
</ol>
</li>
<li>主服务器<ol>
<li>如果主服务器返回+FULLRESYNC ＜runid＞ ＜offset＞回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量</li>
<li>如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了</li>
<li>如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>复制的实现<ol>
<li>设置主服务器的地址端口，通过slaveof 127.0.0.1  6739 这样的命令，将ip和端口保存到服务器状态的masterhost属性和masterport属性里面。SLAVEOF命令是一个异步命令，在完成masterhost属性和masterport属性的设置工作之后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而实际的复制工作将在OK返回之后才真正开始执行。</li>
<li>建立套接字连接：从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接；连接成功，<ul>
<li>从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令</li>
<li>主服务器在接受（accept）从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待</li>
</ul>
</li>
<li>发送ping命令：通过发送PING命令可以检查套接字的读写状态是否正常和检查主服务器能否正常处理命令请求。其有下面三种情况：<ul>
<li>如果主服务器向从服务器返回了一个命令回复，但从服务器却不能在规定的时限（timeout）内读取出命令回复的内容，那么表示主从服务器之间的网络连接状态不佳，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器断开并重新创建连向主服务器的套接字。</li>
<li>如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器断开并重新创建连向主服务器的套接字。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only callSCRIPT KILL or SHUTDOWN NOSAVE.错误。</li>
<li>如果从服务器读取到”PONG”回复，那么表示主从服务器之间的网络连接状态正常，并且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可以继续执行复制工作的下个步骤。</li>
</ul>
</li>
<li>身份验证：<ul>
<li>如果主服务器没有设置requirepass选项，并且从服务器也没有设置masterauth选项，那么主服务器将继续执行从服务器发送的命令，复制工作可以继续进行</li>
<li>如果从服务器通过AUTH命令发送的密码和主服务器requirepass选项所设置的密码相同，那么主服务器将继续执行从服务器发送的命令，复制工作可以继续进行。与此相反，如果主从服务器设置的密码不相同，那么主服务器将返回一个invalid password错误</li>
<li>如果主服务器设置了requirepass选项，但从服务器却没有设置masterauth选项，那么主服务器将返回一个NOAUTH错误。另一方面，如果主服务器没有设置requirepass选项，但从服务器却设置了masterauth选项，那么主服务器将返回一个no password is set错误</li>
</ul>
</li>
<li>发送端口信息：从服务器将执行命令REPLCONFlistening-port ＜port-number＞，向主服务器发送从服务器的监听端口号。主服务器在接收到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的slave_listening_port属性中。<strong>slave_listening_port属性目前唯一的作用就是在主服务器执行INFO replication命令时打印出从服务器的端口号。</strong></li>
<li>同步：同步操作后，主服务器也会成为从服务器的客户端（这样才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命令传播操作的基础）</li>
<li>命令传播：当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。</li>
</ol>
</li>
</ul>
<h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h4><ul>
<li><p>定义：从服务器默认会以每秒一次的频率，向主服务器发送命令：其中replication_offset是从服务器当前的复制偏移量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测主从服务器的网络连接状态：主从服务器可以通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接是否正常：如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了；通过向主服务器发送INFO replication命令，在列出的从服务器列表的<strong>lag一栏</strong>中，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令距离现在过了多少秒</p>
</li>
<li><p>辅助实现min-slaves配置选项：Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>那么在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令，这里的延迟值就是上面提到的INFO replication命令的lag值</p>
</li>
<li><p>检测命令丢失：如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p>
</li>
</ul>
<h4 id="Sentinel（哨兵）"><a href="#Sentinel（哨兵）" class="headerlink" title="Sentinel（哨兵）"></a>Sentinel（哨兵）</h4><ul>
<li><p>定义：Redis的高可用性（highavailability）解决方案，由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<ul>
<li>假设主服务器server1进入下线状态，当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行故障转移操作：<ul>
<li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</li>
<li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li>
<li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器</li>
</ul>
</li>
</ul>
</li>
<li><p>启动并初始化</p>
<ul>
<li><p>启动一个Sentinel命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-sentinel /path/to/your/sentinel.conf</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server /path/to/your/sentinel.conf --sentinel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化服务器：Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器。（大致类似于普通服务器的初始化，只不过还原数据库状态啥的没有）</p>
</li>
<li><p>使用Sentinel专用代码：如 Sentinel使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define REDIS_SENTINEL_PORT 26379</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化Sentinel状态：服务器会初始化一个sentinel.c/sentinelState结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> current_epoch;<span class="comment">//当前纪元</span></span><br><span class="line">    dict *masters;<span class="comment">//保存监视的主服务器，键是主服务器的名字，值指向一个sentinelRedisInstance结构的指针</span></span><br><span class="line">    <span class="keyword">int</span> tilt;<span class="comment">//是否进入TILT模式</span></span><br><span class="line">    <span class="keyword">int</span> running_scripts;<span class="comment">//目前正在执行的脚本的数量</span></span><br><span class="line">    <span class="keyword">mstime_t</span> tilt_start_time;<span class="comment">//进入TILT模式的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> previous_time;<span class="comment">//最后一次执行时间处理器的时间</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;<span class="comment">//一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化Sentinel状态的masters属性：masters字典记录了所有被Sentinel监视的主服务器的相关信息，字典的键是被监视主服务器的名字，字典的值则是被监视主服务器对应的sentinel.c/sentinelRedisInstance结构。每个sentinelRedisInstance结构（后面简称“实例结构”）代表一个被Sentinel监视的Redis服务器实例（instance），这个实例可以是主服务器、从服务器，或者另外一个Sentinel。（这个masters字典的初始化根据被载入的Sentinel配置文件进行）</p>
</li>
<li><p>创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息，对于每个被Sentinel监视的主服务器来说，Sentinel会创建<strong>两个</strong>连向主服务器的<strong>异步网络连接</strong></p>
<ul>
<li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复</li>
<li>另一个是订阅连接，这个连接专门用于订阅主服务器的<strong>sentinel</strong>:hello频道（在Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失<strong>sentinel</strong>:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息）</li>
</ul>
</li>
</ul>
</li>
<li><p>获取主服务器信息</p>
<ul>
<li>Sentinel默认会以<strong>每十秒一次</strong>的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。<ul>
<li>一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</li>
<li>另一方面是关于主服务器属下所有从服务器的信息，每个从服务器都由一个”slave”字符串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器。生成slaves字典保存数据：<ul>
<li>字典的键是由Sentinel自动设置的从服务器名字，格式为ip:port：如对于IP地址为127.0.0.1，端口号为11111的从服务器来说，Sentinel为它设置的名字就是127.0.0.1:11111</li>
<li>至于字典的值则是从服务器对应的实例结构：比如说，如果键是127.0.0.1:11111，那么这个键的值就是IP地址为127.0.0.1，端口号为11111的从服务器的实例结构。</li>
<li>同时校验从服务器对应的实例结构已经存在，存在则更新，不存在添加</li>
</ul>
</li>
<li>主从服务器实例之间的区别<ul>
<li>主服务器实例结构的flags属性的值为SRI_MASTER，而从服务器实例结构的flags属性的值为SRI_SLAVE</li>
<li>主服务器实例结构的name属性的值是用户使用Sentinel配置文件设置的，而从服务器实例结构的name属性的值则是Sentinel根据从服务器的IP地址和端口号自动设置的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>获取从服务器信息</p>
<ul>
<li>Sentinel会创建连接到从服务器的命令连接和订阅连接</li>
<li>在创建命令连接之后，Sentinel在默认情况下，会以<strong>每十秒一次</strong>的频率通过命令连接向从服务器发送INFO命令，根据INFO命令的回复，Sentinel会提取出以下信息<ul>
<li>从服务器的运行ID run_id</li>
<li>从服务器的角色role</li>
<li>主服务器的IP地址master_host，以及主服务器的端口号master_port</li>
<li>主从服务器的连接状态master_link_status</li>
<li>从服务器的优先级slave_priority</li>
<li>从服务器的复制偏移量slave_repl_offset</li>
</ul>
</li>
</ul>
</li>
<li><p>向主从服务器发送消息（发消息和订阅消息时一个频道）</p>
<ul>
<li><p>Sentinel会以<strong>每两秒一次</strong>的频率，通过命令连接向所有被监视的主服务器和从服务器的 __ sentinel__:hello频道发送以下格式的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH _sentinel_:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>其中以s_开头的参数记录的是Sentinel本身的信息, m_开头的参数记录的则是主服务器的信息(如果Sentinel正在监视的是主服务器，那么这些参数记录的就是主服务器的信息；如果Sentinel正在监视的是从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息)</p>
</li>
</ul>
</li>
<li><p>接受来自主从服务器的频道信息</p>
<ul>
<li><p>当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过<strong>__ sentinel__:hello的频道</strong>订阅连接(订阅会持续到Sentinel与服务器断开连接)，向服务器发送以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE _sentinel_:hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个Sentinel从<strong>sentinel</strong>:hello频道收到一条信息时，Sentinel会对这条信息进行分析，提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查</p>
<ul>
<li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理</li>
<li>相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，<strong>对相应主服务器的实例结构进行更新</strong></li>
<li>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接，<strong>最终监视同一主服务器的多个Sentinel将形成相互连接的网络</strong>：Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接</li>
<li>连接其他Sentinel时，却只会创建命令连接，而不创建订阅连接。这是因为Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新Sentinel，所以才需要建立订阅连接，而相互已知的Sentinel只要使用命令连接来进行通信就足够了。</li>
</ul>
</li>
</ul>
</li>
<li><p>检测主观下线状态</p>
<ul>
<li>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。<ul>
<li>有效回复：实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种</li>
<li>无效回复：实例返回除+PONG、-LOADING、-MASTERDOWN三种回复之外的其他回复，或者在指定时限内没有返回任何回复。</li>
</ul>
</li>
<li>Sentinel配置文件中的<strong>down-after-milliseconds</strong>选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，<strong>在结构的flags属性中打开SRI_S_DOWN标识</strong>，以此来表示这个实例已经进入主观下线状态</li>
<li>配置文件中的<strong>down-after-milliseconds</strong>选项不仅会成为Sentinel判断master进入主观下线的标准，还会成为Sentinel判断master属下所有从服务器，以及所有同样监视master的其他Sentinel进入主观下线的标准</li>
<li>每个sentinel都会有自己的down-after-milliseconds，所以主观判断不相同</li>
</ul>
</li>
<li><p>检查客观下线状态</p>
<ul>
<li><p>使用 如下命令，询问其他sentinel是否同意主服务器已下线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt;&lt;port&gt;&lt;current_epoch&gt;&lt;runid&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>目标sentinel收到源sentinel后，根据参数，确定主服务器是否下线，给予回复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;down_state&gt;&#x2F;&#x2F;1代表下线，0代表未下线</span><br><span class="line">&lt;leader_runid&gt;</span><br><span class="line">&lt;leader_epoch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>收到回复下线的sentinel数量大于启动时配置的数量，则认为主服务器已经进入客观下线状态</p>
</li>
<li><p>同样，因为配置不同，每个sentinel也判断客观下线不一定</p>
</li>
</ul>
</li>
<li><p>选举领头sentinel</p>
<ul>
<li>规则和方法如下：<ul>
<li>所有在线的Sentinel都有被选为领头Sentinel的资格，换句话说，监视同一个主服务器的多个在线Sentinel中的任意一个都有可能成为领头Sentinel。</li>
<li>每次进行领头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的。</li>
<li>在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。</li>
<li>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。</li>
<li>当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINELis-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel。</li>
<li>Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。</li>
<li>目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，将向源Sentinel返回一条命令回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元。</li>
<li>源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel。</li>
<li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成为领头Sentinel。</li>
<li>因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel。</li>
<li>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止。</li>
</ul>
</li>
</ul>
</li>
<li><p>故障转移</p>
<ul>
<li>选择新的主服务器，按照以下规则<ul>
<li>删除列表中所有处于下线或者断线状态的从服务器，这可以保证列表中剩余的从服务器都是正常在线的</li>
<li>删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的</li>
<li>删除所有与已下线主服务器连接断开超过down-after-milliseconds<em>10毫秒的从服务器：down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过 down-after-milliseconds</em>10毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，换句话说，列表中剩余的从服务器保存的数据都是比较新的</li>
<li>然后按照优先级从高到底（前面出现过的一个属性），偏移量从大到小，运行id从小到大，选出一个从服务器（前一个相同，看后一个属性）</li>
</ul>
</li>
<li>向选出的从服务器发送SLAVEOF no one命令，发送之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升级的从服务器发送INFO命令，并观察命令回复中的角色（role）信息，当被升级服务器的role从原来的slave变为master时，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了</li>
<li>修改从服务器的复制目标：向从服务器发送SLAVEOF命令，让已下线主服务器属下的所有从服务器去复制新的主服务器</li>
<li>将旧的主服务器变为从服务器：当旧主服务器重新上线时，Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器</li>
</ul>
</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul>
<li><p>节点（node）</p>
<ul>
<li><p>一个Redis集群由多个节点组成，一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式，节点会继续使用所有在单机模式中使用的服务器组件</p>
</li>
<li><p>集群数据结构</p>
<ul>
<li>clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号等等，每个节点有一个自己的clusterNode，同时给所有主从节点创建一个相应的clusterNode结构</li>
<li>clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区（redisClient结构和其一样，但是redisClient用来连接客户端，而clusterLink用来连接节点）</li>
<li>clusterState结构：这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元，诸如此类</li>
</ul>
</li>
<li><p>向一个节点node发送CLUSTER MEET命令，可以让node节点与ip和port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>握手步骤：</p>
<ol>
<li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li>
<li>之后，节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）</li>
<li>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面</li>
<li>之后，节点B将向节点A返回一条PONG消息</li>
<li>如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息</li>
<li>之后，节点A将向节点B返回一条PING消息</li>
<li>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成</li>
</ol>
</li>
</ul>
</li>
<li><p>槽指派</p>
<ul>
<li><p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p>
</li>
<li><p>当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p>
</li>
<li><p>命令将槽点设置给各个服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster addslots &lt;slot&gt;  [slot ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>clusterNode结构中的slots属性（二进制数组，长度为16384/8=2048个字节，共包含16384个二进制位）和numslot属性记录节点负责的处理槽和长度，也即是slots数组中值为1的二进制位的数量</p>
<ul>
<li>Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位的值来判断节点是否负责处理槽i；为1则表示节点负责处理槽i，值为0则不负责</li>
<li>节点也保存其他节点的槽记录，因为集群中的每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面，因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点。</li>
</ul>
</li>
<li><p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息；slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针：如果slots[i]指针指向NULL，那么表示槽i尚未指派给任何节点。如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点</p>
</li>
</ul>
</li>
<li><p>集群中执行命令</p>
<ul>
<li><p>计算键属于哪个槽：其中CRC16（key）语句用于计算键key的CRC-16校验和，而&amp;16383语句则用于计算出一个介于0至16383之间的整数作为键key的槽号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def slot_number(key): </span><br><span class="line">    return CRC16(key) &amp; 16383</span><br><span class="line">CLUSTER KEYSLOT &lt;key&gt; &#x2F;&#x2F;查看一个给定键属于哪个槽</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断槽点是否由当前节点负责</p>
<ul>
<li>如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令</li>
<li>如果clusterState.slots[i]不等于clusterState.myself，那么说明槽i并非由当前节点负责，节点会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，向客户端返回MOVED错误，指引客户端转向至正在处理槽i的节点</li>
</ul>
</li>
<li><p>MOVED错误格式：MOVED <slot> <ip> :<port></p>
</li>
<li><p><strong>集群模式的redis-cli客户端在</strong>接收到MOVED错误时，并不会打印出MOVED错误，而是根据MOVED错误自动进行节点转向，并打印出转向信息，所以我们是看不见节点返回的MOVED错误的;<strong>单机可以</strong></p>
</li>
<li><p>集群中的节点只能用0号数据库，而单机redis可以用全部</p>
</li>
<li><p>除了将键值对保存在数据库里面之外，节点还会用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系，slots_to_keys跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键：</p>
<ul>
<li>每当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到slots_to_keys跳跃表</li>
<li>当节点删除数据库中的某个键值对时，节点就会在slots_to_keys跳跃表解除被删除键与槽号的关联</li>
</ul>
</li>
</ul>
</li>
<li><p>重新分片</p>
<ul>
<li><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。<strong>在线（online）进行</strong>,<strong>且源节点和目标节点都可以继续处理命令请求</strong>。</p>
</li>
<li><p>步骤：</p>
<ol>
<li>redis-trib对目标节点发送CLUSTER SETSLOT＜slot＞IMPORTING＜source_id＞命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对</li>
<li>redis-trib对源节点发送CLUSTER SETSLOT＜slot＞MIGRATING＜target_id＞命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点</li>
<li>redis-trib向源节点发送CLUSTER GETKEYSINSLOT＜slot＞＜count＞命令，获得最多count个属于槽slot的键值对的键名（key name）</li>
<li>对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE＜target_ip＞＜target_port＞＜key_name＞0＜timeout＞命令，将被选中的键原子地从源节点迁移至目标节点。</li>
<li>重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止</li>
<li>redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT＜slot＞NODE＜target_id＞命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点</li>
</ol>
</li>
</ul>
</li>
<li><p>ASK错误：当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时</p>
<ul>
<li><p>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令</p>
</li>
<li><p>相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令</p>
</li>
<li><p>ASK错误格式 : ASK<slot> <ip> :<port></p>
</li>
<li><p>在对集群进行重新分片的时候，向目标节点发送命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT&lt;i&gt; IMPORTING &lt;SOURCE_id&gt;</span><br></pre></td></tr></table></figure>

<p>可以将目标节点clusterState.importing_slots_from[i]的值设置为source_id所代表节点的clusterNode结构。(如果importing_slots_from[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在从clusterNode所代表的节点导入槽i。)</p>
</li>
<li><p>在对集群进行重新分片的时候，向源节点发送命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</span><br></pre></td></tr></table></figure>

<p>可以将源节点clusterState.migrating_slots_to[i]的值设置为target_id所代表节点的clusterNode结构（如果migrating_slots_to[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在将槽i迁移至clusterNode所代表的节点。）</p>
</li>
<li><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识;</p>
</li>
<li><p>当客户端接收到ASK错误并转向至正在导入槽的节点时,客户端会<strong>先向节点发送一个ASKING命令</strong>，然后才重新发送想要执行的命令，这是因为如果客户端不发送ASKING命令，而直接发送想要执行的命令的话，那么客户端发送的命令将被节点拒绝执行，并返回MOVED错误。（因为槽的指派还没有换过来）</p>
</li>
<li><p>客户端的REDIS_ASKING标识是一个一次性标识，当节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，客户端的REDIS_ASKING标识就会被移除。所以下次启动要再执行下这个命令。</p>
</li>
<li><p>ASK错误和MOVED错误区别：</p>
<ul>
<li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点，因为该节点就是目前负责槽i的节点</li>
<li>与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，但这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现</li>
</ul>
</li>
</ul>
</li>
<li><p>复制与故障转移</p>
<ul>
<li><p>Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求</p>
</li>
<li><p>向一个节点发送命令:可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_ip&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>节点首先会在自己的clusterState.nodes字典中找到node_id所对应节点的clusterNode结构，并将自己的clusterState.myself.slaveof指针指向这个结构，以此来记录这个节点正在复制的主节点；</p>
</li>
<li><p>然后节点会修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识，表示这个节点已经由原来的主节点变成了从节点。</p>
</li>
<li><p>最后，节点会调用复制代码，并根据clusterState.myself.slaveof指向的clusterNode结构所保存的IP地址和端口号，对主节点进行复制。因为节点的复制功能和单机Redis服务器的复制功能使用了相同的代码，所以让从节点复制主节点相当于向从节点发送命令SLAVEOF</p>
</li>
<li><p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点，集群中的所有节点都会在代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单</p>
</li>
</ul>
</li>
<li><p>故障检测</p>
<ul>
<li>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线（probable fail，PFAIL）</li>
<li>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL），将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线</li>
</ul>
</li>
<li><p>故障转移</p>
<p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li>
<li>被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
</li>
<li><p>选举新的主节点（类似Sentinel选举）</p>
<ol>
<li>集群的配置纪元是一个自增计数器，它的初始值为0；</li>
<li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li>
<li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li>
<li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li>
<li>如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li>
<li>每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li>
<li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</li>
<li>因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li>
<li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li>
</ol>
</li>
</ul>
</li>
<li><p>消息</p>
<ul>
<li><p>集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者.<strong>一条消息由消息头（header）和消息正文（data）组成</strong></p>
</li>
<li><p>节点发送的消息类型</p>
<ul>
<li>MEET消息：当发送者接到客户端发送的CLUSTERMEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</li>
<li>PING消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。除此之外，如果节点A最后一次收到节点B发送的PONG消息的时间，距离当前时间已经超过了节点A的cluster-node-timeout选项设置时长的一半，那么节点A也会向节点B发送PING消息，这可以防止节点A因为长时间没有随机选中节点B作为PING消息的发送对象而导致对节点B的信息更新滞后。</li>
<li>PONG消息：当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。另外，一个节点也可以通过向集群广播自己的PONG消息来让集群中的其他节点立即刷新关于这个节点的认识，例如当一次故障转移操作成功执行之后，新的主节点会向集群广播一条PONG消息，以此来让集群中的其他节点立即知道这个节点已经变成了主节点，并且接管了已下线节点负责的槽。</li>
<li>FAIL消息：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。</li>
<li>PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li>
</ul>
</li>
<li><p>消息头（结构略）：节点发送的所有消息都由一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身的一些信息，因为这些信息也会被消息接收者用到，所以严格来讲，我们可以认为消息头本身也是消息的一部分。<strong>接收者会根据这些信息，在自己的clusterState.nodes字典里找到发送者对应的clusterNode结构，并对结构进行更新。</strong></p>
</li>
<li><p>消息的实现：</p>
<ul>
<li><p>Redis集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG三种消息实现；节点通过消息头的type属性来判断消息类型（发送者同时携带从自己的已知节点列表中随机选出的俩个节点，主从皆可能），接受者根据节点是否已知，进行更新维护或者进行握手</p>
</li>
<li><p>当集群里的主节点A将主节点B标记为已下线（FAIL）时，主节点A将向集群广播一条关于主节点B的FAIL消息，所有接收到这条FAIL消息的节点都会将主节点B标记为已下线</p>
</li>
<li><p>当客户端向集群中的某个节点发送命</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH &lt;channel&gt; &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p> 的时候，接收到PUBLISH命令的节点不仅会向channel频道发送消息message，它还会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会向channel频道发送message消息。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="独立功能"><a href="#独立功能" class="headerlink" title="独立功能"></a>独立功能</h2><h4 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h4><ul>
<li>Redis将所有<strong>频道的订阅</strong>关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端。<ul>
<li>SUBSCRIBE命令订阅某个或某些频道</li>
<li>UNSUBSCRIBE命令让服务器将从pubsub_channels中解除客户端与被退订频道之间的关联</li>
<li>订阅或者退订的频道有键存在在字典里，则在链表中添加或者删除该客户端，没有的则在字典里添加或者删除频道的键</li>
</ul>
</li>
<li>服务器将所有频道的订阅关系都保存在服务器状态的pubsub_channels属性里面，与此类似，服务器也将所有<strong>模式的订阅关系</strong>都保存在服务器状态的pubsub_patterns属性里面（模式以正则表达式的形式存储如news.* 可能频道的是news.it;news.me等等  则这个频道是这个模式）<ul>
<li>pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsub Pattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端</li>
<li>PSUBSCRIBE命令订阅某个或某些模式的时候，新建一个pubsubPattern结构，将结构的pattern属性设置为被订阅的模式，client属性设置为订阅模式的客户端；将这个结构添加到链表末尾</li>
<li>PUNSUBSCRIBE命令则是从链表中查找并删除这个结构</li>
</ul>
</li>
<li>发送消息 PUBLISH <channel> <message><ul>
<li>将消息message发送给channel频道的所有订阅者（在pubsub_channels字典里找到频道channel的订阅者名单（一个链表），然后将消息发送给名单上的所有客户端）</li>
<li>如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。（PUBLISH命令要做的就是遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端）</li>
</ul>
</li>
<li>查看订阅信息<ul>
<li>PUBSUB CHANNELS [pattern]子命令用于返回服务器当前被订阅的频道（例如 PUBSUB CHANNELS “news.[is]*”   pattern可以是正则表达式）<ul>
<li>如果不给定pattern参数，那么命令返回服务器当前被订阅的所有频道</li>
<li>如果给定pattern参数，那么命令返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道</li>
</ul>
</li>
<li>PUBSUB NUMSUB[channel-1 channel-2…channel-n]子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量（这个子命令是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的（订阅者链表的长度就是频道订阅者的数量））</li>
<li>PUBSUB NUMPAT子命令用于返回服务器当前被订阅模式的数量。（这个子命令是通过返回pubsub_patterns链表的长度来实现的，因为这个链表的长度就是服务器被订阅模式的数量）</li>
</ul>
</li>
</ul>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul>
<li><p>事务的实现</p>
<ul>
<li><p>事务开始：MULTI命令   显示切换执行该命令的客户端，从非事务状态切换至事务状态，通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成</p>
</li>
<li><p>命令入队：事务状态下的客户端，服务器会根据这个客户端发来的不同命令执行不同的操作</p>
<ul>
<li>如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令</li>
</ul>
</li>
</ul>
</li>
<li><p>与此相反，如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个<strong>事务队列</strong>里面，然后向客户端返回QUEUED回</p>
</li>
<li><p>事务队列是一个先进先出的队列，是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span>&#123;</span></span><br><span class="line">    robj **argv; <span class="comment">//参数</span></span><br><span class="line">    <span class="keyword">int</span> argc;<span class="comment">//参数数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span><span class="comment">//命令指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>+ 当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果**全部**返回给客户端</code></pre>
<ul>
<li><p>WATCH命令</p>
<ul>
<li>WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。（别的客户端进行的修改）</li>
<li>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端</li>
<li>命令 WATCH “name” “age”  让客户端监视键name和age，即在这俩个键的链表中加上当前客户端</li>
<li>所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。</li>
<li>一个客户端发来EXEC命令提交事务时，服务器根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务</li>
</ul>
</li>
<li><p>事务的ACID性质</p>
<ul>
<li>原子性：redis事务支持原子性（但是不支持回滚，所以就算执行失败也会全部执行一遍）</li>
<li>一致性：<ul>
<li>入队错误：Redis 2.6.5以后直接拒绝事务</li>
<li>执行错误：在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。</li>
<li>服务器停机：根据RDB或者AOF模式恢复数据，恢复不了则空白，也保证一致性</li>
</ul>
</li>
<li>隔离性：因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</li>
<li>持久性：根据redis本身启用的持久化模式决定是否具有耐久性，（不论Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事务的耐久性，不过因为这种做法的效率太低，所以并不具有实用性。）</li>
</ul>
</li>
</ul>
<h4 id="LUA脚本"><a href="#LUA脚本" class="headerlink" title="LUA脚本"></a>LUA脚本</h4><ul>
<li>Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性、安全性等方面的需要。（一些优化，比如对于不确定命令加入排序（列表不加排序，根据添加不同输出会不同），random函数自定义，去除掉lua脚本的该函数会有副作用）</li>
<li>协作组件<ul>
<li>Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令。</li>
<li>Redis服务器为Lua环境创建的另一个协作组件是lua_scripts字典，这个字典的键为某个Lua脚本的SHA1校验和（checksum），而字典的值则是SHA1校验和对应的Lua脚本</li>
</ul>
</li>
<li>Redis使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能。</li>
<li>脚本管理命令<ul>
<li>EVAL命令为客户端输入的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。</li>
<li>EVALSHA命令通过直接调用Lua环境中已定义的函数来执行脚本。</li>
<li>SCRIPT FLUSH命令会清空服务器lua_scripts字典中保存的脚本，并重置Lua环境。</li>
<li>SCRIPT EXISTS命令接受一个或多个SHA1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。</li>
<li>SCRIPT LOAD命令接受一个Lua脚本为参数，为该脚本在Lua环境中创建函数，并将脚本保存到lua_scripts字典中。</li>
</ul>
</li>
<li>服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行情况时，客户端可以通过向服务器发送SCRIPT KILL命令（未执行写命令相关操作）来让钩子停止正在执行的脚本，或者发送SHUTDOWN nosave命令（执行了写命令相关操作）来让钩子关闭整个服务器。</li>
<li>脚本复制<ul>
<li>主服务器复制EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的方法和复制普通Redis命令一样，只要将相同的命令传播给从服务器就可以了。</li>
<li>主服务器在复制EVALSHA命令时，必须确保<strong>所有从服务器都已经载入了EVALSHA命令指定的SHA1校验和所对应的Lua脚本</strong>，（主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器）如果不能确保这一点的话，主服务器会将EVALSHA命令转换成等效的EVAL命令，并通过传播EVAL命令来获得相同的脚本执行效果。</li>
</ul>
</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul>
<li>命令的实现（快速排序实现实际排序）：<ul>
<li>SORT <key>  （ASC | DESC）（数字值排序 升降序） 默认升序从小到大<ul>
<li>创建个和要排序的列表长度相同的数组，该数组里obj指针指向每个列表项完成绑定关系，u.score属性保存由列表项值转成的double类型的浮点数。</li>
<li>遍历数组，根据u.score属性从小到大排序，排序结果传给客户端，完成排序</li>
</ul>
</li>
<li>SORT <key> ALPHA  （ASC | DESC）（字符串值排序  升降序） 默认升序从小到大<ul>
<li>创建个和要排序的列表长度相同的数组，该数组里obj指针指向每个列表项完成绑定关系，u.score属性保存字符串值。</li>
<li>遍历数组，根据u.score属性的字符串值从小到大排列，排序结果传给客户端，完成排序</li>
</ul>
</li>
<li>SORT命令可以指定某些字符串键，或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序   （例如  SORT fruits BY *-price 权重值数值型    SORT fruits BY *-id ALPHA 权重值为字符串型 ） <ul>
<li>这里相对于不使用by，就是在实际排序时，*<em>BY选项所给定的模式</em>-price，查找相应的权重键，将各个权重键的值转换成一个double类型的浮点数，然后保存在相应数组项的u.score属性里面，之后进行排序**。</li>
<li>将各个数组项的u.cmpobj指针分别指向相应的权重键（一个字符串对象），以各个数组项的权重键的值为权重，对数组执行字符串排序</li>
</ul>
</li>
<li>LIMIT选项  格式为LIMIT＜offset＞＜count＞<ul>
<li>offset参数表示要跳过的已排序元素数量</li>
<li>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量</li>
<li>实际逻辑类似排序，就是在起始索引处用offset的值，取出来的数量用count的值</li>
</ul>
</li>
<li>GET选项<ul>
<li>SORT students ALPHA GET *-name   排序students之后，返回以students各个元素+-name的键对应的值</li>
<li>SORT students ALPHA GET *-name GET *-birth 排序students之后，返回students各个元素+-name的键和+-birth的键对应的值</li>
</ul>
</li>
<li>STORE选项<ul>
<li>SORT 例如（students ALPHA STORE sorted_students）  sort命令只向客户端返回排序结果，而不保存排序结果，通过使用STORE选项，我们可以将排序结果保存在指定的键里面</li>
<li>这里实际实现时，先排序，排序完成后，检查sorted_students键是否存在，存在删除，设置一个空的sorted_students键，然后依次压入，完成存储</li>
</ul>
</li>
<li>多选项执行顺序<ul>
<li>排序：在这一步，命令会使用ALPHA、ASC或DESC、BY这几个选项，对输入键进行排序，并得到一个排序结果集</li>
<li>限制排序结果集的长度：在这一步，命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中。</li>
<li>获取外部键：在这一步，命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。</li>
<li>保存排序结果集：在这一步，命令会使用STORE选项，将排序结果集保存到指定的键上面去。</li>
<li>向客户端返回排序结果集：在最后这一步，命令遍历排序结果集，并依次向客户端返回排序结果集中的元素。</li>
<li>调用SORT命令时，除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。（GET选项顺序不一样，导致取数不一样，所以会影响）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h4><ul>
<li><p>GETBIT：用于返回位数组bitarray在offset偏移量上的二进制位的值</p>
<ul>
<li>命令格式  GETBIT <bitarray> <offset><ul>
<li>计算byte=offset÷8」，byte值记录了offset偏移量指定的二进制位保存在位数组bitarray的哪个字节</li>
<li>计算bit=（offset mod 8）+1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li>
<li>根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位，并返回这个位的值。</li>
</ul>
</li>
<li>例如：GETBIT <bitarray> 3    <ul>
<li>3÷8」的值为0</li>
<li>（3 mod 8）+1的值为4。</li>
<li>定位到buf[0]字节上面，然后取出该字节上的第4个二进制位（从左向右数）的值。</li>
<li>向客户端返回二进制位的值1。</li>
</ul>
</li>
</ul>
</li>
<li><p>SETBIT命令：SETBIT用于将位数组bitarray在offset偏移量上的二进制位的值设置为value，并向客户端返回二进制位被设置之前的旧值</p>
<ul>
<li>命令格式：SETBIT <bitarray> <offset><value><ul>
<li>定位二进制数组第几个字节第几位和GETBIT一样（多了一步对数组长度检查，长度不够会扩展）</li>
<li>设置新值value为这个二进制位的值</li>
<li>向客户端返回oldvalue变量的值</li>
</ul>
</li>
</ul>
</li>
<li><p>BITCOUNT命令：用于统计给定位数组中，值为1的二进制位的数量。</p>
<ul>
<li><p>算法实现：</p>
<ul>
<li><p>遍历</p>
</li>
<li><p>查表算法：空间换时间，我们可以创建一个表，表的键为某种排列的位数组，而表的值则是相应位数组中，值为1的二进制位的数量，如16位，则一个二进制位数组，没16位组合查一次表直接获得值。</p>
</li>
<li><p>variable-precision SWAR算法（因为swar函数是一个常数复杂度的操作，所以我们可以按照自己的需要，在一次循环中多次执行swar，从而按倍数提升计算汉明重量的效率，1次32位）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">swar</span><span class="params">(<span class="keyword">uint32_t</span> i)</span></span>&#123;</span><br><span class="line">    i=(i &amp; <span class="number">0x55555555</span>) + ((i&gt;&gt;<span class="number">1</span>)&amp;<span class="number">0x55555555</span>);<span class="comment">//步骤1</span></span><br><span class="line">    i=(i &amp; <span class="number">0x33333333</span>) + ((i&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x33333333</span>);<span class="comment">//步骤2</span></span><br><span class="line">    i=(i &amp; <span class="number">0x0F0F0F0F</span>) + ((i&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0x0F0F0F0F</span>);<span class="comment">//步骤3</span></span><br><span class="line">    i=(i * (<span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);<span class="comment">//步骤4</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>❑步骤1计算出的值i的二进制表示可以按每两个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</p>
<p>❑步骤2计算出的值i的二进制表示可以按每四个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</p>
<p>❑步骤3计算出的值i的二进制表示可以按每八个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</p>
<p>❑步骤4的i*0x01010101语句计算出bitarray的汉明重量并记录在二进制位的最高八位，而＞＞24语句则通过右移运算，将bitarray的汉明重量移动到最低八位，得出的结果就是bitarray的汉明重量。</p>
</li>
<li><p>redis实现：</p>
<ul>
<li>如果未处理的二进制位的数量小于128位，那么程序使用查表算法来计算二进制位的汉明重量。：查表算法使用键长为8位的表，表中记录了从00000000到1111 1111在内的所有二进制位的汉明重量</li>
<li>如果未处理的二进制位的数量大于等于128位，那么程序使用variable-precision SWAR算法来计算二进制位的汉明重量：variable-precision SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision SWAR算法来计算这128个二进制位的汉明重量。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>BITOP命令：BITOP AND <key> <bitarray> <bitarray>（例如：BITOP AND result x y）</p>
<ul>
<li>在执行BITOP AND命令时，程序用&amp;操作计算出所有输入二进制位的逻辑与结果，然后保存在指定的键上面</li>
<li>在执行BITOP OR命令时，程序用|操作计算出所有输入二进制位的逻辑或结果，然后保存在指定的键上面</li>
<li>在执行BITOP XOR命令时，程序用^操作计算出所有输入二进制位的逻辑异或结果，然后保存在指定的键上面</li>
<li>在执行BITOP NOT命令时，程序用~操作计算出输入二进制位的逻辑非结果，然后保存在指定的键上面</li>
</ul>
</li>
</ul>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><ul>
<li><p>定义：Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度（服务器使用先进先出的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除）</p>
<ul>
<li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上</li>
<li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。</li>
</ul>
</li>
<li><p>慢查询记录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redusServer</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;<span class="comment">//下一条慢查询日志的id</span></span><br><span class="line">    <span class="built_in">list</span> *slowlog;<span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than;<span class="comment">//执行超过多少时间的命令记录到日志</span></span><br><span class="line">    <span class="keyword">unsigned</span> slowlog-max-len;<span class="comment">//服务器最多保存多少条慢查询日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;<span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">time_t</span> time;<span class="comment">//命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration;<span class="comment">//执行命令消耗的时间，以微妙为单位</span></span><br><span class="line">    robj **argv;<span class="comment">//命令与命令参数</span></span><br><span class="line">    <span class="keyword">int</span> argc;<span class="comment">//命令与命令参数的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>慢查询命令</p>
<ul>
<li>SLOWLOG GET命令查询所有的慢查询日志</li>
<li>SLOWLOG LEN命令查看日志数量</li>
<li>SLOWLOG RESET命令清除所有慢查询日志</li>
</ul>
</li>
<li><p>添加新日志（slowlogPushEntryIfNeeded函数完成）</p>
<ul>
<li>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，服务器会将这个时长作为参数之一传给slowlogPushEntryIfNeeded函数<ul>
<li>检查命令的执行时长是否超过slowlog-log-slower-than选项所设置的时间，如果是的话，就为命令创建一个新的日志，将redisServer.slowlog_entry_id的值增1，并将新日志添加到slowlog链表的表头，</li>
<li>检查慢查询日志的长度是否超过slowlog-max-len选项所设置的长度，如果是的话，那么将多出来的日志从slowlog链表中删除掉。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><p>发送MONITOR命令可以让一个普通客户端变为一个监视器，客户端的REDIS_MONITOR标志会被打开，并且这个客户端本身会被添加到monitors链表的表尾；服务器在每次处理命令请求之前，都会调用replicationFeedMonitors函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>谢谢你请我吃糖!</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="zhhw 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhhw 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a>
              <a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i> Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/14/JVM%E7%AF%87/" rel="prev" title="JVM">
      <i class="fa fa-chevron-left"></i> JVM
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">Redis数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.0.1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.0.2.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">2.0.3.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="nav-number">2.0.4.</span> <span class="nav-text">跳跃表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="nav-number">2.0.5.</span> <span class="nav-text">整数集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">2.0.6.</span> <span class="nav-text">压缩列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.0.7.</span> <span class="nav-text">对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">单机数据库的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.0.1.</span> <span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="nav-number">3.0.2.</span> <span class="nav-text">过期键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.0.3.</span> <span class="nav-text">RDB持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.0.4.</span> <span class="nav-text">AOF持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.0.5.</span> <span class="nav-text">事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">4.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">多机数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6"><span class="nav-number">6.0.1.</span> <span class="nav-text">复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B"><span class="nav-number">6.0.2.</span> <span class="nav-text">心跳检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel%EF%BC%88%E5%93%A8%E5%85%B5%EF%BC%89"><span class="nav-number">6.0.3.</span> <span class="nav-text">Sentinel（哨兵）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4"><span class="nav-number">7.</span> <span class="nav-text">集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD"><span class="nav-number">8.</span> <span class="nav-text">独立功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="nav-number">8.0.1.</span> <span class="nav-text">发布与订阅</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">8.0.2.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LUA%E8%84%9A%E6%9C%AC"><span class="nav-number">8.0.3.</span> <span class="nav-text">LUA脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">8.0.4.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E6%95%B0%E7%BB%84"><span class="nav-number">8.0.5.</span> <span class="nav-text">二进制位数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">8.0.6.</span> <span class="nav-text">慢查询日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E8%A7%86%E5%99%A8"><span class="nav-number">8.0.7.</span> <span class="nav-text">监视器</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhhw</p>
  <div class="site-description" itemprop="description">欢迎联系</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhhw137" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhhw137" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:13717737201@163.com" title="Mail → mailto:13717737201@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020/8 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhhw</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'KgdHuT3kltgIrgNT6o76hovl-gzGzoHsz',
      appKey     : '6phircWV4C7FajDWFXruKbr9',
      placeholder: "不说点啥？",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
